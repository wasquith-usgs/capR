

################################################################
##    capR Source File ./AAAUtilities/catme.R
################################################################
"catme" <- 
function(...) {
  cat(c(...,"\n"),sep=" ");
}


catme2 <-
function(...) {
  cat(c(...,"\n"),sep="");
}



################################################################
##    capR Source File ./AAAUtilities/hashtools.R
################################################################
"new.h" <- function() new.env(hash=TRUE)
"is.h"  <- function(hash) {
    ifelse(  is.environment(hash) &&
           ! is.null(env.profile(hash)),
        return(TRUE), return(FALSE))
}
"len.h" <- function(hash) {
    if(! is.h(hash)) {
        warning("need hash"); return(NULL)
    }
    return(length(ls(envir=hash)))
}
"set.h" <- function(key, val, hash) {
    if(! is.h(hash)) {
        warning("missing hash"); return(NULL)
    }
    assign(as.character(key), val, envir=hash)      
}
"setnum.h" <- function(key, val, hash) {
   if(is.null(val)) {
      set.h(key, val, hash);
   } else {
      set.h(key, as.numeric(val), hash);
   }
}
"setint.h" <- function(key, val, hash) {
   if(is.null(val)) {
      set.h(key, val, hash);
   } else {
      set.h(key, as.integer(val), hash);
   }
}
"setchar.h" <- function(key, val, hash) {
   if(is.null(val)) {
      set.h(key, val, hash);
   } else {
      set.h(key, as.character(val), hash);
   }
}
"setlog.h" <- function(key, val, hash) {
   if(is.null(val)) val <- FALSE;
   val <- as.logical(val);
   if(is.na(val)) val <- FALSE;
   set.h(key, val, hash);
}
"get.h" <- function(key, hash, default=NULL) {
    if(! is.h(hash)) {
        warning("need hash"); return(NULL)
    }
    key <- as.character(key)
    ifelse(exists(key, envir=hash),
        return(get(key, hash)), return(default))
}
"del.h" <- function(key, hash) {
    if(! is.h(hash)) {
        warning("need hash"); return(NULL)
    }
    key <- as.character(key)
    if(exists(key, envir=hash)) {
        rm(list=c(key), envir=hash)
        return(TRUE)
    }
    return(FALSE)
}
"has.key"  <- function(key, hash) {
    if(! is.h(hash)) {
        warning("need hash"); return(NULL)
    }
    return(exists(as.character(key), envir=hash))
}
"keys.h" <- function(hash) {
    if(! is.h(hash)) {
        warning("missing hash"); return(NULL)
    }
    return(ls(envir=hash))
}
"vals.h" <- function(hash,
               mode=c("character", "numeric")) {
    mode <- match.arg(mode)
    if(! is.h(hash)) {
        warning("need hash"); return(NULL)
    }
    l <- as.list(hash); n <- length(l)
    if(n == 0) invisible(NULL)
    v <- vector("character", n)
    for(i in 1:n) v[i] <- l[[i]]
    if(mode == "numeric") v <- as.numeric(v)
    return(v)
}
"each.h" <- function(hash) {
    if(! is.h(hash)) {
        warning("need hash"); return(NULL)
    }
    return(as.list(hash))
}
"clear.h" <- function(hash) {
    if(! is.h(hash)) {
        warning("need hash"); return(NULL)
    }
    rm(list=keys.h(hash), envir=hash)
}
"tag.h" <- function(hash, key="my.hexid") {
    assign(key, capture.output(hash), hash)
}


################################################################
##    capR Source File ./AAAUtilities/prettyOutputSubs.R
################################################################
"splashbars" <-
function(bar="-") {
  bars <- paste(rep(bar, options()$width), sep="", collapse="");
  catme(bars);
}

"capRheader" <-
function(approach=NULL, splash=TRUE) {
  splashbars();
  catme("    capR (TWRI Culvert Analysis Program in R)\n",
        "   by William H. Asquith, USGS, Lubbock, Texas");
  if(splash) splashbars();
  catme("Culvert system at", approach$station.id, approach$station.name);
  if(splash) splashbars();
}


"printCvalueSummary" <-
function(flow=NULL, culvert=NULL, splash=TRUE, verbose=FALSE, ...) {
  if(splash) splashbars();
  catme("kbev: ",culvert$kbev);
  if(splash) splashbars();
}


"printFlow" <-
function(type, h1=h1, h4=h4, flow=NULL, culvert=NULL, approach=NULL,
         splash=TRUE, verbose=FALSE, datetime="not provided", ...) {

  if(! flow$valid) {
    catme("FLOW IS NOT VALID, assume discharge = 0 and continue with output.");
    printApproach(discharge=0, approach=approach,
                  culvert=culvert, splash=splash);
    return(NA);
  }

  lunits <- culvert$lengthunits;
  qunits <- culvert$flowunits;
  aunits <- culvert$areaunits;

  Qculvert <- flow$Q; # extract the culvert flow
  Qroad <- 0;
  if(length(flow$roadflow$is.flow) && flow$roadflow$is.flow) {
     Qroad <- flow$roadflow$Qroad;
  }
  Qtotal   <- Qculvert + Qroad;

  catme("CULVERT FLOW SUMMARY:",culvert$name);
  catme("   Date of data",datetime);
  if(type == "SAC") {
    catme(" Type is SAC or 2-section slope-area based on horizontal\n",
          "projection of h1 and h4 into the inlet and outlet, respectively."); 
    catme(" Flow is",Qculvert, qunits,"Is this a reliable estimate?\n");
    catme(" Headwater (h1, gage height, no datum offset) is", h1, lunits, "\n",
          "Tailwater (h4, gage height, no datum offset) is", h4, lunits);
    catme(" -------");
    printTypeSAC(flow=flow, culvert=culvert, ...);  
  } else {
    err <- flow$error;
    catme(" Type", type,"culvert discharge is", Qculvert, qunits, "\n",
          "     with error=", round(err, digits=6), qunits,
          "in", flow$its, "iterations.");
    catme(" Discharge coefficient (C) is", flow$C, "dimensionless");
    catme(" Headwater (h1, gage height, no datum offset) is", h1, lunits, "\n",
          "Tailwater (h4, gage height, no datum offset) is", h4, lunits);
    catme(" Total head (H) is", round(flow$H, digits=3), lunits);
    catme(" -------");
    switch(type,
           printType1(flow=flow, culvert=culvert, ...),
           printType2(flow=flow, culvert=culvert, ...),
           printType3(flow=flow, culvert=culvert, ...),
           printType4(flow=flow, culvert=culvert, ...),
           printType5(flow=flow, culvert=culvert, ...),
           printType6(flow=flow, culvert=culvert, ...));
    if(culvert$ignore.approach.velocity.head) {
       catme("  Culvert is configured to ignore approach velocity head (v1head).");
    } else {
       catme("  Culvert is configured to use approach velocity head (v1head).");
    }
    if(culvert$ignore.approach.losses) {
       catme("  Culvert is configured to ignore approach losses (hf12).");
    } else {
       catme("  Culvert is configured to use approach losses (hf12).");
    }
  }
  printApproach(discharge=Qtotal, approach=approach,
                culvert=culvert, splash=splash);

  if(length(flow$roadflow$is.flow) && flow$roadflow$is.flow) {
     printRoadFlow(flow$roadflow, culvert=culvert, splash=splash);
     if(splash) splashbars();
     catme("TOTAL FLOW (Qculvert + Qroad) is",
            round(Qtotal, digits=4), qunits);
  }

  if(splash) splashbars();
}



################################################################
##    capR Source File ./ApproachSection/geoXsec.R
################################################################
"geoXsec" <-
function(h, xsec=NULL, subdivision=NULL, nvalue=NULL, manningcor=1.486,
         plotem=FALSE, xfudge=0.001, tag="") {

   n.subs <- length(subdivision);
  n.nvals <- length(nvalue);

  mainpdf <- paste(c("TMPcapR_geoXsec",tag,".pdf"),sep="",collapse="");
  zall <- geoXsecSimple(h, xsec=xsec, nvalue=mean(nvalue),
                        plotem=plotem, xfudge=0.001,
                        pdffile=mainpdf);
  if(n.subs == 0) {
    if(is.list(zall)) {
      zall$alpha <- 1;
      zall$AREATOTAL   <- zall$A;
      zall$KONVEYTOTAL <- zall$KONVEY;
    }
  	return(zall);
  }

  A <- K <- vector(mode = "numeric");
  i <- 0; j <- 0;
  while(i < n.subs) {
      i <- i + 1;
      if(i == 1 | n.subs == 1) {
      print("FIRST SUBDIVISION");
      locxsec <- xsec[xsec$X <= subdivision[i], ];
      tmpx <- c(locxsec$X,
                locxsec$X[length(locxsec$X)],
                subdivision[i]);
      tmpy <- c(locxsec$Y,
                locxsec$Y[length(locxsec$Y)],
                h);
      locxsec <- data.frame(X=tmpx, Y=tmpy);
      #print(locxsec);
      txt <- paste(c("TMPcapR_geoXsecFIRST",tag,".pdf"), sep="", collapse="");
      z <- geoXsecSimple(h, locxsec,  nvalue=nvalue[i], manningcor=manningcor,
                         plotem=plotem, xfudge=0.001,
                         pdffile="TMPcapR_geoXsecFIRST.pdf");
      j <- j + 1;
      if(is.list(z)) {
        A[j] <- z$A; K[j] <- z$KONVEY;
      } else {
        A[j] <- NA;  K[j] <- NA;
      }
    }
    if(i == n.subs) {
      print("LAST SUBDIVISION");
      locxsec <- xsec[xsec$X >= subdivision[n.subs],];
      tmpx <- c(subdivision[i],
                locxsec$X);
      tmpy <- c(h,
                locxsec$Y);
      locxsec <- data.frame(X=tmpx, Y=tmpy);
      #print(locxsec);
      txt <- paste(c("TMPcapR_geoXsecLAST",tag,".pdf"), sep="", collapse="");
      z <- geoXsecSimple(h, locxsec,  nvalue=nvalue[i], manningcor=manningcor,
                   plotem=plotem, xfudge=0.001,
                   pdffile=txt);
      j <- j + 1;
      if(is.list(z)) {
        A[j] <- z$A; K[j] <- z$KONVEY;
      } else {
        A[j] <- NA;  K[j] <- NA;
      }
    } else {
      print("CENTRAL SUBDIVISION");
      locxsec <- xsec[xsec$X >= subdivision[i] &
                      xsec$X <= subdivision[i+1],];
      tmpx <- c(subdivision[i],
                locxsec$X,
                locxsec$X[length(locxsec$X)],
                subdivision[i+1]);
      tmpy <- c(h,
                locxsec$Y,
                locxsec$Y[length(locxsec$Y)],
                h);
      locxsec <- data.frame(X=tmpx, Y=tmpy);
      #print(locxsec);
      txt <- paste(c("TMPcapR_geoXsec",i,tag,".pdf"), sep="", collapse="");
      z <- geoXsecSimple(h, locxsec,  nvalue=nvalue[i], manningcor=manningcor,
                         plotem=plotem, xfudge=0.001,
                         pdffile=txt);
      if(is.list(z)) {
        A[j] <- z$A; K[j] <- z$KONVEY;
      } else {
        A[j] <- NA;  K[j] <- NA;
      }
    }
  }
  AREATOTAL   <- sum(A);
  KONVEYTOTAL <- sum(K);
  alpha <- Alpha(area=A, konvey=K);
  zall$alpha <- alpha;
  zall$AREATOTAL <- AREATOTAL;
  zall$KONVEYTOTAL <- KONVEYTOTAL;
  return(zall);
}


#xsec <- data.frame(X=1:11, Y=c(12,11,5,6,7,8,9,0,4,7,12))
#print(geoXsec(runif(1,min=0, max=10),xsec, nvalue=0.035, plotem=TRUE))
#


#xsec <- data.frame(X=1:11, Y=c(12,11,5,6,7,8,9,0,4,7,12))
#print(geoXsec(runif(1,min=0, max=10),xsec, subdivision=c(7.01), nvalue=c(0.050, 0.035), plotem=TRUE))


################################################################
##    capR Source File ./ApproachSection/geoXsecSimple.R
################################################################
"geoXsecSimple" <-
function(h, xsec=NULL, nvalue=NULL, manningcor=1.486,
            plotem=FALSE, xfudge=0.001,
            pdffile="TMPgeoXsecSimple.pdf") {
  xs <- xsec$X;  ys <- xsec$Y;
  n <- length(ys);

  xs <- xs + xfudge*(1:n);

  xmin <- min(xs); xmax <- max(xs);
  ymin <- min(ys); ymax <- max(ys);
  if(h >= ys[1]) {
     txt <- paste(c("height of ",h," is greater than left end ",
                    "point of cross section, setting edge to height"),
                  collapse="");
     warning(txt);
     ys[1] <- h;
  }
  if(h >= ys[n]) {
     txt <- paste(c("height of ",h," is greater than right end ",
                    "point of cross section, setting edge to height"),
                    collapse="");
     warning(txt);
     ys[n] <- h;
  }
  if(h <= ymin) {
     txt <- paste(c("height of ",h," is less than minimum, ",
                    "setting height to minimum"),
                  collapse="");
     warning(txt);
     h <- ymin;
  }

  xs2 <- xs; ys2 <- ys;
  nx <- ny <- vector(mode = "numeric");
  e <- 0;
  for(i in 1:(n-1)) {
  	if(ys[i] > h & ys[i+1] < h) {
      e <- e + 1;
      if(xs[i] != xs[i+1]) {
    	nx[e] <- approx(c(ys[i], ys[i+1]), y=c(xs[i], xs[i+1]), h)$y
      } else {
        nx[e] <- xs[i];
      }
      ny[e] <- h;
  	} else if(ys[i] < h & ys[i+1] > h) {
  	  e <- e + 1;
      if(xs[i] != xs[i+1]) {
    	nx[e] <- approx(c(ys[i], ys[i+1]), y=c(xs[i], xs[i+1]), h)$y
      } else {
        nx[e] <- xs[i];
      }
      ny[e] <- h;
  	}
  }
  xs2 <- xs2[ys2 <= h]; ys2 <- ys2[ys2 <= h];
  xs2 <- c(xs2, nx); ys2 <- c(ys2, ny);
  idx <- sort(xs2, index.return=TRUE);
  xs2 <- xs2[idx$ix]; ys2 <- ys2[idx$ix];
  n2  <- length(ys2);

  if(n2 < 3) return(0);

  new.x.again <- new.y.again <- vector(mode = "numeric");
  j <- 0;
  for(i in 1:n2) {
  	j <- j + 1;
  	new.x.again[j] <- xs2[i];
  	new.y.again[j] <- ys2[i];
  	if(i < n2 & ys2[i] == h & ys2[i+1] == h) {
  		j <- j + 1;
  	  	new.x.again[j] <- new.y.again[j] <- NA;
  	}
  }
  xs2 <- new.x.again; ys2 <- new.y.again;

  rx <- xs2[! is.na(ys2)]; ry <- ys2[! is.na(ys2)];
  rn <- length(ry);
  area <- sum( (h - (ry[1:(rn-1)] + ry[2:rn    ])/2 ) *
                    (rx[2:rn    ] - rx[1:(rn-1)])   );

   #print(rx);
   #print(ry);
   #print(rn);

  "hypoth" <- function(i) {
  	y1 <- ys2[i]; y2 <- ys2[i+1];
    if( any( is.na( c(y1, y2) ) ) ) return(0);
  	ifelse(y2 <= h, return(sqrt((xs2[i+1] - xs2[i])^2 + (y2 - y1)^2)),
  	               return(0));
  }
  wettedperimeter <- sum(sapply(1:(rn-1),hypoth));

  "TW" <- function(i) {
     #print(ry[i]);
     #print(ry[i+1]);
     return(rx[i+1] - rx[i]);
     #ifelse((ry[i] = h & ry[i+1] == h), return(0), return(rx[i+1] - rx[i]));
  }
  topwidth <- sum(sapply(1:(rn-1),TW));


  if(plotem) {
  	pdf(pdffile);
    xc <- c(xs2, xs2[n], xs2[1]); yc <- c(ys2, h, h);
  	plot(xs,ys, type="b", lty=2, cex=2,
  	     xlab="STATION, IN FEET",
  	     ylab="HEIGHT, IN FEET");
    polygon(xc,  yc, col=rgb(0.95,0.95,0.95), border=NA);
    points(xs2, ys2, pch=16)
    lines(xs2,  ys2, lwd=3);
    dev.off();
  }
  hydraulicradius <- area/wettedperimeter;
  ifelse(is.null(nvalue), konvey <- NA,
            konvey <- Conveyance(A=area, R=hydraulicradius,
                                 nvalue=nvalue, manningcor=manningcor));

  z <- list(HEIGHT  = h,
            N      = nvalue,
            DBAR   = area/topwidth,
            A      = area,
            TW     = topwidth,
            WP     = wettedperimeter,
            HR     = hydraulicradius,
            KONVEY = konvey);
  return(z);
}


"demo.geoXsecSimple" <-
function(ask=TRUE) {
  if (ask) {
    oask <- devAskNewPage(TRUE)
    on.exit(devAskNewPage(oask))
  }

  xsec <- data.frame(X=1:11, Y=c(12,11,5,6,7,8,9,0,4,7,12))
  print(geoXsec(runif(1,min=0, max=10),xsec, plotem=TRUE))

  xsec <- data.frame(X=c( 1,  1,  1, 1, 4, 4, 4,  4),
                     Y=c(13, 11, 10, 0, 0, 2, 6, 13))
  print(geoXsecSimple(runif(1,min=0, max=10),xsec, plotem=TRUE))


  xsec <- data.frame(X=c( 1,  1.05, 3.99,  4),
                     Y=c(13, 0, 0, 13))
  print(geoXsecSimple(runif(1,min=0, max=10),xsec, plotem=TRUE))


  xsec <- data.frame(X=c( 1,  10,  20),
                     Y=c(10, 0, 10))
  print(geoXsecSimple(runif(1,min=0, max=10),xsec, plotem=TRUE))

  xsec <- data.frame(X=c( 1,  10,  10),
                     Y=c(10, 0, 10))
  print(geoXsecSimple(runif(1,min=0, max=10),xsec, plotem=TRUE))


  xsec <- data.frame(X=c( 0,  10,  10,  15,  20, 30, 30),
                     Y=c(10,   0,    10,  10,  10, 0, 10))
  print(geoXsecSimple(runif(1,min=0, max=14),xsec, plotem=TRUE))

  x <- seq(-10,10,by=0.1)
  B <- 10
  h <- runif(1,min=0, max=14)
  xsec <- data.frame(X=x, Y=x^2)
  print(geoXsecSimple(h,xsec, plotem=TRUE))

  x <- seq(-10,10,by=0.1)
  B <- 10; h <- runif(1,min=0, max=14);
  xsec <- data.frame(X=c(x,x+20), Y=c(x^2,x^2))
  print(geoXsecSimple(h,xsec, plotem=TRUE))


}


################################################################
##    capR Source File ./ApproachSection/printApproach.R
################################################################
"printApproach" <-
function(discharge=0, approach=NULL, culvert=NULL,
         splash=TRUE, verbose=FALSE, ...) {

  lunits <- culvert$lengthunits;
  aunits <- culvert$areaunits;
  vunits <- culvert$velunits;
  qunits <- culvert$flowunits;
  
  g <- culvert$gravity;
  g2 <- 2*g;
  
  if(splash) splashbars();

  catme("APPROACH SUMMARY");
  catme("  Approach Attributes");
  catme("    Approach is", approach$Lapproach, lunits,
        "upstream of inlet, and normal-to-inlet the approach");
  catme("      conveys a", approach$fraction.of.flow, "fraction of total flow.",
        "The Manning's n-value is", approach$nvalue, "dimensionless.");
      
  geo <- approach$geometry;
  vel <- approach$fraction.of.flow*discharge/geo$AREATOTAL;
  
  Fr <- Froude(discharge=approach$fraction.of.flow*discharge,
               area=geo$AREATOTAL, topwidth=geo$TW,
               alpha=geo$alpha, g=g);
  flow.regime <- ifelse(Fr >= 1, "supercritical.", "subcritial.");
  
  catme("  Summary of Approach Geometry");
  catme("    Cross-sectional area is", round(geo$AREATOTAL,  digits=3),aunits,
        "for height (gage height) of",geo$HEIGHT, lunits);
  catme("    Hydraulic depth (A/TW) is",  round(geo$DBAR, digits=3),lunits,
        "for topwidth of",                round(geo$TW, digits=2),lunits);
  catme("    Hydraulic radius (A/WP) is", round(geo$HR, digits=3),lunits,
        "for wetted perimeter of",        round(geo$WP, digits=2),lunits);
  catme("    Conveyance is",              round(geo$KONVEYTOTAL, digits=0),
        qunits);
  catme("    Velocity is", round(vel, digits=3),vunits,
        "considering the fraction of flow.");
  catme("    Velocity head with alpha of", round(geo$alpha, digits=2),
       "is", round(geo$alpha*vel^2/g2, digits=3),lunits,
       "considering the fraction of flow.");
  catme("    Froude number is", round(Fr,digits=2),
        "dimensionless; therefore, flow is", flow.regime);
}



################################################################
##    capR Source File ./ApproachSection/setApproach.R
################################################################
"setApproach" <-
function(station.id="",
         station.name="",
         Lapproach=0,
         nvalue=0.030,
         manningcor=1.486,
         X=c(0,0,20,20), Y=c(10,0,0,10), XY=NULL,
         subdivision=NULL,
         additional.flow=0,
         fraction.of.flow=1,
         skew.angle=0,
         time.series.in=NULL,
         time.series.out=NULL,
         forceEqualApproachHead=TRUE,
         forceIgnoreApproachHead=FALSE,
         useApproachHeadApportioning=FALSE,
         ...) {

  if(! is.null(XY)) {
     if(is.data.frame(XY)) {
       X <- XY$X;
       Y <- XY$Y;
     } else if(is.vector(XY)) {
       n <- length(XY);
       if(n %% 2 != 0) {
         stop("XY argument is not of even length for a paired X,Y requirement");
       }
       xs <- seq(1,n, by=2);
       ys <- xs+1;
       X <- XY[xs];
       Y <- XY[ys];
     }
     else {
        stop("XY argument given, but not data.frame or vector");
     }
  }
  if(length(X) != length(Y)) {
     stop("vectors of stationing and elevation on approach not equal length");
  }

  # There are as.numeric()s wrapped around the numerical arguments and
  # properties to provide a mode of protection immediately as the setting
  # of the approach. This was done in response to development of readApproach().
  X <- as.numeric(X); Y <- as.numeric(Y);
  skew.angle  <- as.numeric(skew.angle);
  skew.factor <- cos(skew.angle*pi/180);
  X.original <- as.numeric(X);
  Y.original <- as.numeric(Y);
  X <- X*skew.factor;

  tmp.h <- new.h();
  setchar.h("station.id",   station.id,   tmp.h);
  setchar.h("station.name", station.name, tmp.h);
  setchar.h("description",
        "Approach Section Properties", tmp.h);

  setnum.h("nvalue", nvalue,               tmp.h);
  setnum.h("manningcor", manningcor,       tmp.h);
  setnum.h("subdivision", subdivision,     tmp.h);
  setnum.h("Lapproach", Lapproach,         tmp.h);
  setnum.h("fraction.of.flow", fraction.of.flow,  tmp.h);

  set.h("skew.angle",  skew.angle,     tmp.h);
  set.h("skew.factor", skew.factor,    tmp.h);
  set.h("xsec",data.frame(X=X,Y=Y),    tmp.h);
  set.h("xsec.original",data.frame(X=X.original, Y=Y.original), tmp.h);
  setnum.h("min.elevation", min(Y),       tmp.h);

  set.h("time.series.in",  time.series.in,  tmp.h);
  set.h("time.series.out", time.series.out, tmp.h);

  setnum.h("additional.flow", additional.flow,      tmp.h);
  setnum.h("TMP.accumulated.flow", additional.flow, tmp.h);
  setnum.h("TMP.terminal.area.previous.run", 0,     tmp.h);
  setnum.h("TMP.konvey2.previous.run", 0,           tmp.h);

  set.h("forceEqualApproachHead",           forceEqualApproachHead, tmp.h);
  set.h("forceIgnoreApproachHead",         forceIgnoreApproachHead, tmp.h);
  set.h("useApproachHeadApportioning", useApproachHeadApportioning, tmp.h);

  nargs <- length(pairlist(...));
  if(nargs >= 1) {
     other.args <- pairlist(...);
     if(is.h(other.args$left.approach)) {
        set.h("left.approach",other.args$left.approach, tmp.h);
     }
     if(is.h(other.args$right.approach)) {
        set.h("right.approach",other.args$right.approach, tmp.h);
     }
  }
  return(tmp.h);
}



"readApproach" <-
function(file=NULL, sep="|", verbose=FALSE) {
  if(is.null(file) || ! file.exists(file)) {
     file <- file.choose();
  }
  message("Reading approach properties file ", file);
  D <- read.table(file, sep=sep, header=TRUE, as.is=TRUE);
  if(verbose) print(D);

  tmphash <- new.h(); # tmp hash, which will be used to form named arguments

  for(i in (1:length(D$KEY))) { # loop through each key
     key <- D$KEY[i];
     if(length(grep("^#", key, perl=TRUE, value=TRUE)) == 1) {
        message("   Skipping ",key);
        next;
     }
     val <- D$VALUE[i];

     # next two substitutions strip out leading and trailing whitespace
     val <- gsub("^\\s+", "", val, perl=TRUE);
     val <- gsub("\\+s$", "", val, perl=TRUE);

     message("Parsing on key '", key, "' and value '", val,"'");
     if(key == "X" || key == "Y") { # treating these different
       message("   Found either X or Y and appending previous values");
       was  <- get.h(key, tmphash);
       vals <- as.numeric(unlist(strsplit(val, '\\s+', perl=TRUE)));
        val <- c(was, vals); # combine old and then the new
     }
     if(key == "XY") { # treating this type even more different
       message("   Found XY key, splitting on spaces and then comma");
       xy.dataframe <- get.h(key, tmphash);
       xy <- unlist(strsplit(val, '\\s+', perl=TRUE));
       #print(xy);
       n <- length(xy);
       x.vec <- y.vec <- vector(length=n);
       for(i in 1:length(xy)) {
          each.xy <- as.numeric(unlist(strsplit(xy[i], ',', perl=TRUE)));
          if(length(each.xy) == 2) {
             #print(each.xy);
             x.vec[i] <- each.xy[1];
             y.vec[i] <- each.xy[2];
          }
       }
       message("      X vector= ",x.vec);
       message("      Y vector= ",y.vec);
       val <- data.frame(X=c(xy.dataframe$X, x.vec),
                         Y=c(xy.dataframe$Y, y.vec));
     }
     if(has.key("XY", tmphash)) {
        message("   Found and XY key, so deleting X and Y keys");
        del.h("X", tmphash);
        del.h("Y", tmphash);
     }
     set.h(key, val, tmphash); # ONLY LOCATION SETTING THE KEY=VALUE
  }

  # it took a lot of searching figureout a means to get user input
  # to function as formal named arguments to a function. This is apparently
  # the R idiom to do just that.
  approach <- do.call("setApproach", as.list(tmphash));

  # note that setApproach does create this key
  set.h("external.approachfile", file, approach);

  return(approach);
}





"editApproach.subnval" <-
function(approach=NULL) {
  if(! is.h(approach)) {
     warning("An approach hash is needed as argument");
     return();
  }
  nvalue <- get.h("nvalue",      approach);
  subdiv <- get.h("subdivision", approach);
  if(is.null(subdiv)) subdiv <- NA;

  edited.val <- de(nvalue, subdiv,
                  Modes=c("numeric", "numeric"),
                  Names=c("NVALUE", "SUBDIVISION"));

  nvalue <- edited.val$NVALUE;
  subdiv <- edited.val$SUBDIVISION;
  if(length(subdiv) == 1 && is.na(subdiv)) subdiv <- NULL;
  set.h("nvalue",      nvalue, approach);
  set.h("subdivision", subdiv, approach);
}


"editApproach.xy" <-
function(approach=NULL) {
  if(! is.h(approach)) {
     warning("An approach hash is needed as argument");
     return();
  }

  XY   <- get.h("xsec.original", approach);
  skew.angle <- get.h("skew.angle",    approach);
  X.original <- XY$X; Y.original <- XY$Y;
  skew.factor <- cos(skew.angle*pi/180);

  edited.XY <- de(X.original,Y.original,
                  Modes=c("numeric", "numeric"),
                  Names=c("STATION", "ELEVATION"));

  X.original <- edited.XY$STATION; Y.original <- edited.XY$ELEVATION;
  ok <- complete.cases(X.original, Y.original);
  X.original <- X.original[ok]; Y.original <- Y.original[ok];
  ix <- sort(X.original, index.return=TRUE)$ix;
  X.original <- X.original[ix]; Y.original <- Y.original[ix];


  X <- X.original*skew.factor; Y <- Y.original;
  set.h("xsec.original", data.frame(X=X.original, Y=Y.original), approach);
  set.h("xsec",          data.frame(X=X,          Y=Y),          approach);
}


# Three temporary summations are kept associated with the approach
# section. accumulated.flow is the total flow running through the approach,
# terminal.area.previous.run is the total area of the terminal sections of
# one or more culvert objects and is used in computing the contraction ratio
# of the flow, konvey2.previous.run is the conveyance for the computation
# of the headloss from section 1 (approach) to all inlets.
"resetTMPvarsApproach" <-
function(approach=NULL) {
   set.h("TMP.accumulated.flow", approach$additional.flow, approach);
   set.h("TMP.terminal.area.previous.run", 0,     approach);
   set.h("TMP.konvey2.previous.run", 0,           approach);
}


"setApproachConditions" <-
function(depth=NULL, approach=NULL, ...) {
       nvalue <- approach$nvalue;
   manningcor <- approach$manningcor;
  subdivision <- approach$subdivision;
         xsec <- approach$xsec;
          geo <- geoXsec(h=depth, xsec=xsec, subdivision=subdivision,
                         nvalue=nvalue, manningcor=manningcor, ...);

  if(is.h(approach$left.approach)) {
           tmp.h <- approach$left.approach;
          nvalue <- tmp.h$nvalue;
     subdivision <- tmp.h$subdivision;
            xsec <- tmp.h$xsec;
        left.geo <- geoXsec(h=depth, xsec=xsec, subdivision=subdivision,
                            nvalue=nvalue, manningcor=manningcor,
                            tag="left", ...);
      geo$AREATOTAL   <- geo$AREATOTAL   + left.geo$AREATOTAL;
      geo$KONVEYTOTAL <- geo$KONVEYTOTAL + left.geo$KONVEYTOTAL;
     set.h("geometry",left.geo, approach$left.approach);
  }
  if(is.h(approach$right.approach)) {
           tmp.h <- approach$right.approach;
          nvalue <- tmp.h$nvalue;
     subdivision <- tmp.h$subdivision;
            xsec <- tmp.h$xsec;
       right.geo <- geoXsec(h=depth, xsec=xsec, subdivision=subdivision,
                            nvalue=nvalue, manningcor=manningcor,
                            tag="right", ...);
     geo$AREATOTAL   <- geo$AREATOTAL   + right.geo$AREATOTAL;
     geo$KONVEYTOTAL <- geo$KONVEYTOTAL + right.geo$KONVEYTOTAL;
     set.h("geometry",right.geo, approach$right.approach);
  }

  set.h("geometry",geo, approach);
}


"demo.multiple.approaches" <- function() {
   app.left  <- setApproach(nvalue=0.01);
   app.right <- setApproach(nvalue=0.03);
   app <- setApproach(nvalue=0.02,
                      left.approach=app.left,
                      right.approach=app.right);
   setApproachConditions(depth=4, approach=app, plotem=TRUE);
   print(each.h(app));
   print(each.h(app$left.approach));
   print(each.h(app$right.approach));
}




"reset.approachlength" <- function(length, approach) {
    oldlength <- get.h("Lapproach", approach)
    set.h("Lapproach", length, approach);
    return(oldlength)
}




################################################################
##    capR Source File ./CulvertProperties/graphCulvert.R
################################################################
"graphCulvert" <-
function(discharge=NULL, depth=NULL, culvert=NULL, verbose=FALSE,
         location=c("inlet", "outlet"), depression=0, usedatums=FALSE) {

  key <- culvert$TMP.key;
  location <- match.arg(location);
  if(location == "inlet") {
     my.location <- paste(c("CULVERT ",key," INLET"), collapse="");
     my.datum    <- culvert$zusinvert;
     my.center   <- culvert$inlet.centerline;
  } else {
     my.location <- paste(c("CULVERT ",key," OUTLET"), collapse="");
     my.datum    <- culvert$zdsinvert;
     my.center   <- culvert$outlet.centerline;
  }
  usedatums <- culvert$use.datums.when.graphing;
  if(! usedatums) {
     my.datum  <- 0;
     my.center <- 0;
  }

  D <- culvert$diameter;
  if(is.null(depth)) depth <- D - depression;

  if(is.null(discharge)) {
    yo <- NA;
    yc <- NA;
  } else {
    discharge <- discharge/culvert$number.of.barrels;
    yo <- getNormalDepth(discharge,   culvert=culvert,
                         location=location, depression=depression);
    yc <- getCriticalDepth(discharge, culvert=culvert,
                           location=location, depression=depression);
  }

  TW2 <- 0.5*setCulvertGeometry(depth=depth,
                                culvert=culvert, location=location,
                                depression=depression)$TW;
  TW.at.depth.neg <- -TW2;
  TW.at.depth.pos <-  TW2;

  depths <- sort(c(seq(0, D - depression, by=0.01), depth));
  n <- length(depths);
  #catme("Depth and depression:", depth, depression);
  #catme("Depths for drawing A:", max(depths));
  TW.neg <- TW.pos <- vector(mode="numeric", length=n);
  for(i in 1:n) {
     TW2 <- 0.5*setCulvertGeometry(depth=depths[i],
                                   culvert=culvert, location=location,
                                   depression=depression)$TW;
     TW.neg[i] <- -TW2;
     TW.pos[i] <-  TW2;
  }
  #catme("TW.neg", TW.neg);
  #catme("TW.pos", TW.pos);

   ys <- c(rev(depths), depths, D - depression);
  #catme("Depths for drawing B:", max(ys));
  TWs <- c(rev(TW.neg), TW.pos);
  if(culvert$altgeotype == "trapezoid") {
     TWs[2*n+1] <- min(TW.neg);
  } else {
     TWs[2*n+1] <- rev(TW.neg)[1];
  }

  #idx <- sort(TWs, index.return=TRUE)$ix;
  #catme("TWs", TWs);
  #catme("ys", ys);
  ifelse(culvert$lengthunits == "feet",
         my.lunits <- ", IN FEET",
         my.lunits <- ", IN METERS");
  my.xlab <- paste(c("DISTANCE FROM CENTER LINE", my.lunits),
                   sep="", collapse="");
  if(usedatums) {
     my.ylab <- paste(c("ELEVATION FROM CULVERT DATUM", my.lunits),
                      sep="", collapse="");
  } else {
     my.ylab <- paste(c("ELEVATION FROM CULVERT INVERT", my.lunits),
                      sep="", collapse="");
  }
  rngy <- range(ys);
  rngx <- range(TWs);
  if(rngx[2] - rngx[1] > rngy[2] - rngy[1]) {
    xlim <- c(rngx[1], rngx[2]);
    ylim <- c(0, rngx[2] - rngx[1]);
  } else {
    xlim <- c(-D/2, D/2);
    ylim <- c(   0, D  );
  }

    plot(TWs + my.center,
         ys + my.datum,
         type="l", tcl=0.5, lwd=3,
         xlim=xlim + my.center,
         ylim=ylim + my.datum,
         xlab=my.xlab, ylab=my.ylab, col=1);
    polygon(TWs[ys <= depth] + my.center,
            ys[ys <= depth] + my.datum,
            col=rgb(0.95,0.95,0.95));
    lines(c(TW.at.depth.neg, TW.at.depth.pos) + my.center,
          c(depth, depth) + my.datum,
          lwd=3);

    if(! is.na(yo)) {
       TW <- setCulvertGeometry(depth=yo, culvert=culvert,
                                location=location, depression=depression)$TW;
       if(verbose) {
          catme("Topwidth=", TW, "at normal depth=", yo, "\n");
       }
       lines(c(-0.5*TW, 0.5*TW) + my.center,
             c(yo,yo) + my.datum,
             lwd=1, lty=2);
    }
    if(! is.na(yc)) {
       TW <- setCulvertGeometry(depth=yc, culvert=culvert,
                                location=location, depression=depression)$TW;
       if(verbose) {
          catme("Topwidth=", TW, "at critical depth=", yc, "\n");
       }
       lines(c(-0.5*TW, 0.5*TW) + my.center,
             c(yc,yc) + my.datum,
             lwd=1, lty=4, col=rgb(0.5,0.5,0.5));
    }
    mtext(my.location, side=3);
    legend(min(TWs) + my.center,
           0.95*ylim[2] + my.datum,
           c("Free surface",
             "Normal depth (if applicable)",
             "Critical depth (if applicable)"),
           lty=c(1,2,4), lwd=c(3,1,1), cex=0.75, col=c(1,1,rgb(0.5,0.5,0.5)),
           bty="o", bg="white", box.lwd=4, box.col="white");

}




################################################################
##    capR Source File ./CulvertProperties/Lengths4MiteredPipe.R
################################################################
"Lengths4MiteredPipe" <-
function(h1, flowtype=NULL, d2=NULL, d3=NULL, culvert=NULL, approach=NULL) {

  Lw <- NULL; L <- NULL;

  Lapproach     <- approach$Lapproach;
  USmiterlength <- culvert$USmiterlength;
  DSmiterlength <- culvert$DSmiterlength;
  Ltopculvert   <- culvert$Ltop;
  Lbotculvert   <- culvert$Lbot;
              D <- culvert$diameter;

  if(is.null(USmiterlength) || is.null(DSmiterlength)) {
    return(list(L=Ltopculvert, Lw=Lapproach));
  }

  # vertical angle from inlet culvert invert turning up
  # to the miter (IN RADIANS)
  thetaUS <- pi/2 - acos((D - culvert$inlet.depression)/USmiterlength);

  # vertical angle from outlet culvert invert turning up
  # (looking upstream) to the miter (IN RADIANS)
  thetaDS <- pi/2 - acos((D - culvert$outlet.depression)/DSmiterlength);

  if(flowtype == 1) {
    hzD <- HeadwtrDiaRatio(h1=h1, culvert=culvert);
  	ifelse(hzD >= 1, intoculvert <- 0,
  	                 intoculvert <- d2/tan(thetaUS));
  	L  <- "L not applicable because flow is Type1"
  	Lw <- Lapproach - intoculvert;
  } else if(flowtype == 2 || flowtype == 3) {
    Lw <- Lapproach;
    intoculvert     <- d2/tan(thetaUS);
    backintoculvert <- d3/tan(thetaDS);
    L <- Lbotculvert - intoculvert - backintoculvert;
  } else if(flowtype >= 4) {
    Lw <- Lapproach;
    L  <- Ltopculvert;
  } else {
    stop("flow type indeterminate");
  }

  #catme("L=",L);
  #catme("Lw=",Lw);
  #catme("Lapproach=",Lapproach);

  return(list(L=L, Lw=Lw));
}

#
#  other.lengths <-
#     Lengths4MiteredPipe(h1=h1, flowtype=flowtype,
#                         d2=d2, culvert=culvert,
#                         approach=approach)



################################################################
##    capR Source File ./CulvertProperties/MinFlowUtilities.R
################################################################
"setMinRecordables" <-
function(hwpin=NULL, twpin=NULL, culvert=NULL) {
   if(is.null(hwpin))    stop("Headwater pin elevation (min recordable) is NULL");
   if(is.null(twpin))    stop("Tailwater pin elevation (min recordable) is NULL");
   if(is.null(culvert))  stop("Culvert is NULL");

   if(! is.null(hwpin)) set.h("min.recordable.hw", hwpin, culvert);
   if(! is.null(twpin)) set.h("min.recordable.tw", twpin, culvert);
}


"computeMinFlowPin" <-
function(culvert=NULL, approach=NULL, del=0.001, verbose=TRUE, digits=2) {
   if(is.null(culvert))   stop("Culvert is NULL");
   if(is.null(approach))  stop("Approach is NULL");

   us.pin <- get.h("min.recordable.hw", culvert) + del;
   ds.pin <- get.h("min.recordable.tw", culvert) + del;
   min.recordable.flow <- computeFlow(h1=us.pin, h4=ds.pin, verbose=verbose,
                                      culvert=culvert, approach=approach);
   if(is.na(min.recordable.flow$Qsd)) {
      catme("*** Minimum recordable flow ('pin discharge') is",
            round(min.recordable.flow$Qtotal, digits=digits),
            culvert$flowunits,
            "of type", min.recordable.flow$type,"\n");
   } else {
      catme("*** Multiple solutions to minimum recordable flow",
            " ('pin discharge')---printing flow object\n");
      print(min.recordable.flow);
   }
   return(min.recordable.flow);
}





"computeMinFlowPivot" <-
function(h1=NULL, h4=NULL, culvert=NULL, approach=NULL, del=0.01,
         silent=TRUE, verbose=FALSE, digits=2) {
   if(is.null(culvert))   stop("Culvert is NULL");
   if(is.null(approach))  stop("Approach is NULL");

   zusinvert <- get.h("zusinvert", culvert);
   zdsinvert <- get.h("zdsinvert", culvert);
   us.pin <- get.h("min.recordable.hw", culvert);
   ds.pin <- get.h("min.recordable.tw", culvert);

   if(is.null(h1) && is.null(h4)) stop("Both h1 and h4 are NULL");

   if(is.null(h1) && us.pin > ds.pin && h4 > ds.pin) {
      print("Computation A:")
      top <- max(us.pin, zusinvert);
      bot <- max(h4, zdsinvert);
      h1s <- seq(top, bot, by=sign(bot - top)*del);
      i <- 0
      maxQ <- maxT <- maxh1 <- vector(mode="numeric")
      #print(h1s)
      for(h1 in h1s) {
         if(h1 <= zusinvert) next
         if(h4 >= h1) next
         flow <- NA
         try( flow <- computeFlow(h1=h1, h4=h4, verbose=verbose, ignore.early.out=TRUE,
                             culvert=culvert, approach=approach, silent=silent));
         Q <- max(flow$Qtotal, na.rm=TRUE);
         T <- paste(flow$Types, sep=",", collapse=";")
         i <- i + 1;
         maxQ[i] <- Q;
         maxT[i] <- T;
         maxh1[i] <- h1
      }
      if(length(Q) == 0) {
         stop("Ambiguous elevation conditions for a nonNULL h4, threshold discharge not available");
      }
      thresholdQ <- max(maxQ, na.rm=TRUE);
      ix <- seq(1,length(maxQ));
      DF <- data.frame(h1=maxh1, h4=rep(h4, length(maxQ)), Q=maxQ, Types=maxT)
      print(DF)
      plot(DF$h1, DF$Q, type="l",
           xlab="Headwater height, in length units",
           ylab="Maximum discharge for each headwater height, in length per time")
      thresholdh1 <- maxh1[ix[maxQ == thresholdQ]];
      typeh1 <- maxT[ix[maxQ == thresholdQ]]
      catme("ComputationA: The lowest recordable discharge threshold is",
            round(thresholdQ, digits=digits),  "if (when) h1 is",
            round(thresholdh1, digits=digits), "of type", typeh1, "\n");
      return(DF);
   }


   if(is.null(h4) && us.pin > zusinvert && us.pin > zdsinvert && ds.pin > zdsinvert) {
      print("Computation B:")
      bot <- min(ds.pin, zdsinvert);
      top <- max(ds.pin, zdsinvert);
      h4s <- seq(top, bot, by=-del);
      i <- 0
      maxQ <- maxT <- maxh4 <- vector(mode="numeric")
      for(h4 in h4s) {
         if(h4 <= zdsinvert) next
         if(h4 >= h1) next
         flow <- NA
         try( flow <- computeFlow(h1=h1, h4=h4, verbose=verbose, ignore.early.out=TRUE,
                             culvert=culvert, approach=approach, silent=silent));
         Q <- max(flow$Qtotal, na.rm=TRUE);
         T <- paste(flow$Types, sep=",", collapse=";")
         i <- i + 1;
         maxQ[i] <- Q;
         maxT[i] <- T;
         maxh4[i] <- h4;
         #cat(h1, h4, Q, T, sep="  ")
      }
      if(length(Q) == 0) {
         stop("Ambiguous elevation conditions for a nonNULL h1, threshold discharge not available");
      }
      thresholdQ <- max(maxQ, na.rm=TRUE);
      ix <- seq(1,length(maxQ))
      thresholdh4 <- maxh4[ix[maxQ == thresholdQ]];
      typeh4 <- maxT[ix[maxQ == thresholdQ]]
      DF <- data.frame(h1=rep(h1, length(maxh4)), h4=maxh4, Q=maxQ, Types=maxT)
      print(DF)
      plot(DF$h4, DF$Q, type="l",
           xlab="Tailwater height, in length units",
           ylab="Maximum discharge for each headwater height, in length per time")
      catme("ComputationB: The lowest recordable discharge threshold is",
            round(thresholdQ, digits=digits),  "if (when) h4 is",
            round(thresholdh4, digits=digits), "of type", typeh4, "\n");
      return(DF);
   }

   if(is.null(h4) && ds.pin < us.pin && h1 > us.pin) {
      print("Computation C:")
      bot <- min(ds.pin, zdsinvert);
      top <- max(us.pin, h1);
      h4s <- seq(top, bot, by=-del);
      i <- 0
      maxQ <- maxT <- maxh4 <- vector(mode="numeric")
      for(h4 in h4s) {
         if(h4 <= zdsinvert) next
         if(h4 >= h1) next
         flow <- NA
         try( flow <- computeFlow(h1=h1, h4=h4, verbose=verbose, ignore.early.out=TRUE,
                             culvert=culvert, approach=approach, silent=silent));
         Q <- max(flow$Qtotal, na.rm=TRUE);
         T <- paste(flow$Types, sep=",", collapse=";")
         i <- i + 1;
         maxQ[i] <- Q;
         maxT[i] <- T;
         maxh4[i] <- h4
      }
      if(length(Q) == 0) {
         stop("Ambiguous elevation conditions for a nonNULL h1, threshold discharge not available");
      }
      thresholdQ <- max(maxQ, na.rm=TRUE);
      ix <- seq(1,length(maxQ))
      thresholdh4 <- maxh4[ix[maxQ == thresholdQ]];
      typeh4 <- maxT[ix[maxQ == thresholdQ]]
      DF <- data.frame(h1=rep(h1, length(maxQ)), h4=maxh4, Q=maxQ, Types=maxT)
      print(DF)
      plot(DF$h4, DF$Q, type="l",
           xlab="Tailwater height, in length units",
           ylab="Maximum discharge for each headwater height, in length per time")
      thresholdh4 <- thresholdh4[length(thresholdh4)];
      catme("ComputationC: The lowest recordable discharge threshold is",
            round(thresholdQ, digits=digits),  "if (when) h4 is",
            round(thresholdh4, digits=digits), "of type", typeh4, "\n");
      return(DF);
   }

   stop("Ambiguous elevation conditions seemingly do not facilitate computation of threshold discharge")
}


"setMinRecordablesSystem" <-
function(hwpin=NULL, twpin=NULL, culverts=NULL) {
  if(! is.h(culverts)) {
     stop("Need hash of culverts to process");
  }

  keys <- keys.h(culverts);
  n.culverts <- length(keys);
  if(n.culverts < 1) {
     stop("*** Processing no culverts ***");
  }
  for(culvert.key in keys) {
     #catme("extracting culvert",culvert.key,"\n");
     the.culvert <- get.h(culvert.key, culverts);
     setMinRecordables(hwpin=hwpin, twpin=twpin, culvert=the.culvert);
  }
}


"computeMinFlowSystemPin" <-
function(culverts=NULL, approach=NULL, del=0.001, verbose=TRUE, digits=2) {
   if(! is.h(culverts)) {
     stop("Need hash of culverts to process");
   }
   if(is.null(approach)) stop("Approach is NULL");

   keys <- keys.h(culverts);
   us.pins <- ds.pins <- vector(mode="numeric");
   for(culvert.key in keys) {
     #catme("extracting culvert",culvert.key,"\n");
     the.culvert <- get.h(culvert.key, culverts);
     us.pin <- get.h("min.recordable.hw", the.culvert) + del;
     ds.pin <- get.h("min.recordable.tw", the.culvert) + del;
     us.pins <- c(us.pins, us.pin);
     ds.pins <- c(ds.pins, ds.pin);
   }
   us.sd.pins <- sd(us.pins);
   ds.sd.pins <- sd(ds.pins);
   if(us.sd.pins > 0 || ds.sd.pins > 0) {
      stop("Variability in the min.recordable.hw or min.recordable.tw ",
           "for the culvert system is present. The function ",
           "setMinRecordablesSystem() should be used to set these elevations ",
           "for all culverts in the system.");
   }

   us.pin <- us.pins[1];
   ds.pin <- ds.pins[1];

   min.recordable.flow <- computeFlowSystem(culverts=culverts, approach=approach,
                                            h1=us.pin, h4=ds.pin, verbose=verbose, show.pass.results=FALSE);
   if(is.na(min.recordable.flow$Qtotal)) {
      warning("Could not compute a minimum recordable flow for the ",
              "culvert system\n");
      return(NA);
   } else {
      catme("*** Minimum recordable flow ('pin discharge') for the",
            "culvert system is",
            round(min.recordable.flow$Qtotal, digits=digits),
            min.recordable.flow$flowunits,"\n");
   }
   return(min.recordable.flow);
}


"computeMinFlowSystemPivot" <-
function(h1=NULL, h4=NULL, culverts=NULL, approach=NULL, del=0.01,
         silent=TRUE, verbose=FALSE, digits=2) {

   if(! is.h(culverts)) {
     stop("Need hash of culverts to process");
   }
   if(is.null(approach)) stop("Approach is NULL");

   keys <- keys.h(culverts);
   us.pins <- ds.pins <- vector(mode="numeric");
   for(culvert.key in keys) {
     #catme("extracting culvert",culvert.key,"\n");
     the.culvert <- get.h(culvert.key, culverts);
     us.pin <- get.h("min.recordable.hw", the.culvert)
     ds.pin <- get.h("min.recordable.tw", the.culvert)
     us.pins <- c(us.pins, us.pin);
     ds.pins <- c(ds.pins, ds.pin);
   }
   us.sd.pins <- sd(us.pins);
   ds.sd.pins <- sd(ds.pins);
   if(us.sd.pins > 0 || ds.sd.pins > 0) {
      stop("Variability in the min.recordable.hw or min.recordable.tw ",
           "for the culvert system is present. The function ",
           "setMinRecordablesSystem() should be used to set these elevations ",
           "for all culverts in the system.");
   }
   us.pin <- us.pins[1];
   ds.pin <- ds.pins[1];
   message("us.pin=",us.pin,"  and ds.pin=",ds.pin)

   zusinverts <- zdsinverts <- vector(mode="numeric");
   for(culvert.key in keys) {
     #catme("extracting culvert",culvert.key,"\n");
     the.culvert <- get.h(culvert.key, culverts);
     us.invert <- get.h("zusinvert", the.culvert) + del;
     ds.invert <- get.h("zdsinvert", the.culvert) + del;
     zusinverts <- c(zusinverts, us.invert);
     zdsinverts <- c(zdsinverts, ds.invert);
   }
   zusinvert <- min(zusinverts);
   zdsinvert <- min(zdsinverts);
   message("zusinvert=",zusinvert,"  and zdsinvert=",zdsinvert)

   if(is.null(h1) && is.null(h4)) stop("Both h1 and h4 are NULL");

   if(is.null(h1) && us.pin > ds.pin && h4 > ds.pin) {
      message("ComputationA:")
      top <- max(us.pin, zusinvert);
      bot <- max(h4, zdsinvert);
      h1s <- seq(top, bot, by=-del);
      i <- 0
      maxQ <- maxT <- maxh1 <- vector(mode="numeric")
      #print(h1s)
      for(h1 in h1s) {
         if(h1 <= zusinvert) next
         if(h4 >= h1) next
         flow <- NA
         try( flow <- computeFlowSystem(h1=h1, h4=h4, verbose=verbose, ignore.early.out=TRUE,
                             culvert=culverts, approach=approach, silent=silent));
         Q <- max(flow$Qtotal, na.rm=TRUE);
         T <- paste(flow$Types, sep=",", collapse=";")
         i <- i + 1;
         maxQ[i] <- Q;
         maxT[i] <- T;
         maxh1[i] <- h1
         message("h1=",h1,"  h4=",h4,"  Q=",Q)
      }
      if(length(Q) == 0) {
         stop("Ambiguous elevation conditions for a nonNULL h4, threshold discharge not available");
      }
      thresholdQ <- max(maxQ, na.rm=TRUE);
      ix <- seq(1,length(maxQ));
      DF <- data.frame(h1=maxh1, h4=rep(h4, length(maxQ)), Q=maxQ, Types=maxT)
      print(DF)
      plot(DF$h1, DF$Q, type="l",
           xlab="Headwater height, in length units",
           ylab="Maximum discharge for each headwater height, in length per time")
      thresholdh1 <- maxh1[ix[maxQ == thresholdQ]];
      typeh1 <- maxT[ix[maxQ == thresholdQ]]
      catme("ComputationA: The lowest recordable discharge threshold is",
            round(thresholdQ, digits=digits),  "if (when) h1 is",
            round(thresholdh1, digits=digits), "of type", typeh1, "\n");
      return(DF);
   }


 if(is.null(h4) && us.pin > zusinvert && us.pin > zdsinvert && ds.pin > zdsinvert) {
      message("ComputationB:")
      bot <- min(ds.pin, zdsinvert);
      top <- max(ds.pin, zdsinvert);
      h4s <- seq(top, bot, by=-del);
      i <- 0
      maxQ <- maxT <- maxh4 <- vector(mode="numeric")
      for(h4 in h4s) {
         if(h4 <= zdsinvert) next
         if(h4 >= h1) next
         flow <- NA
         try( flow <- computeFlowSystem(h1=h1, h4=h4, verbose=verbose, ignore.early.out=TRUE,
                                        culvert=culverts, approach=approach, silent=silent));
         Q <- max(flow$Qtotal, na.rm=TRUE);
         T <- paste(flow$Types, sep=",", collapse=";")
         i <- i + 1;
         maxQ[i] <- Q;
         maxT[i] <- T;
         maxh4[i] <- h4;
         #cat(h1, h4, Q, T, sep="  ")
      }
      if(length(Q) == 0) {
         stop("Ambiguous elevation conditions for a nonNULL h1, threshold discharge not available");
      }
      thresholdQ <- max(maxQ, na.rm=TRUE);
      ix <- seq(1,length(maxQ))
      thresholdh4 <- maxh4[ix[maxQ == thresholdQ]];
      typeh4 <- maxT[ix[maxQ == thresholdQ]]
      DF <- data.frame(h1=rep(h1, length(maxh4)), h4=maxh4, Q=maxQ, Types=maxT)
      print(DF)
      plot(DF$h4, DF$Q, type="l",
           xlab="Tailwater height, in length units",
           ylab="Maximum discharge for each headwater height, in length per time")
      catme("ComputationB: The lowest recordable discharge threshold is",
            round(thresholdQ, digits=digits),  "if (when) h4 is",
            round(thresholdh4, digits=digits), "of type", typeh4, "\n");
      return(DF);
   }

   if(is.null(h4) && ds.pin < us.pin && h1 > us.pin) {
      message("ComputationC:")
      bot <- min(ds.pin, zdsinvert);
      top <- max(us.pin, h1);
      h4s <- seq(top, bot, by=-del);
      i <- 0
      maxQ <- maxT <- maxh4 <- vector(mode="numeric")
      for(h4 in h4s) {
         if(h4 <= zdsinvert) next
         if(h4 >= h1) next
         flow <- NA
         try( flow <- computeFlowSystem(h1=h1, h4=h4, verbose=verbose, ignore.early.out=TRUE,
                                        culvert=culverts, approach=approach, silent=silent));
         Q <- max(flow$Qtotal, na.rm=TRUE);
         T <- paste(flow$Types, sep=",", collapse=";")
         i <- i + 1;
         maxQ[i] <- Q;
         maxT[i] <- T;
         maxh4[i] <- h4
      }
      if(length(Q) == 0) {
         stop("Ambiguous elevation conditions for a nonNULL h1, threshold discharge not available");
      }
      thresholdQ <- max(maxQ, na.rm=TRUE);
      ix <- seq(1,length(maxQ))
      thresholdh4 <- maxh4[ix[maxQ == thresholdQ]];
      typeh4 <- maxT[ix[maxQ == thresholdQ]]
      DF <- data.frame(h1=rep(h1, length(maxQ)), h4=maxh4, Q=maxQ, Types=maxT)
      print(DF)
      plot(DF$h4, DF$Q, type="l",
           xlab="Tailwater height, in length units",
           ylab="Maximum discharge for each headwater height, in length per time")
      thresholdh4 <- thresholdh4[length(thresholdh4)];
      catme("ComputationC: The lowest recordable discharge threshold is",
            round(thresholdQ, digits=digits),  "if (when) h4 is",
            round(thresholdh4, digits=digits), "of type", typeh4, "\n");
      return(DF);
   }

   stop("Ambiguous elevation conditions seemingly do not facilitate computation of threshold discharge")
}




################################################################
##    capR Source File ./CulvertProperties/nvalues_corrugated.R
################################################################
"nvalues_corrugated" <-
function(corrugation=c("annular", "spiral"),
         diameter=c(  "1ft",  "2ft",  "3ft",  "4ft",  "5ft",
                      "6ft",  "7ft",  "8ft",  "9ft", "10ft",
                     "11ft", "12ft", "16ft", "18ft", "21ft"),
         pitchrise=c("2-2/3x1/2", "3x1", "5x1", "6x1",
                     "6x2", "9x2-1/2"),
         hashback=FALSE) {
         	
  corrugation <- match.arg(corrugation);
  diameter    <- match.arg(diameter);
  pitchxrise  <- match.arg(pitchrise);
  
  nval.h <- new.h();
  nval.annular.h <- new.h();
  nval.spiral.h  <- new.h();
  
  set.h( "1ft", new.h(), nval.annular.h);
  set.h( "2ft", new.h(), nval.annular.h);
  set.h( "3ft", new.h(), nval.annular.h);
  set.h( "4ft", new.h(), nval.annular.h);
  set.h( "5ft", new.h(), nval.annular.h);
  set.h( "6ft", new.h(), nval.annular.h);
  set.h( "7ft", new.h(), nval.annular.h);
  set.h( "8ft", new.h(), nval.annular.h);
  set.h( "9ft", new.h(), nval.annular.h);
  set.h("10ft", new.h(), nval.annular.h);
  set.h("11ft", new.h(), nval.annular.h);
  set.h("12ft", new.h(), nval.annular.h);
  set.h("16ft", new.h(), nval.annular.h);
  set.h("18ft", new.h(), nval.annular.h);
  set.h("21ft", new.h(), nval.annular.h);
  
  set.h("2-2/3x1/2", 0.027, get.h( "1ft", nval.annular.h));
  set.h("2-2/3x1/2", 0.025, get.h( "2ft", nval.annular.h));
  set.h("2-2/3x1/2", 0.024, get.h( "3ft", nval.annular.h));
  set.h("2-2/3x1/2", 0.024, get.h( "4ft", nval.annular.h));
  set.h("2-2/3x1/2", 0.024, get.h( "5ft", nval.annular.h));
  set.h("2-2/3x1/2", 0.023, get.h( "6ft", nval.annular.h));
  set.h("2-2/3x1/2", 0.023, get.h( "7ft", nval.annular.h));
  set.h("2-2/3x1/2", 0.023, get.h( "8ft", nval.annular.h));
  set.h("2-2/3x1/2", 0.023, get.h( "9ft", nval.annular.h));
  set.h("2-2/3x1/2", 0.022, get.h("10ft", nval.annular.h));
  set.h("2-2/3x1/2", 0.022, get.h("11ft", nval.annular.h));
  
  set.h("3x1", 0.028, get.h( "3ft", nval.annular.h));
  set.h("3x1", 0.028, get.h( "4ft", nval.annular.h));
  set.h("3x1", 0.028, get.h( "5ft", nval.annular.h));
  set.h("3x1", 0.028, get.h( "6ft", nval.annular.h));
  set.h("3x1", 0.028, get.h( "7ft", nval.annular.h));
  set.h("3x1", 0.028, get.h( "8ft", nval.annular.h));
  set.h("3x1", 0.028, get.h( "9ft", nval.annular.h));
  set.h("3x1", 0.027, get.h("10ft", nval.annular.h));
  set.h("3x1", 0.027, get.h("11ft", nval.annular.h));
  set.h("3x1", 0.027, get.h("12ft", nval.annular.h));
  set.h("3x1", 0.026, get.h("16ft", nval.annular.h));

  set.h("5x1", 0.026, get.h( "4ft", nval.annular.h));
  set.h("5x1", 0.026, get.h( "5ft", nval.annular.h));
  set.h("5x1", 0.026, get.h( "6ft", nval.annular.h));
  set.h("5x1", 0.026, get.h( "7ft", nval.annular.h));
  set.h("5x1", 0.025, get.h( "8ft", nval.annular.h));
  set.h("5x1", 0.025, get.h( "9ft", nval.annular.h));
  set.h("5x1", 0.025, get.h("10ft", nval.annular.h));
  set.h("5x1", 0.025, get.h("11ft", nval.annular.h));
  set.h("5x1", 0.024, get.h("12ft", nval.annular.h));
  set.h("5x1", 0.023, get.h("16ft", nval.annular.h));

  set.h("6x1", 0.025, get.h( "3ft", nval.annular.h));
  set.h("6x1", 0.024, get.h( "4ft", nval.annular.h));
  set.h("6x1", 0.024, get.h( "5ft", nval.annular.h));
  set.h("6x1", 0.024, get.h( "6ft", nval.annular.h));
  set.h("6x1", 0.023, get.h( "7ft", nval.annular.h));
  set.h("6x1", 0.023, get.h( "8ft", nval.annular.h));
  set.h("6x1", 0.023, get.h( "9ft", nval.annular.h));
  set.h("6x1", 0.023, get.h("10ft", nval.annular.h));
  set.h("6x1", 0.022, get.h("11ft", nval.annular.h));
  set.h("6x1", 0.022, get.h("12ft", nval.annular.h));
  set.h("6x1", 0.021, get.h("16ft", nval.annular.h));
 
  set.h("6x2", 0.035, get.h( "5ft", nval.annular.h));
  set.h("6x2", 0.035, get.h( "6ft", nval.annular.h));
  set.h("6x2", 0.035, get.h( "7ft", nval.annular.h));
  set.h("6x2", 0.034, get.h( "8ft", nval.annular.h));
  set.h("6x2", 0.034, get.h( "9ft", nval.annular.h));
  set.h("6x2", 0.034, get.h("10ft", nval.annular.h));
  set.h("6x2", 0.034, get.h("11ft", nval.annular.h));
  set.h("6x2", 0.033, get.h("12ft", nval.annular.h));
  set.h("6x2", 0.033, get.h("21ft", nval.annular.h));
 
  set.h("9x2-1/2", 0.036, get.h( "5ft", nval.annular.h));
  set.h("9x2-1/2", 0.035, get.h( "6ft", nval.annular.h));
  set.h("9x2-1/2", 0.034, get.h( "7ft", nval.annular.h));
  set.h("9x2-1/2", 0.034, get.h( "8ft", nval.annular.h));
  set.h("9x2-1/2", 0.034, get.h( "9ft", nval.annular.h));
  set.h("9x2-1/2", 0.034, get.h("10ft", nval.annular.h));
  set.h("9x2-1/2", 0.033, get.h("11ft", nval.annular.h));
  set.h("9x2-1/2", 0.033, get.h("12ft", nval.annular.h));
  set.h("9x2-1/2", 0.033, get.h("18ft", nval.annular.h));

  set.h("4ft", 0.020, nval.spiral.h);
  set.h("5ft", 0.022, nval.spiral.h);
  set.h("6ft", 0.023, nval.spiral.h);
  set.h("7ft", 0.023, nval.spiral.h);
  
  set.h("annular", nval.annular.h, nval.h);
  set.h("spiral",  nval.spiral.h,  nval.h);
  
  if(hashback) return(nval.h);
  if(corrugation == "spiral" & pitchrise == "2-2/3x1/2") {
  	if(has.key(diameter, nval.spiral.h)) {
       return(get.h(diameter, nval.spiral.h));
    }
  }
  tmp.h <- get.h(diameter, nval.annular.h);
  return(get.h(pitchrise, tmp.h));
}

#Manning n for Corrugated Metal Culverts 
#
#In Reply Refer To:                                  June 22, 1993 
#Mail Stop 415 
#
#OFFICE OF SURFACE WATER TECHNICAL MEMORANDUM NO. 93.17 
#
#Subject:  Manning n for Corrugated Metal Culverts 
#
#Several types of corrugated metal now used for culvert pipe are 
#not discussed in Techniques of Water-Resources Investigations 
#(TWRI), Book 3, Chapter A3, Measurement of Peak Discharge at 
#Culverts by Indirect Methods.  Laboratory studies conducted by 
#Utah State University for the National Corrugated Steel Pipe 
#Association provide n values for the new types of corrugation.  
#These studies have caused the Federal Highway Administration to 
#revise culvert roughness tables in the manual, Hydraulic Design of 
#Highway Culverts (Hydraulic Design Series No. 5), and provides 
#sufficient basis to revise n values for multiplate culverts as 
#given in TWRI, Book 3, Chapter A3, pages 10 and 11.  The values 
#given herein should be used for all future culvert computations. 
#
#The Office of Surface Water (OSW) also recommends that previous 
#computations for flow through multiplate culverts be reviewed if 
#the following conditions are met: 
#
#     1.  The n value used in the computation differs by 
#         0.003 or more from the value in this memorandum, and 
#     2.  discharges from types 2, 3, 4, or 6 computations using 
#         n values from TWRI, Book 3, Chapter A3, or from ratings 
#         based on such computations, have been published. 
#
#Ratings that were based on the old n values and are still in use 
#should be reviewed and revised if use of the revised n values 
#change any part of the rating by 5 percent or more.  Published 
#discharges do not need to be revised unless they meet the criteria 
#for revisions given in Novak (1985, p. 103-104, WRD data reports 
#preparation guide) and the water-surface elevations and field 
#conditions on which the computation is based provide a high degree 
#of reliability to the computed discharge.  The following material 
#supersedes the discussion in Standard riveted section and 
#Multiplate section in the part of the manual entitled "Corrugated 
#Metal" under Roughness Coefficients on pageJ10 of TWRI, Book 3, 
#Chapter A3. 
#
#                           Corrugated Metal 
#Corrugated pipes and arches are made in riveted, spiral, and 
#structural-plate styles.  The riveted and spiral styles are used 
#in small pipes of less than 9-foot diameter.  Spiral corrugations 
#have the same pitch and depth as that used in riveted 
#construction, but the plates are wound to form a continuous pipe.  
#Because of its greater strength, structural-plate (also called 
#multiplate) commonly is used for pipes that are more than 6 feet 
#in diameter.  Multiplate is made in sheets that are bolted
#together. 
#
#                     Standard Riveted Sections 
#The corrugated metal most commonly used in riveted pipes and 
#arches has a 2 2/3-inch pitch with a rise of 1/2 inch.  This is 
#frequently referred to as standard corrugated metal.  According to 
#laboratory tests, n values for full pipe flow vary from 0.0266 for 
#a 1-foot-diameter pipe to 0.0224 for an 8-foot-diameter pipe for 
#velocities normally encountered in culverts.  The American Iron 
#and Steel Institute recommends that a single value of 0.024 be 
#used in design of both partly-full and full-pipe flow for any size 
#of pipe.  This value may be satisfactory for many computations of 
#discharge.  However, more precise values are given in the 
#accompanying table, which shows values derived from tables and 
#graphs published by the Federal Highway Administration for culvert 
#design and that apply to both annular and spiral corrugations, as 
#noted in the table.  Values from this table should be used by 
#U.S. Geological Survey offices in computation of discharge through 
#culverts. 
#
#Riveted pipes are also made from corrugated metal with a 1-inch 
#rise and 3-, 5-, and 6-inch pitch.  Experimental data show a 
#slight lowering of the n value as pitch increases.  The n values 
#for these three types of corrugation are also given in the table. 
#
#                   Structural Plate (Multiplate) 
#Structural-plate metal used in multiplate construction has much 
#larger corrugations than does that used in riveted pipes.  
#Multiplate construction is used with both steel and aluminum.  The 
#steel has a 6-inch pitch and a 2-inch rise; aluminum has a 9-inch 
#pitch and a 2.5-inch rise.  Tests show somewhat higher n values 
#for this metal and type of construction than for riveted 
#construction.  Average n values range from 0.035 (steel) or 0.036 
#(aluminum) for 5-foot-diameter pipes to 0.033 for pipes of 18 feet 
#or greater diameter.  The n values for various diameters of pipe 
#are given in the following table. 
#
#Revised Roughness Coefficients for Corrugated Metal (May 1993)  
#  Pipe    |            n value for Indicated Corrugation Size   
#Diameter  |                                    |  Structural-plate 
#   ft     |       Riveted Construction         |    Construction        
#          |             Corrugation, Pitch x Rise, inches 
#          |2-2/3 x 1/2   3 x 1   5 x 1   6 x 1   6 x 2   9 x 2-1/2 
#           Annular Corrugations 
#    1          0.027 
#    2          0.025 
#    3          0.024     0.028           0.025 
#    4          0.024     0.028   0.026   0.024 
#    5          0.024     0.028   0.026   0.024   0.035     0.036 
#    6          0.023     0.028   0.026   0.024   0.035     0.035 
#    7          0.023     0.028   0.026   0.023   0.035     0.034 
#    8          0.023     0.028   0.025   0.023   0.034     0.034 
#    9          0.023     0.028   0.025   0.023   0.034     0.034 
#   10          0.022     0.027   0.025   0.023   0.034     0.034 
#   11          0.022     0.027   0.025   0.022   0.034     0.033 
#   12                    0.027   0.024   0.022   0.033     0.033 
#   16                 (a)0.026(a)0.023(a)0.021
#   18                                                   (a)0.033 
#   21                                         (a)0.033 
#           Spiral Corrugations 
#    4          0.020                    Use values for annular 
#    5          0.022                    corrugations for all other 
#    6          0.023                    corrugation sizes and pipe 
#    7          0.023                    diameters. 
#Range of pipe diameter in feet commonly encountered with the above 
#indicated corrugation size: 
#                <9       3-13    5-13    3-13    5-25      5-25 
#(a)Extrapolated beyond Federal Highway Administration curves.1 
#Note:  n values apply to pipes in good condition.  Severe 
#       deterioration of metal and misalignment of pipe sections 
#       may cause slightly higher values. 
#1See page 16 HDS-5 for extrapolation. 
#                                 Charles W. Boning, Chief 
#                                 Office of Surface Water 
#WRD DISTRIBUTION:  A, B, FO, PO 
#







################################################################
##    capR Source File ./CulvertProperties/setCulvert.R
################################################################
"setCulvert" <-
function(name="",
         slope=NULL,
         beveling=0,
         thetabev=45,
         rounding=0,
         USmiterlength=NULL,
         DSmiterlength=NULL,
         nvalue=0.015,
         skew.angle=0,
         L=NULL,
         Ltop=NULL,
         Lbot=NULL,
         diameter=NULL,
         width=NULL,
         rise=NULL,
         span=NULL,
         inlet.centerline=0,
         outlet.centerline=0,
         sideslope=0,
         zusinvert=0,
         zdsinvert=0,
         inlet.depression=0,
         outlet.depression=0,
         min.recordable.hw=NULL,
         min.recordable.tw=NULL,
         type=c("circle", "box", "ellipse", "pipearch"),
         altgeotype=c(NA, "circle", "box", "ellipse", "pipearch",
                      "trapezoid"),
         pipearch.type=c(NA, "RCP", "ALUM 31.8inchCR",
                         "CMP <=18inchCR", "CMP 31inchCR", "CMP 47inchCR",
                         "custom"),
         inlet=c("flush", "mitered", "flared"),
         theta=0,
         theta.left=NULL,
         theta.right=NULL,
         web=0,
         projectlength=0,
         is.topedge.square=FALSE,
         is.bellmouthed=FALSE,
         is.tonguegroove=FALSE,
         pipearch.radius.bottom=NULL,
         pipearch.radius.top=NULL,
         pipearch.radius.corner=NULL,
         pipearch.radius.units=NULL,
         number.of.barrels=1,
         ignore.approach.losses=FALSE,
         ignore.approach.velocity.head=FALSE,
         fraction.of.approach.area=1,
         material=c("concrete", "corrugated-metal"),
         is.barrel.rough=FALSE,
         materialthickness=c("thin-walled"),
         headwall=c("vertical"),
         embankment=c("slope"),
         gravity=32.2,
         flowunits=c("cubic feet per second", "cubic meters per second"),
         lengthunits=c("feet", "meters"),
         areaunits=c("square feet","square meters"),
         velunits=c("feet per second", "meters per second"),
         use.datums.when.graphing=TRUE,
         road=NULL) {

  ifelse(gravity > 15, manningcor <- 1.486, manningcor <- 1);
  flowunits <- match.arg(flowunits);
  if(is.null(flowunits)) flowunits <- "cubic feet per second";
  lengthunits <- match.arg(lengthunits);
  if(is.null(lengthunits)) lengthunits <- "feet";
  areaunits <- match.arg(areaunits);
  if(is.null(areaunits)) areaunits <- "square feet";
  velunits <- match.arg(velunits);
  if(is.null(velunits)) velunits <- "feet per second";

  type <- match.arg(type);
  if(is.null(type)) type <- "circle";

  pipearch.type <- match.arg(pipearch.type);
  if(type == "pipearch" & is.na(pipearch.type)) {
     stop("pipearch specified, but pipearch.type is NULL");
  }

  altgeotype <- match.arg(altgeotype);
  if(is.na(altgeotype)) altgeotype <- type;


  inlet <- match.arg(inlet);
  if(is.null(inlet)) inlet <- "flush";
  if(! is.null(USmiterlength)) inlet <- "mitered";

  material <- match.arg(material);
  if(is.null(material)) material <- "concrete";
  if(material == "corrugated-material") is.barrel.rough <- TRUE;

  headwall <- match.arg(headwall);
  if(is.null(headwall)) headwall <- "vertical";

  embankment <- match.arg(embankment);
  if(is.null(embankment)) embankment <- "slope";

  geometry.func <- NULL
  if(type == "circle") {
    if(is.null(rise))     rise     <- diameter;
    if(is.null(diameter)) diameter <- rise;
    width <- span <- diameter;
    geometry.func <- ARCIR;
  } else if(type == "box") {
    if(is.null(rise))     rise     <- diameter;
    if(is.null(width) && is.null(span))  width    <- diameter;
    if(is.null(diameter)) diameter <- rise;
    if(is.null(span))     span     <- width;
    width <- span;
    if(altgeotype == "trapezoid") {
      geometry.func <- ARTRAP;
    } else {
      geometry.func <- ARBOX;
    }
  } else if(type == "ellipse") {
    if(is.null(diameter)) diameter <- rise;
    if(is.null(rise)) rise <- diameter;
    if(is.null(span)) span <- width;
    if(is.null(span)) span <- rise;
    width <- span;
    geometry.func <- ARELLIPSE;
  } else if(type == "pipearch") {
    if(is.null(diameter)) diameter <- rise;
    if(is.null(rise))     rise     <- diameter;
    if(is.null(span))     span     <- rise;
    width <- span;
    geometry.func <- ARPIPEARCH;
  } else {
    stop("can not determine culvert type");
  }

  if(! is.null(L) && is.null(Ltop)) Ltop <- L;
  if(! is.null(L) && is.null(Lbot)) Lbot <- L;
  L <- NULL;

  if(! is.null(slope)) {
     ifelse(is.null(Lbot), zusinvert <- zdsinvert,
                           zusinvert <- Lbot*slope + zdsinvert);
  }
  z <- zusinvert - zdsinvert;
  if(z == 0) {
     slope <- 0;
  } else {
     slope <- z/Lbot;
  }


  tmp.h <- new.h();

  setchar.h("name", name, tmp.h);

  setnum.h("So", slope,                    tmp.h); # cap96 variable So
  setnum.h("USmiterlength", USmiterlength, tmp.h);
  setnum.h("DSmiterlength", DSmiterlength, tmp.h);
  setnum.h("nvalue", nvalue,               tmp.h);
  setnum.h("diameter", diameter,           tmp.h); # cap96 variable D
  setnum.h("span", span,                   tmp.h);
  setnum.h("rise", rise,                   tmp.h);
  setnum.h("width", width,                 tmp.h);

  skew.factor <- cos(skew.angle*pi/180);
  setnum.h("skew.angle",   skew.angle,     tmp.h);
  setnum.h("skew.factor", skew.factor,     tmp.h);


  if(is.null(web) || is.na(web)) stop("Web can not be NULL or NA, make zero if no webbing");
  if(type != 'box' & web > 0)    stop("Geometry is non-'box', yet a web > 0 is specified");

  setint.h("web", web,         tmp.h);
  setnum.h("sideslope", sideslope,         tmp.h);
  setchar.h("type", type,                   tmp.h);
  setchar.h("pipearch.type", pipearch.type, tmp.h);
  setchar.h("altgeotype", altgeotype,       tmp.h);
  setchar.h("inlet", inlet,                 tmp.h);
  setnum.h("inlet.centerline",   inlet.centerline, tmp.h);
  setnum.h("outlet.centerline", outlet.centerline, tmp.h);
  setnum.h("z", z,                         tmp.h);
  setnum.h("zusinvert", zusinvert,         tmp.h);
  setnum.h("zdsinvert", zdsinvert,         tmp.h);
  setnum.h("min.recordable.hw", min.recordable.hw, tmp.h);
  setnum.h("min.recordable.tw", min.recordable.tw, tmp.h);
  setnum.h("Ltop", Ltop,                   tmp.h);
  setnum.h("Lbot", Lbot,                   tmp.h);
  set.h("geometry.func", geometry.func, tmp.h);
  setchar.h("material", material,           tmp.h);
  setchar.h("headwall", headwall,           tmp.h);
  setchar.h("embankment", embankment,       tmp.h);

  setnum.h("gravity", gravity,             tmp.h);
  setnum.h("manningcor", manningcor,       tmp.h);
  setchar.h("flowunits", flowunits,         tmp.h);
  setchar.h("lengthunits", lengthunits,     tmp.h);
  setchar.h("areaunits", areaunits,         tmp.h);
  setchar.h("velunits", velunits,           tmp.h);

  set.h("road", road,             tmp.h);

  if(type == "pipearch") {
    if(is.null(pipearch.radius.units)) {
      radii <- CULPAD(culvert=tmp.h);
      setnum.h("pipearch.radius.bottom", radii$radius.bottom, tmp.h);
      setnum.h("pipearch.radius.top",    radii$radius.top,    tmp.h);
      setnum.h("pipearch.radius.corner", radii$radius.corner, tmp.h);
      set.h("pipearch.radius.units",  radii$radius.units,  tmp.h);
    } else {
      if(pipearch.radius.units != "inches") {
         stop("pipearch radii set by user requires pipearch.radius.units equal to 'inches'");
      }
      setnum.h("pipearch.radius.bottom", pipearch.radius.bottom, tmp.h);
      setnum.h("pipearch.radius.top",    pipearch.radius.top,    tmp.h);
      setnum.h("pipearch.radius.corner", pipearch.radius.corner, tmp.h);
      setchar.h("pipearch.radius.units",  pipearch.radius.units,  tmp.h);
    }
  }

  if(inlet.depression < 0) {
    stop("inlet.depression is < 0, which is in error");
  }
  if(outlet.depression < 0) {
    stop("outlet.depression is < 0, which is in error");
  }
  if(inlet.depression >= diameter) {
    stop("inlet.depression is > diameter or rise, which is in error");
  }
  if(outlet.depression >= diameter) {
    stop("outlet.depression is > diameter or rise, which is in error");
  }
  setnum.h("inlet.depression",   inlet.depression, tmp.h);
  setnum.h("outlet.depression", outlet.depression, tmp.h);

  the.geometry <- setCulvertGeometry(depth=inlet.depression, culvert=tmp.h);
  inlet.depression.A  <- the.geometry$A;
  inlet.depression.WP <- the.geometry$WP;
  inlet.depression.TW <- the.geometry$TW;
  setnum.h("inlet.depression.A",   inlet.depression.A,  tmp.h);
  setnum.h("inlet.depression.WP",  inlet.depression.WP, tmp.h);
  setnum.h("inlet.depression.TW",  inlet.depression.TW, tmp.h);

  the.geometry <- setCulvertGeometry(depth=outlet.depression, culvert=tmp.h);
  outlet.depression.A  <- the.geometry$A;
  outlet.depression.WP <- the.geometry$WP;
  outlet.depression.TW <- the.geometry$TW;
  setnum.h("outlet.depression.A",   outlet.depression.A,  tmp.h);
  setnum.h("outlet.depression.WP",  outlet.depression.WP, tmp.h);
  setnum.h("outlet.depression.TW",  outlet.depression.TW, tmp.h);


  the.geometry <- setCulvertGeometry(depth=diameter-inlet.depression,
                                     culvert=tmp.h,
                                     depression=inlet.depression,
                                     location="inlet");
  setnum.h("Ao.inlet", the.geometry$A,       tmp.h);
  setnum.h("Po.inlet", the.geometry$WP,      tmp.h);
  setnum.h("Ro.inlet", the.geometry$HR,      tmp.h);
  setnum.h("Ko.inlet", the.geometry$KONVEY,  tmp.h);
  the.geometry <- setCulvertGeometry(depth=diameter-outlet.depression,
                                     culvert=tmp.h,
                                     depression=outlet.depression,
                                     location="outlet");
  setnum.h("Ao.outlet", the.geometry$A,      tmp.h);
  setnum.h("Po.outlet", the.geometry$WP,     tmp.h);
  setnum.h("Ro.outlet", the.geometry$HR,     tmp.h);
  setnum.h("Ko.outlet", the.geometry$KONVEY, tmp.h);

  number.of.barrels <- as.integer(number.of.barrels);
  if(number.of.barrels >= 1) {
     setnum.h("number.of.barrels", number.of.barrels, tmp.h);
  } else {
     stop("number.of.barrels is not >= 1");
  }

  projectratio <- projectlength/diameter;
  setnum.h("projectlength", projectlength, tmp.h);
  setnum.h("projectratio", projectratio,   tmp.h);
  kproj <- KPRJCT(projectratio=projectratio);
  setnum.h("kproj", kproj,                 tmp.h);

  setnum.h("rounding", rounding,           tmp.h); # cap96 variable RND
  krnd <- KRND(rnd=rounding); # FIGURE 21, TWRI p.39
  setnum.h("krnd", krnd,                   tmp.h);

  setnum.h("thetabev", thetabev,           tmp.h);
  setnum.h("beveling", beveling,           tmp.h); # cap96 variable BEV
  kbev <- KBEV(rnd=beveling, theta=thetabev); # FIGURE 22, TWRI p.40
  setnum.h("kbev", kbev,                   tmp.h);

  if(! is.null(theta.left) | ! is.null(theta.right)) {
     theta <- NULL;
     if(is.null(theta.left))  theta.left  <- theta.right;
     if(is.null(theta.right)) theta.right <- theta.left;
     ktheta <- c(KWINGWALL(theta.left), KWINGWALL(theta.right))
     # TWRI p.42 says to compute two C values and then mean the C values
     # so, we will track a vector of kthetas.
     if(length(ktheta) == 2) {
        if(ktheta[1] == ktheta[2]) ktheta <- ktheta[1]
     }
     setnum.h("theta", theta,              tmp.h);
     setnum.h("theta.left", theta.left,    tmp.h);
     setnum.h("theta.right", theta.right,  tmp.h);
     setnum.h("ktheta", ktheta,            tmp.h);
  } else {
     setnum.h("theta", theta,              tmp.h);
     ktheta <- KWINGWALL(theta); # FIGURE 24, TWRI p.42
     setnum.h("ktheta", ktheta,            tmp.h);
  }


  setnum.h("TMP.Q.previous.run", 0,             tmp.h);
  setnum.h("TMP.Qroad.previous.run", 0,         tmp.h);
  setnum.h("TMP.terminal.area.previous.run", 0, tmp.h);
  setnum.h("TMP.konvey2.previous.run", 0,       tmp.h);
  setnum.h("TMP.key", "",                       tmp.h);


  # The following three TMP storage variables contain the original
  # settings of the respective variables. These are stored so that
  # computeFlow() can recover the originals incase of a submerged outlet
  # and nonsubmerged inlet in which the lengths and the computation reference
  # datum (zdsinvert) is needed.
  setnum.h("TMP.Ltop", Ltop,           tmp.h);
  setnum.h("TMP.Lbot", Lbot,           tmp.h);
  setnum.h("TMP.zdsinvert", zdsinvert, tmp.h);

  setlog.h("is.topedge.square", is.topedge.square, tmp.h);
  setlog.h("is.bellmouthed",    is.bellmouthed,    tmp.h);
  setlog.h("is.tonguegroove",   is.tonguegroove,   tmp.h);
  setlog.h("is.barrel.rough",   is.barrel.rough,   tmp.h);

  setlog.h("use.datums.when.graphing",      use.datums.when.graphing,      tmp.h);
  setlog.h("ignore.approach.losses",        ignore.approach.losses,        tmp.h);
  setlog.h("ignore.approach.velocity.head", ignore.approach.velocity.head, tmp.h);

  if(fraction.of.approach.area > 1 || fraction.of.approach.area < 0) {
     stop("bad fraction.of.approach.area, must be in [0,1]");
  } else {
     setnum.h("fraction.of.approach.area", fraction.of.approach.area, tmp.h);
  }

  return(tmp.h);
}

"resetTMPvarsCulvert" <-
function(culvert) {
   set.h("TMP.Q.previous.run", 0,             culvert);
   set.h("TMP.Qroad.previous.run", 0,         culvert);
   set.h("TMP.terminal.area.previous.run", 0, culvert);
   set.h("TMP.konvey2.previous.run", 0,       culvert);
}


"changeBevelingCulvert" <-
function(culvert, bevs=list(beveling=0, thetabev=45)) {
   old.thetabev <- culvert$thetabev;
   old.beveling <- culvert$beveling;
   zz <- list(beveling=old.beveling, thetabev=old.thetabev, kbev=culvert$kbev);
   new.thetabev <- bevs$thetabev;
   new.beveling <- bevs$beveling;
   setnum.h("thetabev", new.thetabev, culvert);
   setnum.h("beveling", new.beveling, culvert);
   setnum.h("kbev",     KBEV(rnd=new.beveling, theta=new.thetabev), culvert); # FIGURE 22, TWRI p.40
   return(zz)
}



"changeRoundingCulvert" <-
function(culvert, rnd=0) {
   old.rounding <- culvert$rounding;
   zz <- list(rounding=old.rounding, krnd=culvert$krnd);
   new.rounding <- rnd;
   setnum.h("rounding", new.rounding, culvert);
   setnum.h("krnd",     KRND(rnd=new.rounding), culvert);  # FIGURE 21, TWRI p.39
   return(zz)
}


################################################################
##    capR Source File ./CulvertProperties/setCulvertGeometry.R
################################################################
"setCulvertGeometry" <-
function(depth=NULL, culvert=NULL, location=c("inlet", "outlet"),
         depression=0, ...) {

  # First compute the properties as if the geometry was complete
  # note that the depression of zero condition results in a regular
  # computation of an undepressed culvert.
  xsec.properties <- culvert$geometry.func(depth=depth + depression,
                                           culvert=culvert);
  if(depression == 0) return(xsec.properties);


  location <- match.arg(location);

  if(location == "inlet") {
     Ad  <- culvert$inlet.depression.A;
     WPd <- culvert$inlet.depression.WP;
     TWd <- culvert$inlet.depression.TW;
  } else {
     Ad  <- culvert$outlet.depression.A;
     WPd <- culvert$outlet.depression.WP;
     TWd <- culvert$outlet.depression.TW;
  }
  A  <- xsec.properties$A  - Ad;
  WP <- xsec.properties$WP - WPd + TWd;
  HR <- A/WP;
  konvey <- Conveyance(A=A, R=HR, nvalue=culvert$nvalue,
                       manningcor=culvert$manningcor);
  xsec.properties$A      <- A;
  xsec.properties$WP     <- WP;
  xsec.properties$HR     <- HR;
  xsec.properties$KONVEY <- konvey;
  #print(xsec.properties);
  return(xsec.properties);
}



################################################################
##    capR Source File ./CulvertProperties/Box/ARBOX.R
################################################################
"ARBOX" <-
function(depth=NULL, culvert=NULL) {

  diameter <- culvert$diameter;
  width    <- culvert$width;
  web      <- culvert$web;
  nvalue   <- culvert$nvalue;
  manningcor <- culvert$manningcor;

  if(is.null(depth) || depth > diameter) depth <- diameter;
  if(depth < 0) depth <- 0;

  # remember that diameter is the height!
  if(is.null(width)) width <- diameter;
  wettedperimeter <- width + 2*(1+web)*depth;
  if(abs(depth - diameter) <= 0.0001) {
    wettedperimeter <- wettedperimeter + width;
  }
  area <- width*depth;
  topwidth <- width;
  hydraulicradius <- area/wettedperimeter;
  konvey <- Conveyance(A=area, R=hydraulicradius,
                       nvalue=nvalue, manningcor=manningcor);
  z <- list(DEPTH=depth, D=diameter, B=width,
            WEB=web, N=nvalue, A=area,
            TW=topwidth, WP=wettedperimeter,
            HR=hydraulicradius, KONVEY=konvey);
  return(z);
}


"demo.ARBOX" <- function(depth=0) {
  culvert <- list(diameter=8, width=8, web=1, nvalue=0.015,
                  manningcor=1.486);
  return(ARBOX(depth=depth, culvert=culvert));
}
#C=====ARBOX bof=============================================================
#C
#C-----Purpose:
#C       Computes geometric properties for box culverts
#C     Programmed by:
#C     Date:
#C     Modified by: JM Fulford
#C     Last modified:
#C
#      SUBROUTINE ARBOX
#     I                (DC,B,D,N,WEB,AREA,KONVEY,TW,WP)
#C
#C-----Arguments:
#      INTEGER WEB
#      REAL N,KONVEY
#C
#      RWEB=WEB
#      WP=B+2.0*(1.0+RWEB)*DC
#      IF (ABS(DC-D).LE.0.0001) WP=WP+B
#      AREA=B*DC
#      TW=B
#      HR=AREA/WP
#      KONVEY=1.49*HR**(2.0/3.0)*AREA/N
#C
#      RETURN
#      END
#C
#C=====ARBOX eof=============================================================
#


################################################################
##    capR Source File ./CulvertProperties/Circular/ARCIR.R
################################################################
"ARCIR" <-
function(depth=NULL, culvert=NULL) {

  diameter   <- culvert$diameter;
  nvalue     <- culvert$nvalue;
  manningcor <- culvert$manningcor;

  if(is.null(depth) || depth > diameter) depth <- diameter;
  if(depth < 0) depth <- 0;

  if(abs(depth - diameter) <= 0.000001) {
    area <- pi*0.25*diameter*diameter;
    wettedperimeter <- pi*diameter;
    topwidth <- 0;
    hydraulicradius <- area/wettedperimeter;
  } else {
    radius <- 0.5*diameter;
    RR <- radius*radius; RmD <- radius - depth;
    alpha <- acos(RmD/radius);
    AS <- alpha*RR;
    AT <- RmD*sqrt(RR - RmD^2);
    area <- AS - AT;
    wettedperimeter <- 2*radius*alpha;
    hydraulicradius <- area/wettedperimeter;
    topwidth <- 2*sqrt(RR - RmD^2);
  }
  konvey <- Conveyance(A=area, R=hydraulicradius,
                       nvalue=nvalue, manningcor=manningcor);
  z <- list(DEPTH=depth, D=diameter, N=nvalue, A=area,
            TW=topwidth, WP=wettedperimeter,
            HR=hydraulicradius, KONVEY=konvey);
  return(z);
}

"demo.ARCIR" <- function(depth=0) {
  culvert <- list(diameter=8, nvalue=0.015,
                  manningcor=1.486);
  return(ARCIR(depth=depth, culvert=culvert));
}
#C=====ARCIR bof=============================================================
#C
#C-----Purpose:
#C       Computes geometric properties for circular section culverts
#C     Programmed by:
#C     Date:
#C     Modified by: JM Fulford
#C     Last modified:
#C
#      SUBROUTINE ARCIR
#     I                (D,DEPTH,N,AREA,KONVEY,TW,WP)
#C
#C     + + + PURPOSE + + +
#C
#      REAL N,KONVEY
#C
#      IF (ABS(DEPTH-D).LE.0.000001) THEN
#        AREA=3.14159*0.25*D*D
#        WP=3.14159*D
#        TW=0.0
#        HR=AREA/WP
#      ELSE
#        R=0.5*D
#        ALP=ACOS((R-DEPTH)/R)
#        AS=ALP*R*R
#        AT=(R-DEPTH)*SQRT(R*R-(R-DEPTH)**2)
#        AREA=AS-AT
#        WP=2.0*R*ALP
#        HR=AREA/WP
#        TW=2.0*SQRT(R*R-(R-DEPTH)**2)
#      ENDIF
#      KONVEY=1.49*HR**(2.0/3.0)*AREA/N
#C
#      RETURN
#      END
#C
#C=====ARCIR eof=============================================================
#


################################################################
##    capR Source File ./CulvertProperties/Elliptical/ARELLIPSE.R
################################################################
"ARELLIPSE" <-
function(depth=NULL, culvert=NULL) {

  # diameter and rise are SAME
  diameter   <- culvert$diameter;
  rise       <- culvert$rise;
  span       <- culvert$span;
  nvalue     <- culvert$nvalue;
  manningcor <- culvert$manningcor;

  if(is.null(depth) || depth > diameter) depth <- rise;
  if(depth < 0) depth <- 0;

  A <- span/2;  B <- rise/2;
  W <- depth - B;
  if(abs(depth - rise) <= 0.000001) {
    area <- pi*A*B;
    wettedperimeter <- 2 * pi * sqrt(0.5 * (A*A + B*B));
    topwidth <- 0;
    hydraulicradius <- area/wettedperimeter;
  } else {
    AB <- A*B; AA <- A*A; BB <- B*B; WW <- W*W; # precompute
    AoBtBBmWW <- (A/B)*sqrt(BB - WW); # precompute
    area <- W*AoBtBBmWW + AB*asin(W/B) + AB*pi/2;
    topwidth <- AoBtBBmWW;
    wettedperimeter <- 2*sqrt((AA + BB)/2)*acos(-W/sqrt(WW + topwidth^2));
    topwidth <- 2*topwidth;
    hydraulicradius <- area/wettedperimeter;
  }
  konvey <- Conveyance(A=area, R=hydraulicradius, nvalue=nvalue,
                       manningcor=manningcor);
  z <- list(DEPTH=depth,  D=diameter, RISE=rise,
            SPAN=span,    N=nvalue,      A=area,
            TW=topwidth, WP=wettedperimeter,
            HR=hydraulicradius, KONVEY=konvey);
  return(z);
}

"demo.ARELLIPSE" <-
function(depth,rise,span) {
  culvert <- list(rise=rise, span=span, diameter=rise,
                  nvalue=0.025, manningcor=1.486);
  return(ARELLIPSE(depth, culvert=culvert));
}

#C=====ELLIPSE BOF===============================================
#C
#C-----Purpose:
#C       Computes geometric properties for elliptical culverts
#C     Programmed by:  J.M. Fulford
#C     Date:  10.14.1998
#C
#      SUBROUTINE ELLIPSE
#     I                  (RISE,SPAN,DEPTH,N,AREA,KONVEY,TW,WP)
#C
#C
#      REAL RISE,SPAN,DEPTH,N,KONVEY,TW,WP
#C
#      REAL A,B,W,HR,RATIO
#C
#      W= DEPTH - (RISE/2.0)
#C      IF(RISE.GE.SPAN) THEN
#C-----vertical ellipse
#        A=SPAN*0.5
#        B=RISE*0.5
#C     ELSE
#C-----horizontal ellipse
#C        A=RISE*0.5
#C        B=SPAN*0.5
#C      ENDIF
#      IF(ABS(DEPTH-RISE).LE.0.000001) THEN
#        AREA = 3.14159*A*B
#        WP = 6.28318*SQRT((A*A + B*B)*0.5)
#        TW = 0.0
#        HR= AREA/WP
#      ELSE
#        AREA = A*W*SQRT(B*B-W*W)/B + A*B*ASIN(W/B) + A*B*3.14159*0.5
#        TW = A* SQRT(B*B - W*W)/B
#        RATIO = -1.0*W/SQRT(W*W + TW*TW)
#        TW=2.0*TW
#        WP = 2.0 * SQRT((A*A + B*B)/2.0)*ACOS(RATIO)
#        HR=AREA/WP
#      ENDIF
#      KONVEY=1.49*HR**(2.0/3.0)*AREA/N
#C
#      RETURN
#      END
#C
#C=====ELLIPSE eOF===============================================



################################################################
##    capR Source File ./CulvertProperties/PipeArch/ARPIPEARCH.R
################################################################
"ARPIPEARCH" <-
function(depth=NULL, culvert=NULL) {
  D <- culvert$diameter;
  AR  <- PIPE.ARCH(depth=depth, culvert=culvert);

  D <- culvert$diameter;
  B <- culvert$span;
  nvalue <- culvert$nvalue;

  z <- list(DEPTH=depth, D=D, B=B, N=nvalue, A=AR$A,
            TW=AR$TW, WP=AR$WP,  HR=AR$HR,  KONVEY=AR$KONVEY);
  return(z);
}

"PIPE.ARCH" <-
function(depth=NULL, culvert=NULL) {

  D <- culvert$diameter;
  B <- culvert$span;
  nvalue   <- culvert$nvalue;
  manningcor <- culvert$manningcor;
  g <- culvert$gravity;

  if(is.null(depth) || depth > D) depth <- D;
  if(depth < 0) depth <- 0;

  #ARADs <- CULPAD(culvert=culvert);
  #ARAD <- c(ARADs$radius.bottom,
  #          ARADs$radius.top,
  #          ARADs$radius.corner);
  ARAD <- c(culvert$pipearch.radius.bottom,
            culvert$pipearch.radius.top,
            culvert$pipearch.radius.corner);
  #catme("PIPEARCH ARAD: ",ARAD,"\n");
#C-----Arguments:
#      REAL B,D,ARAD(3)
#      REAL DEP,AREA,WP,TW,CONV,ROUGH
#C
#C     NOTE -- DIMENSIONS DIMENS MUST BE GIVEN IN INCHES,  DEP IN  FEET.
#C
   if(g > 15) {
      RISEQQ <- D*12;
      SPANQQ <- B*12;
      Y3 <- depth*12;
   } else {
     RISEQQ <- D*3.2808*12;  # meters to feet to inches
     SPANQQ <- B*3.2808*12;  # meters to feet to inches
     Y3 <- depth*3.2808*12;
  }
  if(Y3 <= 0)     Y3 <- 0.0001*RISEQQ;
  if(Y3 > RISEQQ) Y3 <- RISEQQ;

  BRQQ <- ARAD[1];
  TRQQ <- ARAD[2];
  CRQQ <- ARAD[3];

  SPHI1  <- (SPANQQ/2 - CRQQ) / (BRQQ - CRQQ);
  if(! is.finite(SPHI1)) {
    stop("SPHI1 is Inf, pipearch.bottom == pipearch.corner");
  }
  
  CPHI1  <- sqrt(1 - SPHI1^2);
  BDISQQ <- CRQQ + (BRQQ - CRQQ)*(1 - CPHI1);
  TPHI2  <- (SPANQQ/2 - CRQQ) / ( BDISQQ - ( RISEQQ-TRQQ ) );
  

  if(is.nan(CPHI1)) {
    stop("CPHI1 is NaN, review relation between pipearch.radius.bottom, pipearch.radius.corner, and span");
  }
  if(is.nan(TPHI2)) {
    stop("TPHI2 is NaN, review relation between pipearch.radius.bottom, pipearch.radius.top, pipearch.radius.corner, and rise and span");  
  }


  PHI1 <- atan(SPHI1/CPHI1);
  PHI2 <- atan(TPHI2);

  Y1 <- BRQQ   - BRQQ*cos(PHI1);
  Y2 <- BDISQQ + CRQQ*cos(PHI2);
  
  AREA1 <- 0;  AREA2 <- 0; AREA3 <- 0;
    WP1 <- 0;    WP2 <- 0;   WP3 <- 0;
    TOP <- 0;

  B1   <- 2*BRQQ;
  AK1  <- 1/(BRQQ*BRQQ);
  RAD1 <- sqrt(B1*B1);

  B2   <- 2*BDISQQ;
  A2   <- CRQQ*CRQQ - BDISQQ*BDISQQ;
  AK2  <- 1/CRQQ^2;
  RAD2 <- sqrt(B2*B2 - (-4*A2));

  B3   <- 2*(RISEQQ-TRQQ);
  A3   <- 2*RISEQQ*TRQQ - RISEQQ*RISEQQ;
  AK3  <- 1/TRQQ^2;
  RAD3 <- sqrt(B3*B3 - (-4*A3));


  # /144 * 2; # x2 for symmetry? /144 to in^2 to ft^2?

  # The original fortran sources in Cap96.08 use a cascade of
  # goto's. I have tried to keep the core lines in direct port
  # so the following three functions act like the line blocks.
   "PARCH.line325" <- function() {
   #  325 # ORIGINAL LINE LABEL ON NEXT LINE
       X3 <- abs(A3 + B3*Y3 - Y3*Y3);
      X33 <- A3 + B3*Y2 - Y2*Y2;
      subareas <- MARQUE(Y3, Y2, B3, X3, X33, AK3, RAD3);
      ASUB1 <- subareas$subarea1;
      ASUB2 <- subareas$subarea2;
        XX1 <- subareas$XX1;
        XX2 <- subareas$XX2;
      AREA3 <- (ASUB1 - ASUB2)/144 * 2;
        WP3 <- 2*TRQQ*(XX1-XX2);
      return(c(X3,AREA3,WP3));
   }

   "PARCH.line345" <- function() {
   #  345 # ORIGINAL LINE LABEL ON NEXT LINE
       X2 <- A2 + B2*Y2 - Y2*Y2;
      X22 <- A2 + B2*Y1 - Y1*Y1;
      subareas <- MARQUE(Y2, Y1, B2, X2, X22, AK2, RAD2);
      ASUB1 <- subareas$subarea1;
      ASUB2 <- subareas$subarea2;
        XX1 <- subareas$XX1;
        XX2 <- subareas$XX2;
      ASUB3 <- (SPANQQ/2 - CRQQ)*Y2 - (SPANQQ/2 - CRQQ)*Y1;
      AREA2 <- (ASUB1 - ASUB2 + ASUB3)/144 * 2;
        WP2 <- 2*CRQQ*(XX1-XX2);
      return(c(X2,AREA2,WP2));
   }

   "PARCH.line367" <- function() {
   #  367 # ORIGINAL LINE LABEL ON NEXT LINE
      X1 <- B1*Y1 - Y1*Y1;
      subareas <- MARQUE(Y1, 0, B1, X1, 0, AK1, RAD1);
      ASUB1 <- subareas$subarea1;
      ASUB2 <- subareas$subarea2;
        XX1 <- subareas$XX1;
        XX2 <- subareas$XX2;
      AREA1 <- (ASUB1 - ASUB2)/144 * 2;
        WP1 <- 2*BRQQ*(XX1-XX2);
      return(c(X1,AREA1,WP1));
   }


  if(Y3 >= Y2) {# GO TO 325 TODO
     zone3 <- PARCH.line325();
     zone2 <- PARCH.line345();
     zone1 <- PARCH.line367();
     X3 <- zone3[1]; AREA3 <- zone3[2]; WP3 <- zone3[3];
     X2 <- zone2[1]; AREA2 <- zone2[2]; WP2 <- zone2[3];
     X1 <- zone1[1]; AREA1 <- zone1[2]; WP1 <- zone1[3];
  } else {
     Y2 <- Y3;
     if(Y3 >= Y1) { # GO TO 345 TODO
       zone2 <- PARCH.line345();
       zone1 <- PARCH.line367();
       X2 <- zone2[1]; AREA2 <- zone2[2]; WP2 <- zone2[3];
       X1 <- zone1[1]; AREA1 <- zone1[2]; WP1 <- zone1[3];
     }
     else {
        Y1 <- Y3;
        if(Y3 > 0) { # GO TO 367 TODO
           zone1 <- PARCH.line367();
           X1 <- zone1[1]; AREA1 <- zone1[2]; WP1 <- zone1[3];
        } else {
          zone3 <- PARCH.line325();
          zone2 <- PARCH.line345();
          zone1 <- PARCH.line367();
          X3 <- zone3[1]; AREA3 <- zone3[2]; WP3 <- zone3[3];
          X2 <- zone2[1]; AREA2 <- zone2[2]; WP2 <- zone2[3];
          X1 <- zone1[1]; AREA1 <- zone1[2]; WP1 <- zone1[3];
        }
     }
  }

  AREA <- (AREA1 + AREA2 + AREA3); # already in square feet
    WP <- (WP1 + WP2 + WP3)/12; # cast into feet
  if(Y3 > Y2) {
    TOP <- 2*sqrt(X3);
  } else if(Y3 > Y1) {
    TOP <- 2*( sqrt(X2) + (SPANQQ/2 - CRQQ) );
  } else if(Y3 > 0) {
    TOP <- 2*sqrt(X1);
  }
  TW <- TOP/12; # cast into feet
  if(g < 15) { # cast into meters and square meters if needed
    TW   <- TW/3.2808;
    AREA <- AREA/(3.2808^2);
    WP   <- WP/3.2808;
  }

  hydraulicradius <- AREA/WP;
  if(TW <= 0) TW <- 1e-8;
  topwidth <- TW;
  wettedperimeter <- WP;

  konvey <- Conveyance(A=AREA, R=hydraulicradius,
                       nvalue=nvalue, manningcor=manningcor);


  z <- list(DEPTH=depth, D=D, B=B,
            N=nvalue, A=AREA,
            TW=topwidth, WP=wettedperimeter,
            HR=hydraulicradius, KONVEY=konvey);
  return(z);
}


"MARQUE" <-
function(UL, LL, BB, UX, LX, AK, RAD) {
#C=====MARQUE bof=============================================================
#C-----Purpose:
#C       computes culvert properties for pipe arch sections
#C     Programmed by: W Kirby original code from WSPRO
#C     Date:
#C     Modified by: JM Fulford
#C
#C
#C
#C
#C-----Arguments:
#      REAL LL,LX,UL,BB,AK,RAD,XX1,ASUB1,XX2,ASUB2
#C
   XX1 <- (2*UL - BB)/RAD;
   if(abs(XX1) > 1) {
      ifelse(XX1 >= 0, XX1 <-  1, XX1 <- -1);
      #XX1 <- SIGN(1.,XX1); # SEE BELOW
   }
   XX1 <- asin(XX1);
   ASUB1 <- (  ( (-2*UL+BB)*sqrt(UX) )*(-0.25)  ) + 1 / (2*AK) * XX1;
   XX2 <- (2*LL-BB)/RAD;
   if(abs(XX2) > 1) {
      ifelse(XX2 >= 0, XX2 <- 1, XX2 <- -1);
      #XX2 <- SIGN(1, XX2); # SEE BELOW
   }
   XX2 <- asin(XX2);
   ASUB2 <- (  ( (-2*LL+BB)*sqrt(LX) )*(-0.25)  ) + 1 / (2*AK) * XX2;
   return(list(subarea1=ASUB1, subarea2=ASUB2,
               area.units="inches", XX1=XX1, XX2=XX2));
}


#Sign Function
#The function sign in Fortran is called the sign transfer function. It is a function of two variables, and its definition involves two cases:
#
#CASE 1:   If y  0 then
#		sign(x,y) = abs(x)   ,
#CASE 2:   If y < 0 then
#		sign(x,y) = - abs(x)   .
#
#The practical effect is that sign(x,y) has the same absolute value as x, but it has the same sign as y; thus the sign of y is transferred to x. (The case y = 0 is a little special - it gives sign(x,y) always a plus sign.)
#
#Examples :
#
#sign(2,3) = 2,  sign(2, -3) = -2, sign(-2,3) = 2, sign(-2, -3) = -2


"CULPAD" <-
function(culvert=NULL) {
#C=====CULPAD bof=============================================================
#C-----Purpose:
#C       computes culvert properties for pipe arch sections
#C     Programmed by: W Kirby original code from WSPRO
#C     Date:
#C     Modified by: JM Fulford
#C                  6.9.97 - uses arctyp code in material code wspro location
#C     CULPAD -- PIPE-ARCH DIMENSIONS -- APPROXIMATE
#C        REGRESSION EQNS BASED ON DIMENSIONS TABULATED IN FHWA - CDS-4
#C  PARAMETERS --
#C     ARCTYP -- 2,4 = CMP .LE. 18"CR,  5 = CMP-31",
#C                 6 = CMP-47",  3 = ALUM. 31.8",   1 = R.C.P.
#C     ARAD(3,4,5) = APPROX BOTTOM, TOP, CORNER RADII  =  OUTPUT.
#C
#C-----Arguments:
#      INTEGER TCR
#      REAL ARAD(3),D,B
#C
#C-----Local variables:
#      INTEGER ARCTYP
#      REAL SPAN,RISE
#C
    g <- culvert$gravity;
    B <- culvert$span;
    D <- culvert$diameter;
    ARCTYP <- culvert$pipearch.type;

    ARAD <- vector(mode="numeric", length=3);

    if(g > 15) {
       SPAN <- B*12; # SPAN is in inches!
       RISE <- D*12; # RISE is in inches!
    } else {
       SPAN <- B*3.2808*12;  # meters to feet to inches
       RISE <- D*3.2808*12;  # meters to feet to inches
    }

    #ARCTYP <- as.integer((TCR - 300)/10); # TODO, WHAT IS TCR?
    # The as.integer() is my guess at getting something running.
    # TCR <- as.integer(TC/10); # in culrat.f
    # Now TC is a type of culvert, so there must be an interval within
    # the TC range that is reserved for pipearch?
    #C     ARCTYP -- 2,4 = CMP .LE. 18"CR,  5 = CMP-31",
    #C                 6 = CMP-47",  3 = ALUM. 31.8",  1 = R.C.P.
    if(ARCTYP == "CMP <=18inchCR") {
       ARAD[3] <- 18;
       if(RISE < 55) ARAD[3] <- 1.141 + 0.205*RISE;
       ARAD[2] <- 0.594 + 0.498*SPAN;
       ARAD[1] <- 7.000 - 2.036*RISE + 2.741*SPAN;
    } else if(ARCTYP == "CMP 31inchCR") {
       ARAD[3] <-   31;
       ARAD[2] <-   -0.346 +  0.505*SPAN;
       ARAD[1] <- -956.600 + 29.390*RISE - 13.49*SPAN;
    #} else if(ARCTYP == 4) { # TODO BUG IN CAP???? IT NEVER ASKED FOR TYPE 6
    } else if(ARCTYP == "CMP 47inchCR") { # Guessing type 6
       ARAD[3] <- 47; # see the 47 here
       ARAD[2] =   -3.27 +  0.521*SPAN;
       ARAD[1] = -982.30 + 18.440*RISE - 7.805*SPAN;
    } else if(ARCTYP == "ALUM 31.8inchCR") {
       ARAD[3] <- 31.8;
       ARAD[2] <-  -0.696 + 0.522*SPAN;
       ARAD[1] <- 363.300 - 9.639*RISE + 5.398*SPAN;
    } else if(ARCTYP == "RCP") {
       ARAD[3] <-   0.598 + 0.243*RISE;
       ARAD[2] <-   1.210 + 0.499*SPAN;
       ARAD[1] <- -60.130 + 2.106*SPAN + 0.583*abs(SPAN-95);
    } else {
       txt <- paste(c('Pipe archtype code ', ARCTYP,
                      ' is invalid.'),
                    sep=" ", collapse="");
       warning(txt);
    }

    ARAD <- ARAD; # UNIT CONVERSION OR NOT FROM INCHES?
    # WHA 10/28/2009 VOTES TO LEAVE IN INCHES PERIOD
    return(list(radius.bottom=ARAD[1],
                radius.top=ARAD[2],
                radius.corner=ARAD[3],
                radius.units="inches"));
}




################################################################
##    capR Source File ./CulvertProperties/Trapezoid/ARTRAP.R
################################################################
"ARTRAP" <-
function(depth=NULL, culvert=NULL) {

  diameter   <- culvert$diameter;
  width      <- culvert$width;
  sideslope  <- culvert$sideslope;
  web        <- culvert$web;
  nvalue     <- culvert$nvalue;
  manningcor <- culvert$manningcor;

  if(is.null(depth) || depth > diameter) depth <- diameter;
  if(depth < 0) depth <- 0;

  # remember that diameter is the height!
  if(is.null(width)) width <- 0;
  topwidth <- width + 2*sideslope*depth;
  wettedperimeter <- width + 2*depth*(sqrt(1+sideslope^2) + web);
  if(abs(depth - diameter) <= 0.0001) {
    wettedperimeter <- wettedperimeter + topwidth;
  }
  area <- depth*(width + sideslope*depth);
  hydraulicradius <- area/wettedperimeter;
  konvey <- Conveyance(A=area, R=hydraulicradius,
                       nvalue=nvalue, manningcor=manningcor);
  z <- list(DEPTH=depth, D=diameter, B=width,
            WEB=web, N=nvalue, A=area, TW=topwidth,
            WP=wettedperimeter, HR=hydraulicradius,
            KONVEY=konvey);
  return(z);
}


"demo.ARTRAP" <- function(depth=0) {
  culvert <- list(diameter=8, width=8, sideslope=2, web=0, nvalue=0.015,
                  manningcor=1.486);
  return(ARTRAP(depth=depth, culvert=culvert));
}



################################################################
##    capR Source File ./Examples/demo.TWRI.type1.R
################################################################
"demo.TWRI.type1" <-
function(example=c("1","2")) {
  example <- match.arg(example);
  if(example == 1) { # EXAMPLE 1 IN TWRI
     US.depth <- 12;
     DS.depth <- 6;
     my.approach <- setApproach(Lapproach=10,
                                X=c(0,0,200,200), Y=c(15,0,0,15));
     my.culvert <- setCulvert(name="TWRI EXAMPLE 1",
                              type="circle",
                              material="corrugated-metal",
                              diameter=10,
                              nvalue=0.024,
                              rounding=0.006,
                              slope=0.02,
                              L=100);
    flow <- computeFlow(culvert=my.culvert, approach=my.approach,
                        h1=US.depth, h4=DS.depth);
    # 729 cfs in TWRI
    # 725 cfs in capR
  } else { # EXAMPLE 2 IN TWRI
    US.depth <- 10;
    DS.depth <- 4;
    my.approach <- setApproach(Lapproach=20,
                               X=c(0,0,200,200), Y=c(15,0,0,15));
    my.culvert <- setCulvert(name="TWRI EXAMPLE 2",
                             type="box",
                             material="concrete",
                             diameter=8,
                             width=8,
                             web=0,
                             nvalue=0.015,
                             rounding=0,
                             slope=0.02,
                             L=100);
    flow <- computeFlow(culvert=my.culvert, approach=my.approach,
                        h1=US.depth, h4=DS.depth);
    # 530 cfs in TWRI
    # 530 cfs in capR
  }
}





################################################################
##    capR Source File ./Hydraulics/Alpha.R
################################################################
"Alpha" <-
function(area=NULL, konvey=NULL) {
  area   <- area[! is.na(area)];
  konvey <- konvey[! is.na(konvey)];
  AT2 <- sum(area)^2;   KT3 <- sum(konvey)^3;
   A2 <- area^2;         K3 <- konvey^3;
  return( sum(K3/A2)/(KT3/AT2) );
}

# This expression is based on the assumption that the discharge
# in a subsection is proportional to the conveyance. TWRI3/A1/p.29


################################################################
##    capR Source File ./Hydraulics/Conveyance.R
################################################################
"Conveyance" <-
function(A=NULL, R=NULL, nvalue=NULL, manningcor=NULL) {
  return( (manningcor/nvalue)*R^(2/3)*A );
}


################################################################
##    capR Source File ./Hydraulics/Froude.R
################################################################
"Froude" <-
function(discharge=NULL, area=NULL, topwidth=NULL, alpha=1, g=NULL) {
  velocity = discharge/area;
  hydraulicdepth = area/topwidth;
  return(velocity/sqrt(g*hydraulicdepth/alpha));
}




################################################################
##    capR Source File ./Hydraulics/getCriticalDepth.R
################################################################
"getCriticalDepth" <-
function(discharge, culvert=NULL, min.depth=NA, max.depth=NA,
         location=c("inlet", "outlet"), depression=0) {
  g <- culvert$gravity;
  D <- culvert$diameter;
  LHS <- discharge^2/g;
  LHS <- discharge;
  #catme("LHS=",LHS);
  "afunc" <- function(depth) {
    sec <- setCulvertGeometry(depth, culvert=culvert,
                              location=location, depression=depression);
    #if(TW == 0) TW <- 0.0001*D;
    RHS <- sqrt(g*sec$A^3/sec$TW);
    #catme("RHS=",RHS," depth=",depth+depression,
    #      " and A=",sec$A," and TW=",sec$TW);
    return(LHS - RHS);
  }

  ifelse(is.na(max.depth), right <- D-depression, right <- max.depth);
  ifelse(is.na(min.depth), left  <- 0.001*right,  left  <- min.depth);

  my.rt <- NULL;
  try(my.rt <- uniroot(afunc, interval=c(left, right)), silent=TRUE);
  ifelse(is.null(my.rt), return(NA), return(my.rt$root));
}



################################################################
##    capR Source File ./Hydraulics/getCriticalSlope.R
################################################################
"getCriticalSlope" <-
function(discharge, g=32.2, secfunc=NULL, ...) {
  afunc <- function(d, ...) {
    sec <- secfunc(d, ...);
    LHS <- discharge/g;
    RHS <- sec$A^3/sec$TW;
    return(LHS - RHS);	
  }
  rt <- uniroot(afunc, interval=c(0,searchMax), ...);
  return(rt$root);
}


################################################################
##    capR Source File ./Hydraulics/getDischargeAtCriticalDepth.R
################################################################
"getDischargeAtCriticalDepth" <-
function(depth, culvert=NULL,
         location=c("inlet", "outlet"), depression=0) {
  sec <- setCulvertGeometry(depth=depth, culvert=culvert,
                            location=location, depression=depression);
  discharge <- sec$A^(3/2)*sqrt(culvert$gravity/sec$TW);
  return(discharge);
}




################################################################
##    capR Source File ./Hydraulics/getDischargeCriticalDepthRelation.R
################################################################
"getDischargeCriticalDepthRelation" <-
function(culvert=NULL, location=c("inlet", "outlet")) {
   ifelse(location == "inlet", the.depression <- culvert$inlet.depression,
                               the.depression <- culvert$outlet.depression);
   Doff <- culvert$diameter - the.depression;
   dme  <- seq(0.001*Doff, Doff, by=.001);
   Qme  <- sapply(dme, getDischargeAtCriticalDepth, culvert=culvert,
                 location="inlet", depression=the.depression);
   minQ <- min(Qme);
   dc.at.minQ <- dme[Qme == minQ];
   return(list(dc=dme, Qc=Qme, minQ.at.dc=minQ, dc.at.minQ=dc.at.minQ));
}



################################################################
##    capR Source File ./Hydraulics/getHydraulicElements.R
################################################################
"getHydraulicElements" <-
function(culvert=NULL,
         location=c("inlet", "outlet"), depression=0,
         plotfile=NULL, dely=0.01, verbose=FALSE) {

   location <- match.arg(location);

           D <- culvert$diameter - depression;
          So <- culvert$So;
      sqrtSo <- ifelse(So <= 0, NA, sqrt(So));
  manningcor <- culvert$manningcor;
      nvalue <- culvert$nvalue;
           g <- culvert$gravity;

  if(depression != 0) {
     ifelse(location == "inlet", tmp <- culvert$inlet.depression,
                                 tmp <- culvert$outlet.depression);
     if(depression != tmp) {
        catme("Depression requested by function call does not match",
              "depression as set by either inlet.depression or",
              "outlet.depression in the culvert hash. This function",
              "requires for internal reasons that depression=0 or matches",
              "that specified by the culvert object");
        stop("depression != (outlet.depression | outlet.depression)");
     }
  }

  depths <- seq(dely, D, by=dely);
  n <- length(depths);
  A <- TW <- WP <- HR <- K <- Q <- V <- HD <- F <- vector(mode="numeric", length=n);
  for(i in 1:n) {
       geo <- setCulvertGeometry(depth=depths[i],
                                 culvert=culvert, location=location,
                                 depression=depression);
     A[i]  <- geo$A;
     TW[i] <- geo$TW;
     WP[i] <- geo$WP;
     HR[i] <- geo$HR;
     K[i]  <- geo$KONVEY;
     Q[i]  <- ifelse(is.na(sqrtSo), NA, geo$KONVEY * sqrtSo);
     V[i]  <- Q[i]/A[i];
     HD[i] <- A[i]/TW[i];
     F[i]  <- V[i]/sqrt(g*HD[i]);
  }
  area.full <-  A[n];
  hr.full   <- HR[n];
  wp.full   <- WP[n];
  k.full    <-  K[n];
  q.full    <-  Q[n];
  v.full    <-  V[n];
  f.full    <-  F[n];
  tw.max    <- max(TW);
  maxQ      <- max(Q);
  maxV      <- max(V);
  maxF      <- max(F);
  dimless.depth <- depths/D;
  dimless.area  <-  A/area.full;
  dimless.hr    <- HR/hr.full;
  dimless.tw    <- TW/tw.max;
  dimless.wp    <- WP/wp.full;
  dimless.k     <- K/k.full;
  dimless.q     <-  Q/q.full;
  dimless.v     <-  V/v.full;
  dimless.f     <-  F/maxF;
  x.max <- c(dimless.area, dimless.q,  dimless.v, dimless.k,
             dimless.hr,   dimless.tw, dimless.wp);
  x.max <- x.max[! is.na(x.max)];
  x.max <- max(x.max[! is.nan(x.max)]);
  #catme("x.max:",x.max);
  if(! is.null(plotfile)) pdf(plotfile);

  #catme("dimless.q", dimless.q);
  #catme("dimless.v", dimless.v);

  plot(dimless.area, dimless.depth, type="l", tcl=0.5,
       xlim=c(0,x.max), ylim=c(0,1), lty=3,
       xlab="Q/Qmax, V/Vmax, F/Fmax, A/Af, R/Rf, TW/TWmax, P/Pf, K/Kf, DIMENSIONLESS",
       ylab="DEPTH / MAXIMUM HEIGHT, DIMENSIONLESS");
  lines(c(1,1), c(0,1), col=8, lwd=0.75);

  maxdimless.q <- dimless.depth[Q == maxQ];
  maxdimless.v <- dimless.depth[V == maxV];
  maxdimless.f <- dimless.depth[F == maxF];
  if(! is.na(sqrtSo)) {
    lines(c(0,max(dimless.q)), c(maxdimless.q,maxdimless.q), col=8, lwd=0.5);
    points(max(dimless.q), maxdimless.q, pch=16, cex=1.5);
    lines(c(0,max(dimless.v)), c(maxdimless.v,maxdimless.v), col=8, lwd=0.5);
    points(max(dimless.v), maxdimless.v, pch=16, cex=1.5);
    lines(c(0,max(dimless.f)), c(maxdimless.f,maxdimless.f), col=8, lwd=0.5);
    points(max(dimless.f), maxdimless.f, pch=16, cex=1.5);

    lines(dimless.q,  dimless.depth, lwd=3);
    lines(dimless.v,  dimless.depth, lwd=3, lty=2);
    lines(dimless.f,  dimless.depth, lwd=3, lty=3);
  }
  lines(dimless.hr, dimless.depth, lty=2);
  lines(dimless.tw, dimless.depth, lty=1);
  lines(dimless.wp, dimless.depth, lty=4);
  lines(dimless.k,  dimless.depth, lty=6);



  legend(0, 0.75, c("Q/Qmax", "V/Vmax", "F/Fmax",
                    "A/Af", "R/Rf", "TW/TWmax", "P/Pf", "K/Kf"),
         lty=c(1,2,3,3,2,1,4,6), lwd=c(3,3,3,1,1,1,1,1),
         cex=0.75, bty="o", bg="white", box.lwd=4, box.col="white");

  if(! is.null(plotfile)) dev.off();

  z <- list(Qmax=maxQ, Qfull=q.full, Vfull=v.full, Vmax=maxV,
            diameter=D, width=tw.max, depths=depths,
            Area=A, HydraulicRadius=HR, Topwidth=TW,
            Conveyance=K, WettedPerimeter=WP, Froude=F, HydraulicDepth=HD);
  return(z);
}



################################################################
##    capR Source File ./Hydraulics/getNormalDepth.R
################################################################
"getNormalDepth" <-
function(discharge, culvert=NULL,
         location=c("inlet", "outlet"), depression=0) {
        g <- culvert$gravity;
        D <- culvert$diameter;
  nvalue  <- culvert$nvalue;
  manningcor <- culvert$manningcor;
  slope   <- culvert$So;

  if(slope <= 0) return(NA);
  LHS <- nvalue*discharge/(manningcor*sqrt(slope));
  #catme("LHS=",LHS);
  "afunc" <- function(depth) {
    sec <- setCulvertGeometry(depth, culvert=culvert,
                              location=location, depression=depression);
    RHS <- sec$A*sec$HR^(2/3);
    #catme("RHS=",RHS);
    return(LHS - RHS);
  }
  my.rt <- NULL;
  try(my.rt <- uniroot(afunc, interval=c(0.001*D,D-depression)), silent=TRUE);
  ifelse(is.null(my.rt), return(NA), return(my.rt$root));
}



################################################################
##    capR Source File ./Hydraulics/getSlopeEGL.R
################################################################
"getSlopeEGL" <-
function(discharge=NULL, depth=NULL, culvert=NULL) {
  nvalue     <- culvert$nvalue;
  manningcor <- culvert$manningcor;
  slope      <- culvert$So;
  secfunc    <- culvert$geometry.func;
  sec        <- secfunc(depth, culvert=culvert);
  Se <- ( (nvalue*discharge) / (manningcor*sec$A*HR^(2/3)) )^2;
  return(Se);
}



################################################################
##    capR Source File ./Hydraulics/getSubcriticalInletDepth.R
################################################################
"getSubcriticalInletDepth" <-
function(discharge, culvert=NULL, C=NULL, h1=NULL, dc=dc,
         v1head=NULL, h12=NULL, v3=NULL, searchMax=100, ...) {

  #catme("\n getSubcriticalInletDepth===============");

  z <- culvert$z;
  g <- culvert$gravity;
  D <- culvert$diameter;
  g2 <- 2*g; CC <- C^2;

  LHS <- h1 - z + v1head - (1/CC - 1)*v3^2/g2 - h12;

  depression <- culvert$inlet.depression;
  #catme("discharge=",discharge);
  #catme("LHS=",LHS);
  "afunc" <- function(depth) {
    sec <- setCulvertGeometry(depth, culvert=culvert,
                              location="inlet",
                              depression=depression);
    A2  <- sec$A;
    v2  <- discharge/A2;
    RHS <- depth + v2^2/g2;
    #catme("depth=",depth);
    #catme("RHS=",RHS);
    return(LHS - RHS);
  }
  my.rt <- NULL;
  try(my.rt <- uniroot(afunc, interval=c(dc,D-depression)), silent=TRUE);

  d2 <- h1 - z + v1head - h12 - v3^2/(g2*CC); # TWRI p.25 V2=V3
  if(is.null(my.rt)) return(d2);

  d2 <- my.rt$root;
  return(d2);
}


################################################################
##    capR Source File ./Hydraulics/HeadLoss12.R
################################################################
"HeadLoss12" <-
function(discharge, culvert=NULL, approach=NULL,
         d2=NULL, otherL=NULL, log2tmp=FALSE, ...) {
  ifelse(is.null(otherL), L <- approach$Lapproach, L <- otherL);
  konvey1 <- approach$geometry$KONVEYTOTAL;
  geo <- setCulvertGeometry(depth=d2,
                            culvert=culvert, location="inlet",
                            depression=culvert$inlet.depression);

  # Conveyance at section 2 is the sum of the TOTAL convenyance for
  # previously estimated system, which is stored in the approach
  # plus the conveyance for the currently processed culvert MINUS
  # the conveyance for said culvert from previous run
  konvey2 <- approach$TMP.konvey2.previous.run +
             geo$KONVEY - culvert$TMP.konvey2.previous.run;
  hf12 <- L*(approach$fraction.of.flow*discharge)^2/(konvey1*konvey2);
  if(is.nan(hf12)) hf12 <- 0;

  if(log2tmp) {
    sink("TMPcapR_HeadLoss12.txt", ...);
     catme("discharge=", discharge);
     catme("length=", L);
     catme("konvey1=", konvey1);
     catme("konvey2=", konvey2);
     catme("approachTMP.konvey2.previous.run",
           approach$TMP.konvey2.previous.run);
     catme("geoKONVEY", geo$KONVEY);
     catme("culvertTMP.konvey2.previous.run",
           culvert$TMP.konvey2.previous.run);
     catme("hf12=", hf12);
    sink();
  }
  return(hf12);
}






################################################################
##    capR Source File ./Hydraulics/HeadLoss23.R
################################################################
"HeadLoss23" <-
function(discharge, culvert=NULL, d2=NULL, d3=NULL,
         otherL=NULL, log2tmp=FALSE, ...) {
  ifelse(is.null(otherL), L <- culvert$Ltop, L <- otherL);
  geo2 <- setCulvertGeometry(depth=d2,
                             culvert=culvert, location="inlet",
                             depression=culvert$inlet.depression);
  geo3 <- setCulvertGeometry(depth=d3,
                             culvert=culvert, location="outlet",
                             depression=culvert$outlet.depression);
  konvey2 <- geo2$KONVEY;
  konvey3 <- geo3$KONVEY;
  hf23 <- L*discharge^2/(konvey2*konvey3);
  if(is.nan(hf23)) hf23 <- 0;
  if(log2tmp) {
     sink("TMPcapR_HeadLoss23.txt", ...);
        catme("discharge=",discharge);
        catme("length=",L);
        catme("konvey2=",konvey2);
        catme("konvey3=",konvey3);
        catme("hf23=",hf23);
     sink();
  }
  return(hf23);
}




################################################################
##    capR Source File ./Hydraulics/HeadwtrDiaRatio.R
################################################################
"HeadwtrDiaRatio" <-
function(h1=NULL, culvert=NULL, use.depression=TRUE) {
  z <- culvert$z;
  D <- culvert$diameter;
  if(use.depression) D <- D - culvert$inlet.depression;
  return((h1 - z)/D);
}


################################################################
##    capR Source File ./Hydraulics/SpecificEnergy.R
################################################################
"SpecificEnergy" <-
function(depth, alpha=1, velocity=0, g=32.2) {
  return(depth + alpha*velocity^2/(2*g));
}


################################################################
##    capR Source File ./Hydraulics/Cvalues/absMaxC.R
################################################################
"absMaxC" <-
function(C) {
  # TWRI p. 37
  ifelse(C > 0.98, return(0.98), return(C));
}



################################################################
##    capR Source File ./Hydraulics/Cvalues/C5FLARED.R
################################################################


Cval.5flared.h <- new.h();
set.h("c5vals",
      c(0.48, 0.50, 0.52, 0.53, 0.55, 0.56,
        0.57, 0.59, 0.61, 0.63, 0.65, 0.66),
      Cval.5flared.h);
set.h("hnode",
      c(1.4,  1.5,  1.6,  1.7,  1.8,  1.9,
        2.0, 2.5,  3.0,  3.5,  4.0,  5.0),
      Cval.5flared.h);



"C5FLARED" <-
function(hzD) {
  hnode    <- get.h("hnode",  Cval.5flared.h);
  c5vals   <- get.h("c5vals", Cval.5flared.h);
  c5flared <- approx(x=hnode, y=c5vals, xout=hzD,
                     yleft=c5vals[1], yright=c5vals[12]);
  return(c5flared$y);
}

"demo.C5FLARED" <-
function() {
  plot(C5FLARED(seq(1,10,by=0.1)), type="l");
}

#
#C=====C5FLARED eof===========================================================
#C
#C-----Purpose:
#C       interpolate tabled values of C5 for flared pipe ends from table on
#C       page 44 of the twri.
#C     Programmed by: JM Fulford
#C     Date: 12.96
#C
#      REAL FUNCTION C5FLARED(H)
#c
#C-----Arguments:
#      REAL H
#C
#C-----Local variables:
#      INTEGER I,NI
#      REAL HNODE(12),C5VALS(12),LX
#C
#C-----Initializations
#      DATA C5VALS /
#     # 0.48, 0.50, 0.52, 0.53, 0.55, 0.56, 0.57, 0.59
#     #,0.61, 0.63, 0.65, 0.66 /
#      DATA HNODE /
#     #  1.4, 1.5, 1.6, 1.7, 1.8, 1.9, 2.0, 2.5, 3.0,
#     #  3.5, 4.0, 5.0 /
#C
#      I=0
#      NI=12
# 10   CONTINUE
#      I=I+1
#      IF(HNODE(I).LT.H.AND.I.LT.NI) GO TO 10
#C
#      IF(I.EQ.1)THEN
#        C5FLARED=C5VALS(I)
#      ELSE IF(I.EQ.NI.AND.H.GE.HNODE(I))THEN
#        C5FLARED=C5VALS(I)
#      ELSE
#        X=H- HNODE(I-1)
#        LX=HNODE(I) - HNODE(I-1)
#        C5FLARED = C5VALS(I-1) + X*C5VALS(I)/LX
#      ENDIF
#C
#      RETURN
#      END
#C
#C=====C5FLARED bof===========================================================
#


################################################################
##    capR Source File ./Hydraulics/Cvalues/C5TABLE6.R
################################################################


Cval.5table6.h <- new.h();
set.h("c5vals",
      matrix(
      c(0.44, 0.46, 0.49, 0.50, 0.50, 0.51, 0.51,
        0.46, 0.49, 0.52, 0.53, 0.53, 0.54, 0.54,
        0.47, 0.51, 0.54, 0.55, 0.55, 0.56, 0.56,
        0.48, 0.52, 0.55, 0.57, 0.57, 0.57, 0.57,
        0.49, 0.54, 0.57, 0.58, 0.58, 0.58, 0.58,
        0.50, 0.55, 0.58, 0.59, 0.60, 0.60, 0.60,
        0.51, 0.56, 0.59, 0.60, 0.61, 0.61, 0.62,
        0.54, 0.59, 0.62, 0.54, 0.64, 0.65, 0.66,
        0.55, 0.61, 0.64, 0.66, 0.67, 0.69, 0.70,
        0.57, 0.62, 0.65, 0.67, 0.69, 0.70, 0.71,
        0.58, 0.63, 0.66, 0.68, 0.70, 0.71, 0.72,
        0.59, 0.64, 0.67, 0.69, 0.71, 0.72, 0.73), byrow=TRUE, ncol=7),
      Cval.5table6.h);
set.h("rnode", c(  0, 0.02, 0.04, 0.06, 0.08, 0.10, 0.14),
      Cval.5table6.h);
set.h("hnode", c(1.4, 1.5, 1.6, 1.7, 1.8, 1.9, 2.0, 2.5, 3.0, 3.5, 4.0, 5.0),
      Cval.5table6.h);


"C5TABLE6" <-
function(hzD=NULL, rnd=NULL) {

   c5vals <- get.h("c5vals", Cval.5table6.h);
   rnode  <- get.h("rnode",  Cval.5table6.h);
   hnode  <- get.h("hnode",  Cval.5table6.h);

   n.hnode <- length(hnode);
   min.hnode <- min(hnode); max.hnode <- max(hnode);
   nodes <- 1:n.hnode; rnds <- seq(0,0.14, by=0.01);
   c5table6 <- rep(NA, length(hzD));
   for(i in 1:length(hzD)) {
   	 h <- hzD[i];
   	 if(h < min.hnode) {
   	   the.value <- approx(x=rnode, y=c5vals[1,], xout=rnd)$y;
   	 } else if(h > max.hnode) {
       the.value <- approx(x=rnode, y=c5vals[n.hnode,], xout=rnd)$y;
   	 } else {
   	   j <- nodes[hnode == h];
   	   if(length(j) != 0) {
   	     the.value <- approx(x=rnode, y=c5vals[j,], xout=rnd)$y;
   	   } else {
   	     j1 <- max(nodes[hnode < h]); j2 <- min(nodes[hnode > h]);
         y <- c(approx(x=rnode, y=c5vals[j1,], xout=rnd)$y,
                approx(x=rnode, y=c5vals[j2,], xout=rnd)$y);
         the.value <- approx(x=hnode[c(j1,j2)], y=y, xout=h)$y;
       }
     }
     c5table6[i] <- the.value;
   }
   return(c5table6)
}


"demo.C5TABLE6" <-
function() {
  out <- C5TABLE6(runif(10, min=1,max=6), 0.08)
  print(out)
}
#C=====C5TAB6 bof=============================================================
#C
#C-----Purpose:
#C      Interpolate from table 6 values of twri on culverts to determine C5
#C     Programmed by: JM Fulford
#C     Date: 12.96
#C
#      REAL FUNCTION C5TAB6(RND,H)
#C
#C-----Arguments:
#      REAL RND,H
#C
#C-----Local Variables:
#      INTEGER I,J
#      REAL RNODE(7),HNODE(12),C5VALS(7,12)
#      REAL LX,LY,A1,B2,X1,X2
#C
#C-----Initializations
#      DATA C5VALS /
#     #  0.44, 0.46, 0.49, 0.50, 0.50, 0.51, 0.51,
#     #  0.46, 0.49, 0.52, 0.53, 0.53, 0.54, 0.54,
#     #  0.47, 0.51, 0.54, 0.55, 0.55, 0.56, 0.56,
#     #  0.48, 0.52, 0.55, 0.57, 0.57, 0.57, 0.57,
#     #  0.49, 0.54, 0.57, 0.58, 0.58, 0.58, 0.58,
#     #  0.50, 0.55, 0.58, 0.59, 0.60, 0.60, 0.60,
#     #  0.51, 0.56, 0.59, 0.60, 0.61, 0.61, 0.62,
#     #  0.54, 0.59, 0.62, 0.54, 0.64, 0.65, 0.66,
#     #  0.55, 0.61, 0.64, 0.66, 0.67, 0.69, 0.70,
#     #  0.57, 0.62, 0.65, 0.67, 0.69, 0.70, 0.71,
#     #  0.58, 0.63, 0.66, 0.68, 0.70, 0.71, 0.72,
#     #  0.59, 0.64, 0.67, 0.69, 0.71, 0.72, 0.73 /
#      DATA RNODE/ 0, 0.02, 0.04, 0.06, 0.08, 0.10, 0.14 /
#      DATA HNODE /
#     #      1.4, 1.5, 1.6, 1.7, 1.8, 1.9, 2.0,
#     #      2.5, 3.0, 3.5, 4.0, 5.0 /
#C
#      I=0
# 10   CONTINUE
#      I=I+1
#      IF(RNODE(I).LT.RND.AND.I.LT.7) GO TO 10
#      J=0
# 20   CONTINUE
#      J=J+1
#      IF(HNODE(J).LT.H.AND.J.LT.12) GO TO 20
#C
#      IF(I.EQ.1)THEN
#        IF(J.GT.1.AND.J.LE.12)THEN
#          X1=C5VALS(I,J-1)
#          X2=C5VALS(I,J)
#        ELSE
#          IF(J.GT.12) THEN
#            X1=C5VALS(I,12)
#          ELSE
#            X1=C5VALS(I,J)
#          ENDIF
#          X2=X1
#        ENDIF
#      ELSE IF(I.GT.7) THEN
#        IF(J.LT.13.AND.J.GT.1)THEN
#          X1=C5VALS(7,J-1)
#          X2=C5VALS(7,J)
#        ELSE
#          IF(J.GT.12)THEN
#            X1=C5VALS(7,12)
#          ELSE
#            X1=C5VALS(7,J)
#          ENDIF
#          X2=X1
#        ENDIF
#      ELSE
#        LX=RNODE(I) - RNODE(I-1)
#        A1=(RND - RNODE(I-1))/LX
#        IF(J.GT.1.AND.J.LE.12)THEN
#          X1=C5VALS(I-1,J-1) + A1*(C5VALS(I,J-1) - C5VALS(I-1,J-1))
#          X2=C5VALS(I-1,J) + A1*(C5VALS(I,J) - C5VALS(I-1,J))
#        ELSE IF(J.LE.1)THEN
#          X1=C5VALS(I-1,1) + A1*(C5VALS(I,1) -C5VALS(I-1,1))
#          X2=X1
#        ELSE
#          X1=C5VALS(I-1,12) + A1*(C5VALS(I,12)-C5VALS(I-1,12))
#          X2=X1
#        ENDIF
#      ENDIF
#      IF(J.EQ.1)THEN
#        B2=0
#      ELSE IF(J.GT.12)THEN
#        B2=0
#      ELSE
#        LY=HNODE(J)-HNODE(J-1)
#        B2=(H - HNODE(J-1))/LY
#      ENDIF
#      C5TAB6=X1 + B2*(X2-X1)
#C
#      RETURN
#      END
#C
#C=====C5TAB6 bof=============================================================
#


################################################################
##    capR Source File ./Hydraulics/Cvalues/C5TABLE7.R
################################################################


Cval.5table7.h <- new.h();
set.h("c5vals",
      matrix(
      c(0.44, 0.44, 0.44, 0.43, 0.42, 0.39,
        0.44, 0.46, 0.46, 0.45, 0.43, 0.41,
        0.46, 0.47, 0.47, 0.46, 0.45, 0.42,
        0.47, 0.49, 0.49, 0.48, 0.46, 0.43,
        0.48, 0.50, 0.50, 0.48, 0.47, 0.44,
        0.49, 0.51, 0.51, 0.50, 0.48, 0.45,
        0.50, 0.52, 0.52, 0.51, 0.49, 0.46,
        0.51, 0.53, 0.53, 0.52, 0.49, 0.46,
        0.54, 0.56, 0.56, 0.54, 0.52, 0.49,
        0.55, 0.58, 0.58, 0.56, 0.54, 0.50,
        0.57, 0.60, 0.60, 0.58, 0.55, 0.52,
        0.58, 0.61, 0.61, 0.59, 0.56, 0.53,
        0.59, 0.62, 0.62, 0.60, 0.58, 0.54), byrow=TRUE, ncol=6),
      Cval.5table7.h);
set.h("tnode", c(  0,  30,  45,  60,  75,  90),
      Cval.5table7.h);
set.h("hnode", c(1.3, 1.4, 1.5, 1.6, 1.7, 1.8, 1.9,
                 2.0, 2.5, 3.0, 3.5, 4.0, 5.0),
      Cval.5table7.h);


"C5TABLE7" <-
function(hzD=NULL, theta=NULL) {

   c5vals <- get.h("c5vals", Cval.5table7.h);
   tnode  <- get.h("tnode",  Cval.5table7.h);
   hnode  <- get.h("hnode",  Cval.5table7.h);

   n.hnode <- length(hnode);
   min.hnode <- min(hnode); max.hnode <- max(hnode);
   nodes <- 1:n.hnode; thetas <- seq(0,90, by=1);
   c5table7 <- rep(NA, length(hzD));
   for(i in 1:length(hzD)) {
   	 h <- hzD[i];
   	 if(h < min.hnode) {
   	   c5table7[i] <- approx(x=tnode, y=c5vals[1,], xout=theta)$y;
   	 } else if(h > max.hnode) {
       c5table7[i] <- approx(x=tnode, y=c5vals[n.hnode,], xout=theta)$y;
   	 } else {
   	   j <- nodes[hnode == h];
   	   if(length(j) != 0) {
   	     c5table7[i] <- approx(x=tnode, y=c5vals[j,], xout=theta)$y;
   	   } else {
   	     j1 <- max(nodes[hnode < h]); j2 <- min(nodes[hnode > h]);
         y <- c(approx(x=tnode, y=c5vals[j1,], xout=theta)$y,
                approx(x=tnode, y=c5vals[j2,], xout=theta)$y);
         c5table7[i] <- approx(x=hnode[c(j1,j2)], y=y, xout=h)$y;
       }
     }
   }
   return(c5table7)
}

"demo.C5TABLE7" <-
function() {
  out <- C5TABLE7(runif(10, min=1,max=3), 30)
  print(out)
}


#C=====C5TAB7 bof=============================================================
#C
#C-----Purpose:
#C       interpolate from tabled values C5 using table 7 of the TWRI on
#C       culverts
#C     Programmed by: JM Fulford
#C     Date: 12.96
#C
#      REAL FUNCTION C5TAB7(THETA,H)
#C
#C     Arguments:
#      REAL THETA,H
#C
#C     Local variables
#      INTEGER I,J
#      REAL TNODE(6),HNODE(13),C5VALS(6,13)
#      REAL LX,LY,A1,B2
#C
#C-----Initializations
#      DATA C5VALS /
#     # 0.44,0.44,0.44,0.43,0.42,0.39,
#     # 0.44,0.46,0.46,0.45,0.43,0.41,
#     # 0.46,0.47,0.47,0.46,0.45,0.42,
#     # 0.47,0.49,0.49,0.48,0.46,0.43,
#     # 0.48,0.50,0.50,0.48,0.47,0.44,
#     # 0.49,0.51,0.51,0.50,0.48,0.45,
#     # 0.50,0.52,0.52,0.51,0.49,0.46,
#     # 0.51,0.53,0.53,0.52,0.49,0.46,
#     # 0.54,0.56,0.56,0.54,0.52,0.49,
#     # 0.55,0.58,0.58,0.56,0.54,0.50,
#     # 0.57,0.60,0.60,0.58,0.55,0.52,
#     # 0.58,0.61,0.61,0.59,0.56,0.53,
#     # 0.59,0.62,0.62,0.60,0.58,0.54  /
#      DATA TNODE / 0.0, 30., 45., 60., 75., 90. /
#      DATA HNODE /
#     #     1.3, 1.4, 1.5, 1.6, 1.7, 1.8, 1.9, 2.,
#     #     2.5, 3.0, 3.5, 4.0, 5.0 /
#
#C
#      I=0
# 10   CONTINUE
#      I=I+1
#      IF(TNODE(I).LT.THETA.AND.I.LT.6) GO TO 10
#      J=0
# 20   CONTINUE
#      J=J+1
#      IF(HNODE(J).LT.H.AND.J.LT.13) GO TO 20
#C
#      IF(I.EQ.1)THEN
#        IF(J.GT.1.AND.J.LT.14)THEN
#          X1=C5VALS(I,J-1)
#          X2=C5VALS(I,J)
#        ELSE
#          IF(J.GT.13) THEN
#            X1=C5VALS(I,13)
#          ELSE
#            X1=C5VALS(I,J)
#          ENDIF
#          X2=X1
#        ENDIF
#      ELSE IF(I.GT.6) THEN
#        IF(J.LT.14.AND.J.GT.1)THEN
#          X1=C5VALS(6,J-1)
#          X2=C5VALS(6,J)
#        ELSE
#          IF(J.GT.13)THEN
#            X1=C5VALS(6,13)
#          ELSE
#            X1=C5VALS(6,J)
#          ENDIF
#        ENDIF
#      ELSE
#        LX=TNODE(I) - TNODE(I-1)
#        A1=(THETA - TNODE(I-1))/LX
#        IF(J.GT.1.AND.J.LE.13)THEN
#          X1=C5VALS(I-1,J-1) + A1*(C5VALS(I,J-1) - C5VALS(I-1,J-1))
#          X2=C5VALS(I-1,J) + A1*(C5VALS(I,J) - C5VALS(I-1,J))
#        ELSE IF(J.LE.1)THEN
#          X1=C5VALS(I-1,J) + A1*(C5VALS(I,J) - C5VALS(I-1,J))
#          X2=X1
#        ELSE
#          X1=C5VALS(I-1,13) + A1*(C5VALS(I,13) - C5VALS(I-1,13))
#          X2=X1
#        ENDIF
#      ENDIF
#      IF(J.EQ.1)THEN
#        B2=0
#      ELSE IF(J.GT.13)THEN
#        B2=0
#      ELSE
#        LY=HNODE(J)-HNODE(J-1)
#        B2=(H - HNODE(J-1))/LY
#      ENDIF
#      C5TAB7=X1 + B2*(X2-X1)
#C
#      RETURN
#      END
#C
#C=====C5TAB7 eof=============================================================
#


################################################################
##    capR Source File ./Hydraulics/Cvalues/Cbelltonguegroove.R
################################################################
"Cbelltonguegroove" <-
function() {
   return(0.95); # TWRI for bell mouthed or tongue and groove concrete
}


################################################################
##    capR Source File ./Hydraulics/Cvalues/CFIG19.R
################################################################
"CFIG19" <- 
function(C, areac=NULL, area1) {
  if(areac >= 0.2*area1 & area1 != 0) {
    return( 1.25 * (C - 0.196 + (areac * (0.98 - C)/area1)) );
  }
  return(C);
}


# FROM culrat.f
#C     adjustment for channel contraction
#      IF(AC.GE.0.2*A1.AND.A1.NE.0.0) C=1.25*(C-0.196+(AC*(0.98-C)/A1))


################################################################
##    capR Source File ./Hydraulics/Cvalues/CFIG20.R
################################################################
"CFIG20" <-
function(hzD=NULL) {
  return(0.88821+(0.21047-0.29299*hzD+0.078988*hzD*hzD)*hzD);
}

# do not forget to adjust for projection (KPROJ.R)
#C           adjust for projection if corrugated metal pipe

# FROM culrat.f
#C           pipe culverts with square entrance, flush with vertical headwall
#            C=0.88821+(0.21047-0.29299*H+0.078988*H*H)*H


################################################################
##    capR Source File ./Hydraulics/Cvalues/CFIG23.R
################################################################
"CFIG23" <-
function(froude=NULL) {
  if(froude == 1) return(0.95)
  return( 0.71364867 + froude*(0.38017909 - 0.14345278*froude) );
}

# FROM culrat.f
#C           box culverts - equation from fig.23 in TWRI
#            F=CQ/(AC*SQRT(D3*32.2))
#            C=0.71364867+F*(0.38017909-0.14345278*F)


################################################################
##    capR Source File ./Hydraulics/Cvalues/CFIG25.R
################################################################
"CFIG25" <-
function(hzD=NULL) {
  return(0.73620+(0.54049-0.49769*hzD+0.089097*hzD*hzD)*hzD);
}

# do not forget to adjust for projection (KPROJ.R)
#C           adjust for projection if corrugated metal pipe

# FROM culrat.f
#C           mitered entrance, flush with sloping embankment fig.25 TWRI
#            C=0.73620+(0.54049-0.49769*H+0.089097*H*H)*H


################################################################
##    capR Source File ./Hydraulics/Cvalues/Croadway.R
################################################################
# THIS FILE CREATES A HASH TABLE OF C AND KT VALUES FOR FLOW OVER ROAD
# AND A FUNCTION THAT RETURNS A LIST OF C VALUES FOR THE ROAD.
# USGS TWRI B3ChA5 p.26
# Several tables now follow with reference to figure number and the
# curve type from the figures. Each table is first and matrix that is
# cast into a data.frame with renaming of the columns to the axis labels
# from the original figure.
fig22.gravel <-
as.data.frame(matrix(c(
0.15,  2.94979757085,
0.160239005736,  2.95937018602,
0.169990439771,  2.96975716243,
0.180066921606,  2.98013949420,
0.189980879541,  2.98971443169,
0.200057361377,  2.99969190516,
0.210296367113,  3.01047677290,
0.220210325048,  3.02045656869,
0.229961759082,  3.03043868680,
0.240363288719,  3.04041151563,
0.247189292543,  3.04719656915,
0.249789674952,  3.05039827838,
0.257590822180,  3.05757425628,
0.260191204589,  3.06037110721,
0.268154875717,  3.06713990448,
0.270755258126,  3.06993675541,
0.280019120459,  3.07749669069,
0.287820267686,  3.08183866048,
0.294808795411,  3.08497766699,
0.300009560229,  3.08692764416,
0.306998087954,  3.08844721747,
0.310736137667,  3.08920352064,
0.32,  3.0894829735), ncol=2, byrow=TRUE));
names(fig22.gravel) <- c("h.over.L", "C");

fig22.paved <-
as.data.frame(matrix(c(
0.15,  3.04817813765,
0.156175908222,  3.05254565300,
0.160076481836,  3.05491906705,
0.166414913958,  3.05847222115,
0.169990439771,  3.06125513814,
0.180229445507,  3.06556227309,
0.186892925430,  3.06830106595,
0.190143403442,  3.07108862758,
0.195181644359,  3.07263606877,
0.200057361377,  3.07418583228,
0.209971319312,  3.07687817868,
0.220047801147,  3.08037791935,
0.229636711281,  3.08186033550,
0.240200764818,  3.08454339260,
0.249789674952,  3.08602580875,
0.259703632887,  3.08628900535,
0.269780114723,  3.08857417112,
0.280181644359,  3.08923525906,
0.290095602294,  3.08949845566,
0.299684512428,  3.09017115520,
0.310086042065,  3.08961766823,
0.32,  3.08988550948), ncol=2, byrow=TRUE));
names(fig22.paved) <- c("h.over.L", "C");

fig23.gravel <-
as.data.frame(matrix(c(
0,  2.5,
0.0459917998543,  2.52068965517,
0.103577674013,  2.54062066747,
0.153419376942,  2.56131254090,
0.203290656591,  2.58047381906,
0.256997050955,  2.60116791074,
0.295318621380,  2.61802664123,
0.356739610253,  2.63949046705,
0.406625678262,  2.65788644758,
0.479596376359,  2.68165282106,
0.544867268306,  2.70388416278,
0.602512295905,  2.72075398454,
0.687077068306,  2.74452701279,
0.794682105715,  2.7759663269,
0.894646490414,  2.80280941871,
0.963870803957,  2.82045119287,
1.02923042606,  2.83809074877,
1.10239337284,  2.85190825301,
1.17555631962,  2.86572575726,
1.25640428419,  2.88184359091,
1.35271101449,  2.89797029758,
1.44903253316,  2.91333170661,
1.52223984502,  2.92485331795,
1.59546194524,  2.93560963166,
1.68412802283,  2.94714011601,
1.75355937342,  2.95406772329,
1.82681105036,  2.96329344173,
1.96182384845,  2.9763811404,
2.03513467883,  2.9825456683,
2.10840114413,  2.99100608911,
2.19330604881,  2.99717727177,
2.30136952538,  3.00489235922,
2.40168883072,  3.0133683078,
2.50206728950,  3.01878306585,
2.60243095992,  3.02496312153,
2.69123013276,  3.02960592717,
2.79163816826,  3.03349008995,
2.89204620377,  3.03737425273,
2.98860433619,  3.04049089961,
3.09286227477,  3.04514257828,
3.28215821327,  3.04907776089,
3.44832515660,  3.04993844345,
3.57970987702,  3.05077916172,
3.73428274605,  3.05163318952,
3.85799723704,  3.04940828074,
3.95073504311,  3.05022681647,
4.0,  3.05178181254), ncol=2, byrow=TRUE));
names(fig23.gravel) <- c("H", "C");

fig23.paved <-
as.data.frame(matrix(c(
0,  2.84132496312,
0.0158974870879,  2.87807034083,
0.0425658297687,  2.8979836071,
0.0731136522443,  2.91713379399,
0.115225972304,  2.93782123091,
0.161232560518,  2.95698029081,
0.203463187458,  2.97154534666,
0.257302677063,  2.98535175963,
0.315051223182,  2.99686449795,
0.376694037456,  3.00684885926,
0.442245908246,  3.01453954592,
0.496248069811,  3.01992768492,
0.550265019736,  3.02455052628,
0.612011352531,  3.02917780415,
0.666087455897,  3.03073945497,
0.739487016436,  3.03231219707,
0.812842211895,  3.03618083207,
0.913324189197,  3.03623850667,
1.006047206910,  3.03782234004,
1.098799801340,  3.03787557813,
1.195417087210,  3.03793103448,
1.404095636320,  3.03881611783,
1.605059590930,  3.03893146704,
1.883287797510,  3.04062177660,
2.188583632490,  3.04156231630,
2.474556010300,  3.04249176473,
2.609775845430,  3.04486529653,
2.799160514090,  3.04420869334,
3.015524081000,  3.04739410610,
3.185555715760,  3.04825700691,
3.409693030620,  3.04915096328,
3.575845185590,  3.05077694347,
3.718838768670,  3.05085901887,
3.850223489090,  3.05169973714,
4.0,  3.05178181254), ncol=2, byrow=TRUE));
names(fig23.paved) <- c("H", "C");

fig24.gravel <-
as.data.frame(matrix(c(
0.691593743766, 1,
0.720969341118, 0.997572627636,
0.741067775869, 0.996397648404,
0.760782714072, 0.993296998425,
0.778950565270, 0.990968254346,
0.789003057849, 0.988262117508,
0.799829689421, 0.984784819134,
0.809498685452, 0.980153011550,
0.819942415969, 0.974364833843,
0.825744885472, 0.970892373838,
0.831162667445, 0.966264660257,
0.838513414936, 0.961249877180,
0.846639492403, 0.954693515395,
0.851671395862, 0.949680965411,
0.858639837788, 0.941970094415,
0.864445880241, 0.936186382895,
0.872189056652, 0.927319141778,
0.877998672054, 0.919224178743,
0.883422408942, 0.910744379304,
0.888458480842, 0.903035369220,
0.893110460702, 0.893785896974,
0.896599445597, 0.886848792790,
0.901250234475, 0.878369737716,
0.904355127331, 0.869892171371,
0.907072355199, 0.862185394379,
0.909788987575, 0.854863825974,
0.912506215443, 0.847157048982,
0.915223443311, 0.839450271991,
0.917168914151, 0.830973822192,
0.921048541492, 0.821339885725,
0.922609324802, 0.811708182351,
0.925331912094, 0.800534528088,
0.928435613967, 0.792827378914,
0.929219280825, 0.785892880005,
0.932327746630, 0.775104062145,
0.935053311380, 0.762004364953,
0.939337277472, 0.740813798730,
0.943620052582, 0.720393649678,
0.947902827692, 0.699973500627,
0.951024989802, 0.680324885293,
0.953762464382, 0.659521016385,
0.957658169995, 0.639486448101,
0.960779736614, 0.620223041354,
0.964289563713, 0.599803636667,
0.966638182322, 0.580540974284,
0.968214448411, 0.560893847679,
0.971723084527, 0.541244860164,
0.974075276085, 0.519670946266,
0.976423894693, 0.5), ncol=2, byrow=TRUE));
names(fig24.gravel) <- c("ht.over.H", "kt");

fig24.paved <-
as.data.frame(matrix(c(
0.794782898674, 1,
0.807926587804, 0.997103678053,
0.817590819903, 0.995553539155,
0.827643907973, 0.992462193731,
0.838085852014, 0.987829641782,
0.850462548049, 0.981654394579,
0.858587434533, 0.975868449965,
0.867100581497, 0.968926507412,
0.873293097955, 0.963142423710,
0.880260348898, 0.956201969886,
0.886455247323, 0.948877051841,
0.892651932221, 0.940396508038,
0.898462143114, 0.931916336417,
0.905048279476, 0.921509377503,
0.910476184805, 0.910333117964,
0.915129355648, 0.900313228547,
0.920169595989, 0.889907758361,
0.924437483810, 0.879117823955,
0.927932423621, 0.868328633913,
0.931424385974, 0.859465486799,
0.933758117294, 0.849833039061,
0.936092444106, 0.839815382737,
0.940366882334, 0.824788153887,
0.942307589242, 0.819393372775,
0.946201508380, 0.800514430249,
0.950095427518, 0.781635487722,
0.954378798119, 0.760830130085,
0.957501555722, 0.740796306166,
0.961397261334, 0.720761737882,
0.963748857401, 0.699573032570,
0.967643967522, 0.679923672873,
0.969221424594, 0.659506129097,
0.973116534716, 0.639856769399,
0.975079274810, 0.620209270612,
0.976656136391, 0.600176935422,
0.979778298502, 0.580528320089,
0.981741634088, 0.560495612716,
0.983703778692, 0.541233322515,
0.986054779266, 0.520429825789,
0.986472218831, 0.5), ncol=2, byrow=TRUE));
names(fig24.paved) <- c("ht.over.H", "kt");

RoadCvals.h <- new.h(); # Create the parent container of C and kt tables
# Make some handy notes
set.h("reference",
      "The figure numbers referenced are for USGS TWRI Book3 Chapter4",
      RoadCvals.h);
set.h("source",
      paste(c("Dr. Theodore Cleveland (TTU, Lubbock, Texas) digitized ",
              "the figures from jpgs on Dec. 19, 2009 using G3data software. ",
              "Dr. William Asquith (USGS, Lubbock, Texas) implemented in R."),
              collapse=""),
      RoadCvals.h);
# Populate the hash with the tables of the figures.
set.h("fig22.gravel", fig22.gravel, RoadCvals.h);
set.h("fig23.gravel", fig23.gravel, RoadCvals.h);
set.h("fig24.gravel", fig24.gravel, RoadCvals.h);
set.h("fig22.paved",  fig22.paved,  RoadCvals.h);
set.h("fig23.paved",  fig23.paved,  RoadCvals.h);
set.h("fig24.paved",  fig24.paved,  RoadCvals.h);

# Now remove the temporary storage units as RoadCvals.h holds contents now.
rm(fig22.gravel, fig23.gravel, fig24.gravel,
   fig22.paved,  fig23.paved,  fig24.paved);

"Croad" <-
function(H=NULL, h=NULL, ht=HULL, L=NULL, type=c("paved", "gravel")) {

  if(! is.h(RoadCvals.h)) {
    stop("Hash tables of C and kt values (RoadCvals.h) for flow over road is missing");
  }

  type <- match.arg(type);

  if(h > H) {
     stop("h > H, physically impossible, velocity head problem?");
  }

  if(type == "gravel") {
     fig22 <- get.h("fig22.gravel", RoadCvals.h);
     fig23 <- get.h("fig23.gravel", RoadCvals.h);
     fig24 <- get.h("fig24.gravel", RoadCvals.h);
  } else {
     fig22 <- get.h("fig22.paved",  RoadCvals.h);
     fig23 <- get.h("fig23.paved",  RoadCvals.h);
     fig24 <- get.h("fig24.paved",  RoadCvals.h);
  }

  ht.over.H <- ht/H;
  h.over.L  <- h/L;
  which.fig <- ""
  if(h.over.L >= 0.15) {
    Cbase <- approx(fig22$h.over.L, y=fig22$C,
                    xout=h.over.L, rule=2)$y;
    which.fig <- "Cbase from fig22";
  } else {
    Cbase <- approx(fig23$H, y=fig23$C,
                    xout=H, rule=2)$y;
    which.fig <- "Cbase from fig23";
  }
  kt <- approx(fig24$ht.over.H, y=fig24$kt,
               xout=ht.over.H, rule=2)$y;
  return(list(Croad=kt*Cbase, kt=kt, Cbase=Cbase,
              fig=which.fig, ht.over.H=ht.over.H, h.over.L=h.over.L));
}

#Croad(h=6, H=6.4, L=100, ht=0, type="paved")






################################################################
##    capR Source File ./Hydraulics/Cvalues/getCforType1.R
################################################################
"getCforType1" <-
function(culvert=NULL, approach=NULL, hzD=NULL, A1=0, Ac=0) {

  if(! is.null(culvert$C1master)) return(culvert$C1master);

  return(getCforTypes123(culvert=culvert, approach=approach,
                         froude=1, hzD=hzD, A1=A1, Ac=Ac,
                         attempted.flow.type="1"));
}



################################################################
##    capR Source File ./Hydraulics/Cvalues/getCforType2.R
################################################################
"getCforType2" <-
function(culvert=NULL, approach=NULL, hzD=NULL, A1=0, Ac=0) {

  if(! is.null(culvert$C2master)) return(culvert$C2master);

  return(getCforTypes123(culvert=culvert, approach=approach,
                         froude=1, hzD=hzD, A1=A1, Ac=Ac,
                         attempted.flow.type="2"));
}



################################################################
##    capR Source File ./Hydraulics/Cvalues/getCforType3.R
################################################################
"getCforType3" <-
function(culvert=NULL, approach=NULL, froude=NULL, hzD=NULL, A1=0, Ac=0) {

  if(! is.null(culvert$C3master)) return(culvert$C3master);

  return(getCforTypes123(culvert=culvert, approach=approach,
                         froude=froude, hzD=hzD, A1=A1, Ac=Ac,
                         attempted.flow.type="3"));
}



################################################################
##    capR Source File ./Hydraulics/Cvalues/getCforType4.R
################################################################
"getCforType4" <-
function(culvert=NULL) {

   if(! is.null(culvert$C4master)) return(culvert$C4master);

   type  <- culvert$type;
   inlet <- culvert$inlet;
   rnd   <- culvert$rounding;
   bev   <- culvert$beveling;
   if(bev > rnd) rnd <- bev;

   kproj <- culvert$kproj
   # TODO kwr????
   if(is.null(culvert$theta)) {
     C1 <- QC46(type=type, kwr=1, rnd=rnd, theta=culvert$theta.left, inlet=inlet, kproj=kproj);
     C2 <- QC46(type=type, kwr=1, rnd=rnd, theta=culvert$theta.right, inlet=inlet, kproj=kproj);
     C <- mean(C1, C2)
   } else {
     C <- QC46(type=type, kwr=1, rnd=rnd, theta=culvert$theta, inlet=inlet, kproj=kproj);
   }
   return(absMaxC(C));
}



################################################################
##    capR Source File ./Hydraulics/Cvalues/getCforType5.R
################################################################
"getCforType5" <-
function(h1=NULL, culvert=NULL) {

   if(! is.null(culvert$C5master)) return(culvert$C5master);

   type          <- culvert$type;
   inlet         <- culvert$inlet;
   embankment    <- culvert$embankment;
   material      <- culvert$material;
   projectlength <- culvert$projectlength;
   rnd           <- culvert$rounding;
   bev           <- culvert$beveling;
   kproj         <- culvert$kproj;
   C <- NULL;

   hzD <- HeadwtrDiaRatio(h1=h1, culvert=culvert);

   # TODO not testing L/D < 6 and So < 0.03
   if(inlet == "flared") return(C5FLARED(hzD));

   Ctable6 <- C5TABLE6(hzD=hzD, rnd=culvert$rounding);
   if(is.null(culvert$theta)) {
      Ctable7 <- mean(C5TABLE7(hzD=hzD, theta=culvert$theta.left),
                      C5TABLE7(hzD=hzD, theta=culvert$theta.right));
   } else {
      Ctable7 <- C5TABLE7(hzD=hzD, theta=culvert$theta);
   }
   # Open question now, where is the wingwall correction for high-head
   # on non-box culverts?  TWRI is silent. The Ctable7 computation is
   # extra and only needed if type is box. But logic is just to get the
   # two tables computed and then deal with ramifications.
    
   if(projectlength > 0 &
        (material == "corrugated-metal" |
             type == "pipearch")) {
      C <- Ctable6*kproj;
      return(absMaxC(C));
   }
   # Note the above test is from TWRI p. 44 and this implies a 
   # projection correction is not applicable to circular concrete
   # pipes. This subroutine does not apply kproj in the concrete
   # circular case. (Should it?)  CAPGUI appears to do this.

   if(inlet == "mitered" & embankment == "slope") {
      C <- Ctable6*kproj*0.92; # TWRI p. 44
      return(absMaxC(C));
   }

   if(type == "box") {
      C7 <- Ctable7;
      if(rnd != 0 | bev != 0) {
        C6 <- Ctable6;
        ifelse(C6 < C7, C <- C7, C <- C6);
        return(absMaxC(C));
      }
      return(absMaxC(C7));
   }
   return(absMaxC(Ctable6));
}



################################################################
##    capR Source File ./Hydraulics/Cvalues/getCforType6.R
################################################################
"getCforType6" <-
function(culvert=NULL) {

   if(! is.null(culvert$C6master)) return(culvert$C6master);

   type  <- culvert$type;
   inlet <- culvert$inlet;
   bev   <- culvert$beveling;
   rnd   <- culvert$rounding;
   if(bev > rnd) rnd <- bev;

   kproj <- culvert$kproj
   # TODO kwr????
   if(is.null(culvert$theta)) {
     C1 <- QC46(type=type, kwr=1, rnd=rnd, theta=culvert$theta.left, inlet=inlet, kproj=kproj);
     C2 <- QC46(type=type, kwr=1, rnd=rnd, theta=culvert$theta.right, inlet=inlet, kproj=kproj);
     C <- mean(C1, C2)
   } else {
     C <- QC46(type=type, kwr=1, rnd=rnd, theta=culvert$theta, inlet=inlet, kproj=kproj);
   }
   return(absMaxC(C));
}



################################################################
##    capR Source File ./Hydraulics/Cvalues/getCforTypes123.R
################################################################
"getCforTypes123" <-
function(culvert=NULL, approach=NULL, froude=NULL, hzD=NULL, A1=0, Ac=0, 
         attempted.flow.type="not given") {

  #catme("attempted.flow.type=",attempted.flow.type);

  Ac <- Ac - culvert$TMP.terminal.area.previous.run + 
             approach$TMP.terminal.area.previous.run;

  type       <- culvert$type;
  inlet      <- culvert$inlet;
  embankment <- culvert$embankment;
  material   <- culvert$material;

  beveling <- culvert$beveling;

  krnd    <- culvert$krnd;
  kbev    <- culvert$kbev;
  kproj   <- culvert$kproj;
  kthetas <- culvert$ktheta;

  if(culvert$is.bellmouthed |
     culvert$is.tonguegroove) return(Cbelltonguegroove()); #TWRI p.40

  C <- sapply(kthetas, function(ktheta) {
    Cbase <- NULL;

    if(type == "circle" | type == "ellipse") {
       #catme("circle or ellipse");
       if(inlet == "mitered" & embankment == "slope") {
         Cbase <- CFIG25(hzD=hzD);       # TWRI Figure 25
         C <- Cbase*kproj;               # TWRI p. 42
       } else {
         Cbase <- CFIG20(hzD=hzD);       # TWRI Figure 20
         #catme("Cbase:",Cbase)
         #catme("krnd, kbev, ktheta:",krnd,kbev,ktheta)
         C <- Cbase*krnd*kbev;           # TWRI p. 39 (NO Ktheta, p. 41)
         if(beveling == 0) C <- C*kproj; # TWRI p. 42
       }
    } else if(type == "box") {
       #catme("box");
       Cbase  <- CFIG23(froude);         # TWRI Figure 23
       #catme("C123, box, Cbase",Cbase);
       C <- Cbase*krnd*kbev*ktheta;      # TWRI p. 41
       #catme("Cbase(froude):",Cbase,"(",froude,")")
       #catme("krnd, kbev, ktheta:",krnd,kbev,ktheta)
    } else {
       #catme("all else");
       C <- 0.95*krnd*kbev*ktheta*kproj; # ALL ELSE?
    }
    #catme("C (before contraction):",C);

    # A1 is area of approach section
    # Ac is "terminal" area
    # 1.25 is 1/0.80
    # finally adjust for contraction
    #catme("A1",A1);
    #catme("Ac",Ac);
    # Note that the implemented correction adjustment is not the
    # same as the one in the TWRI.
    if(A1 != 0 & Ac >= 0.2*A1) { # FROM Cap96.08c
       #catme("C:",C);
       #m <- 1 - Ac/A1; # TWRI p.38
       #C <- 0.98 - (0.98 - C)*m/0.80 # TWRI p.38
       #catme("C (aftercontraction):",C);
       C <- 1.25*(C - 0.196 + (Ac*(0.98-C)/A1) ); # FROM Cap96.08c
       #catme("C (fortran):",C);
    }
    return(C)
  })
  C <- mean(C) # TWRI P. 41
  return(absMaxC(C))
}



################################################################
##    capR Source File ./Hydraulics/Cvalues/KBEV.R
################################################################
"KBEV" <-
function(rnd=NULL, theta=NULL) {
  if(theta <= 0) {
    return(1);
  } else if(theta <= 30) {
    Y1 <- 0.99973 + 1.4707*rnd - 4.77*rnd^2 - 11.794*rnd^3;
    return(1.0 + theta*(Y1 - 1)/30);
  } else if(theta <= 45) {
    Y1 <- 0.99973 + 1.4707*rnd -   1.77*rnd^2 - 11.794*rnd^3;
    Y2 <- 0.99897 + 3.6457*rnd - 25.459*rnd^2 + 40.508*rnd^3;
    return(Y1 + (theta - 30)*(Y2-Y1)/15);
  } else if(theta <= 60) {
    Y2 <- 0.998997 + 3.6457*rnd - 25.459*rnd^2 + 40.508*rnd^3;
    Y3 <- 1        + 4.8351*rnd - 18.307*rnd^2 - 19.827*rnd^3;
    return(Y2 + (theta - 45)*(Y3-Y2)/15);
  } else  {
    return(1.0+4.8351*rnd - 18.307*rnd^2 - 19.827*rnd^3);
  }
}



#C=====KBEV bof=============================================================
#C
#C-----Purpose:
#C        compute coefficient adjustments for beveling of box or pipe
#C     Programmed by: JM Fulford
#C     Date: 12.96
#C
#      REAL FUNCTION KBEV(RND,THETA)
#C
#C-----Arguments:
#      REAL RND,THETA
#C
#C-----Local variables:
#      REAL Y,Y2,Y3
#C
#      IF(THETA.LE.0.0) THEN
#        KBEV=1.0
#      ELSE IF(THETA.LE.30.) THEN
#        Y=0.99973 + 1.4707*RND - 4.77*RND*RND - 11.794*RND*RND*RND
#        KBEV=1.0 + THETA*(Y - 1.0)/30.0
#      ELSE IF (THETA.LE.45.0) THEN
#        Y=0.99973 + 1.4707*RND - 1.77*RND*RND - 11.794*RND*RND*RND
#        Y2=0.99897 + 3.6457*RND - 25.459*RND*RND + 40.508*RND*RND*RND
#        KBEV = Y + (THETA - 30.0)*(Y2-Y)/15.0
#      ELSE IF(THETA.LE.60)THEN
#        Y2=0.998997 + 3.6457*RND - 25.459*RND*RND + 40.508*RND*RND*RND
#        Y3=1.0 + 4.8351*RND - 18.307*RND*RND -19.827*RND*RND*RND
#        KBEV=Y2 + (THETA-45.0)*(Y3-Y2)/15.0
#      ELSE IF (THETA.GT.60) THEN
#        KBEV=1.0+4.8351*RND - 18.307*RND*RND - 19.827*RND*RND*RND
#      ENDIF
#C
#      RETURN
#      END
#C
#C=====KBEV eof=================================================================
#


################################################################
##    capR Source File ./Hydraulics/Cvalues/KPRJCT.R
################################################################
"KPRJCT" <-
function(projectratio=0) {
  if(projectratio < 0.1)  return(0.99909 - 0.78182*projectratio);
  return(0.92246 - 0.024299*projectratio);
}
# See TWRI p. 41-42

#C=====KPRJCT bof===============================================================
#C
#C-----Purpose:
#C       computes the coefficient adjustment for projecting pipes
#C-----Programmed by: JM Fulford
#C       
#      REAL FUNCTION KPRJCT(LPRJCT)
#C
#C-----Arguments:
#      REAL LPRJCT
#C
#C-----Local variables:
#C
#      IF(LPRJCT.LT.0.1)THEN
#        KPRJCT = 0.99909 - 0.78182*LPRJCT
#      ELSE IF(LPRJCT.GE.0.1)THEN
#        KPRJCT = 0.92246 - 0.024299*LPRJCT
#      ENDIF
#C
#      RETURN
#      END
#C
#C=====KPRJCT eof===============================================================
#


################################################################
##    capR Source File ./Hydraulics/Cvalues/KRND.R
################################################################
"KRND" <-
function(rnd) {
  if(rnd <= 0.115) {
    return(1.0005 + 1.9662*rnd + 4.5275*rnd^2 - 61.792*rnd^3);
  } else if(rnd <= 0.133) {
    return(1.192 + 0.4444*(rnd - 0.115));
  } else {
    return(1.2);
  }
}


#C=====KRND bof=================================================================
#C
#C-----Purpose:
#C       interpolates rounding adjustment coefficients
#C     Programmed by: JM Fulford
#C
#      REAL FUNCTION KRND(RND)
#C
#C-----Arguments:
#      REAL RND
#C
#C-----Local variables
#C
#      IF(RND.LE.0.115) THEN
#        KRND=1.0005 + 1.9662*RND + 4.5275*RND*RND - 61.792*RND*RND*RND
#      ELSE IF (RND.LE.0.133)THEN
#        KRND=1.192 + 0.4444*(RND - 0.115)
#      ELSE
#        KRND=1.2
#      ENDIF
#C
#      RETURN
#      END
#C
#C=====KRND eof=============================================================
#C
#


################################################################
##    capR Source File ./Hydraulics/Cvalues/KWINGWALL.R
################################################################
"KWINGWALL" <-
function(theta) {
  # vectorization to support asymmetric wingwalls
  kwing <- sapply(theta, function(theta) {
    if(theta < 0 | theta > 90) {
        stop("theta is not in [0,90]");
    }
    if(theta == 0) return(1);
    ang <- theta/180*pi;
    ang <- cos(ang);
    if(ang <= 0.5) {
      return(1.0594+0.3062*ang);
    } else {
      return(1.2402+(0.27173-0.79619*ang+0.28426*ang*ang)*ang);
    }
  })
  return(kwing);
}
# See figure 42 of TWRI8-A3

"demo.WINGWALL" <-
function() {
  plot(KWINGWALL(0:90), type="l")
}

#C=====WINGWALL #bof==============================================================
#C
#C-----Purpose:
#C       computes the discharge coefficient adjustment due to the
#C       wingwall angle. Computed when the value of angle is read.
#C     Programmed by: JM Fulford
#C     Date:
#C     Modified by:
#C     Last modified:
#C
#      REAL FUNCTION WINGWALL (THETA)
#C
#C-----Arguments:
#      REAL THETA
#C
#C-----Local variables:
#      REAL ANG
#C
#      IF(THETA.LT.0.0.OR.THETA.GT.90)THEN
#        WINGWALL=-1.0
#      ELSE IF (THETA.EQ.0) THEN
#        WINGWALL=1.0
#      ELSE
#        THETA=THETA/57.2958
#        ANG=COS(THETA)
#        IF(ANG.LT.0.5)THEN
#          WINGWALL=1.0594+0.3062*ANG
#        ELSE
#          WINGWALL=1.2402+(0.27173-0.79619*ANG+0.28426*ANG*ANG)*ANG
#        ENDIF
#      ENDIF
#C
#      RETURN
#      END
#C
#C=====WINGWALL #eof============================================================


################################################################
##    capR Source File ./Hydraulics/Cvalues/QC46.R
################################################################
"QC46" <- function(type=c("circle", "box", "ellipse", "pipearch", "nonstandard"),
                   kwr=NULL, rnd=NULL, theta=NULL,
                   inlet=c("flush", "mitered", "flared"), kproj=NULL) {
   # tc - culvert code type; 1-circular, 2-box, 3-pipe arch, 4-nonstand.
   # kproj  - projecting pipe adjustment to discharge coefficient (pg 42)
   # rnd    - rounding or beveling ratio
   inlet <- match.arg(inlet);
   type  <- match.arg(type);
   
   QC46 <- rep(1, length(theta)); # vectorization for asymmetric wingwalls
   for(i in 1:length(theta)) {
     if(inlet == "mitered") {
       QC46[i] <- 0.74
     } else if(inlet == "flared") {
       QC46[i] <- 0.90
     } else if(theta[i] < 75 | ( type != "circle" & type != "ellipse")) {
       C46 <- 0.84 + 2.125*rnd - 8.035*rnd*rnd
       if(theta[i] >= 30 & C46 < 0.87 &
                      (type == "circle" | type == "ellipse")) C46 <- 0.87
     } else if(theta[i] >= 75 & (type == "circle" | type == "ellipse")) {
       C46 <- (1.47 - 0.008*theta[i])*kwr
     }
     if(inlet != "flared") QC46[i] <- kproj*C46
   }
   return(mean(QC46));
}


#C=====QC46 bof=================================================================
#C
#C-----Purpose:
#C      computes default C46 discharge coefficients according to the TWRI
#C      chapter A3, "Measurement of Peak Discharge at Culverts by Indirect
#C      Methods", pg 42 and 43 using table 5.
#C     Programmed by: JM Fulford
#C
#      REAL FUNCTION QC46(TC,KWR,RND,THETA,INLET,KPROJ)
#c
#C-----Arguments:
#      INTEGER INLET,TC
#      REAL KWR,THETA,KPROJ
#C
#C-----Local variables:
#C
#      QC46=1.0
#      IF (INLET.EQ.2)THEN
#C       mitered pipe
#        QC46=0.74
#      ELSE IF(INLET.EQ.4)THEN
#C       flared pipe ends
#        QC46=0.90
#      ELSE IF(THETA.LT.75.0.OR.TC.GT.1)THEN
#        C46=0.84 + 2.125*RND - 8.035*RND*RND
#        IF(THETA.GE.30.AND.C46.LT.0.87.AND.TC.EQ.1) C46=0.87
#      ELSE IF(THETA.GE.75.0.AND.TC.EQ.1)THEN
#        C46=(1.47 - 0.008*THETA)*KWR
#      ENDIF
#      IF(INLET.NE.4)THEN
#        QC46=KPROJ*C46
#      ENDIF
#C
#      RETURN
#      END
#C
#C=====QC46 eof=================================================================
#


################################################################
##    capR Source File ./Hydraulics/FlowTypes/capgraph.R
################################################################
"capgraph.deforceEqualApproachHead" <-
function(...) {
   capgraph(forceEqualApproachHead=FALSE, ...)
}
"capgraph.forceIgnoreApproachHead" <-
function(...) {
   capgraph(forceIgnoreApproachHead=TRUE, ...)
}

"capgraph" <-
function(h1=NULL, h4=NULL, datetime=NULL, culvert=NULL, approach=NULL,
         silent=TRUE, unlink=FALSE, showprogress=TRUE,
         savefile="TMP4capR_capgraph.RData",
         forceEqualApproachHead=NULL,
         forceIgnoreApproachHead=NULL) {

   n  <- length(h1); IX <- 1:n;
   if(n != length(h4)) {
      stop("\n*** headwater and tailwater vectors not of equal length ***");
   }

   if(is.null(datetime)) datetime <- 1:n;
   cache.h <- new.h();

   total.flows <- types <- abstypes <- vector(mode="numeric");
   road.flows <- culvert.flows <- total.flows;

   counter <- 0;
   if(showprogress) {
         catme(c("Processing", length(h1),
                 "values ('*' means from dynamic cache)..."));
   }
   for(i in IX) {
      if(showprogress) message(c(i), appendLF=FALSE);
      US.depth <- h1[i]; DS.depth <- h4[i];
      key <- paste(c(US.depth,":",DS.depth), sep="", collapse="");
      if(has.key(key, cache.h)) {
         cat(c("* "));
         computed.flow <- get.h(key, cache.h);
      } else {
         cat(c("  "));
         computed.flow <- computeFlow(culvert=culvert, approach=approach,
                                      h1=US.depth, h4=DS.depth, silent=silent,
                                      verbose=TRUE, plotapproach=FALSE,
                                      forceEqualApproachHead=forceEqualApproachHead,
                                      forceIgnoreApproachHead=forceIgnoreApproachHead);
      }
      if(! is.list(computed.flow)) {
         the.Qtotal <- the.Qroad <- the.Qculvert <- the.type <- NA;
      } else {
         the.Qtotal   <- computed.flow$Qtotal;
         the.Qroad    <- computed.flow$Qroad;
         the.Qculvert <- computed.flow$Qculvert;
         the.type     <- computed.flow$type;
         if(is.nan(the.Qculvert) | is.na(the.Qculvert)) {
            the.Qculvert <- NA;
            the.type     <- 0;
         }
         if(is.nan(the.Qtotal) | is.na(the.Qtotal)) the.Qtotal <- NA;
         if(is.nan(the.Qroad)  | is.na(the.Qroad)) the.Qroad <- NA;

      }
      total.flows[i]   <- the.Qtotal;
      culvert.flows[i] <- the.Qculvert;
      road.flows[i]    <- the.Qroad;
      abstypes[i]      <- ifelse(is.numeric(the.type), abs(the.type), 96);
      types[i]         <- the.type;
      set.h(key, computed.flow, cache.h);
   }
   if(showprogress) catme("\n");
   capgraph.RData <- list(ix=IX,
                          datetime=datetime,
                          h1=h1, h4=h4,
                          Qtotal=total.flows,
                          Qculvert=culvert.flows,
                          Qroad=road.flows,
                          Qtype=types, abstypes=abstypes);
   if(unlink) {
      message("Unlinking the savefile");
      try(unlink(savefile));
   }
   if(! file.exists(savefile)) {
      message("The savefile does not exist, testing whether to create one");
      if(! is.na(savefile)) {
        message(paste(c("savefile= ",savefile," now being written"),
                      collapse=""));
        try(save(capgraph.RData, file=savefile));
      } else {
        message("savefile=NA, so it was not written");
      }
   }
   return(capgraph.RData);
}

"plot.capgraph" <-
function(capgraph, culvert=NULL, plotfile=NULL, showtype=FALSE,
         showpoints=TRUE, ask=TRUE, index=NULL, minh=0) {

   if(is.null(culvert) || ! is.h(culvert)) {
     stop("culvert is NULL or not a culvert hash");
   }

   atypes <- c("1", "2", "3", "4", "5", "6");

   if(length(index) == 1) {
      index <- c(index, length(capgraph$ix));
   }
   if(is.null(index)) {
      datetime    <- capgraph$ix; # TODO: TIME SERIES
      h1          <- capgraph$h1;
      h4          <- capgraph$h4;
      total.flows <- capgraph$Qtotal;
      types       <- capgraph$types;
      abstypes    <- capgraph$abstypes;
   } else {
      datetime    <- capgraph$datetime[index];
      h1          <-       capgraph$h1[index];
      h4          <-       capgraph$h4[index];
      total.flows <-   capgraph$Qtotal[index];
      types       <-    capgraph$types[index];
      abstypes    <- capgraph$abstypes[index];
   }

   if(! is.null(plotfile)) ask <- FALSE;

   ifelse(is.null(datetime), my.xlab <- "TIME INDEX", my.xlab <- "TIME");
   if(! is.null(plotfile)) pdf(plotfile);
   ifelse(culvert$flowunits == "cubic feet per second",
          my.qunits <- ", IN FEET^3/SECOND",
          my.qunits <- ", IN METER^3/SECOND");
   my.ylab <- paste(c("DISCHARGE", my.qunits), sep="", collapse="");

   my.ymin <- 0.01;
   my.ymax <- 0.02;

   #catme("my.flows",total.flows);
   my.flows <- total.flows[! is.na(total.flows)];
   #catme("my.flows",my.flows);
   if(length(my.flows) != 0) {
      my.ymin <- min(my.flows[my.flows >= 0]);
      my.ymax <- max(my.flows);
   }
   #catme("ymin:",my.ymin);
   #catme("ymax:",my.ymax);
   #catme("xmin:", datetime[1]);
   my.ymin <- 10^( log10(my.ymin) - 0.05);
   my.ymax <- 10^( log10(my.ymax) + 0.05);

   plot(datetime, total.flows, type="l",
        ylim=c(my.ymin, my.ymax),
        xlab=my.xlab, ylab=my.ylab, tcl=0.5);
   legend(datetime[1],
          my.ymax, c("USGS type 1 flow", "USGS type 2 flow",
                     "USGS type 3 flow", "USGS type 4 flow",
                     "USGS type 5 flow", "USGS type 6 flow",
                     "USGS 2-sec SAC flow"),
          pch=16, col=c(1:6,8), cex=1, bty="n", pt.cex=0.75);
   for(i in 1:length(datetime)) {
     if(showtype)   points(datetime[i],total.flows[i],
                           col=abstypes[i], pch=atypes[types[i]]);
     if(showpoints) points(datetime[i],total.flows[i],
                           col=abstypes[i], pch=16, cex=1);
   }

   ifelse(culvert$lengthunits == "feet",
          my.lunits <- ", IN FEET",
          my.lunits <- ", IN METERS");
   my.ylab <- paste(c("HEAD- AND TAIL-WATER GAGE HEIGHT", my.lunits),
                    sep="", collapse="");
   if(ask) readline("Hit <Return> to see gage-height plot ");
   plot(c(datetime[1], datetime[length(datetime)]),
        c(minh, max(h1,h4)),
        xlab=my.xlab, ylab=my.ylab, type="n", tcl=0.5);
   lines(datetime, h1);
   lines(datetime, h4, col=2);
   if(! is.null(plotfile)) dev.off();
   if(ask) readline("Hit <Return> to continue ");
}


"write.capgraph" <-
function(capgraph, culvert=NULL, approach=NULL,
         index=NULL, sep=",", ...) {
   if(is.null(culvert) || ! is.h(culvert)) {
     stop("culvert is NULL or not a culvert hash");
   }
   if(is.null(approach) || ! is.h(approach)) {
     stop("approach is NULL or not an approach hash");
   }

   # double && needed to ensure that both are evaluated
   if(is.h(approach) && has.key("time.series.out", approach)) {
      outfile <- get.h("time.series.out", approach);
   }
   if(is.null(outfile)) outfile <- "";

   if(length(index) == 1) {
      index <- c(index, length(capgraph$ix));
   }
   if(! is.null(index)) {
      capgraph <- as.list(as.data.frame(capgraph)[index,]);
   }

   write.table(capgraph, file=outfile, sep=sep,
               quote=FALSE,
               row.names=FALSE, ...);
}



"demo.capgraph" <-
function(road=TRUE, ...) {
  US <- c(1,   1.5, 4, 5,   5,   6,   7, 9, 12, 14, 6, 7, 4, 3.5, 3.5,   2, 1);
  DS <- c(0.5, 1.1, 2, 2, 2.5, 2.3, 4.5, 5,  3,  5, 2, 1, 3, 2.5, 2.2, 0.5, 0.7);

  X <- c(0, 200, 230, 430);
  Y <- c(100, 0,   0, 100);
  my.approach <- setApproach(X=X, Y=Y);

  bvals <- c(8.5, 9, 10, 12, 15);
  elevs <- sapply(bvals, function(x) { return((x - 8.5)^2) });
  if(road) {
    my.road <- setRoad(crown.elev=8.5, road.width=50,
                       crest.lengths=data.frame(b=bvals, elev=elevs));
  } else {
    my.road <- NULL;
  }
  my.culvert <- setCulvert(type="circle",
                           material="concrete",
                           diameter=4,
                           rounding=0.008,
                           nvalue=0.015,
                           L=80,
                           slope=0.001,
                           road=my.road);

  flows <- capgraph(h1=US, h4=DS, culvert=my.culvert,
                    approach=my.approach, ...);
  plot.capgraph(flows, culvert=my.culvert);
  write.capgraph(flows, culvert=my.culvert, approach=my.approach);
}



"capgraphSystem" <-
function(h1=NULL, h4=NULL, datetime=NULL, culverts=NULL, approach=NULL,
         silent=TRUE, unlink=FALSE, showprogress=TRUE,
         savefile="TMP4capR_capgraph.RData",
         forceEqualApproachHead=NULL,
         forceIgnoreApproachHead=NULL) {

   n  <- length(h1); IX <- 1:n;
   if(n != length(h4)) {
      stop("\n*** headwater and tailwater vectors not of equal length ***");
   }

   if(is.null(datetime)) datetime <- 1:n;
   cache.h <- new.h();

   total.flows <- vector(mode="numeric");

   counter <- 0;
   if(showprogress) {
         catme(c("Processing", length(h1),
                 "values ('*' means from dynamic cache)..."));
   }
   for(i in IX) {
      if(showprogress) message(c(i), appendLF=FALSE);
      US.depth <- h1[i]; DS.depth <- h4[i];
      key <- paste(c(US.depth,":",DS.depth), sep="", collapse="");
      if(has.key(key, cache.h)) {
         cat(c("* "));
         computed.flow <- get.h(key, cache.h);
      } else {
         cat(c("  "));
         computed.flow <- computeFlowSystem(culverts=culverts, approach=approach,
                                      h1=US.depth, h4=DS.depth, silent=silent,
                                      verbose=TRUE, plotapproach=FALSE,
                                      forceEqualApproachHead=forceEqualApproachHead,
                                      forceIgnoreApproachHead=forceIgnoreApproachHead);
      }
      if(! is.list(computed.flow)) {
         the.Qtotal <- NA;
      } else {
         the.Qtotal   <- computed.flow$Qtotal;
         if(is.nan(the.Qtotal) | is.na(the.Qtotal)) the.Qtotal <- NA;
      }
      total.flows[i]   <- the.Qtotal;
      set.h(key, computed.flow, cache.h);
   }
   if(showprogress) catme("\n");
   capgraph.RData <- list(ix=IX,
                          datetime=datetime,
                          h1=h1, h4=h4,
                          Qtotal=total.flows);
   if(unlink) {
      message("Unlinking the savefile");
      try(unlink(savefile));
   }
   if(! file.exists(savefile)) {
      message("The savefile does not exist, testing whether to create one");
      if(! is.na(savefile)) {
        message(paste(c("savefile= ",savefile," now being written"),
                      collapse=""));
        try(save(capgraph.RData, file=savefile));
      } else {
        message("savefile=NA, so it was not written");
      }
   }
   return(capgraph.RData);
}


################################################################
##    capR Source File ./Hydraulics/FlowTypes/computeFlow.R
################################################################
"computeFlow.deforceEqualApproachHead" <-
function(...) {
   computeFlow(forceEqualApproachHead=FALSE, ...)
}
"computeFlow.forceIgnoreApproachHead" <-
function(...) {
   computeFlow(forceIgnoreApproachHead=TRUE, ...)
}


"computeFlow" <-
function(culvert=NULL, approach=NULL, h1=NULL, h4=NULL,
         justQ=FALSE, verbose=FALSE, silent=FALSE,
         plotapproach=TRUE, reset=TRUE, ignore.early.out=FALSE,
         datetime="not provided",
         forceEqualApproachHead=NULL,
         forceIgnoreApproachHead=NULL, ...) {

  if(length(h1) > 1 || length(h4) > 1 || length(datetime) > 1) {
     warning("multiple h1 or h4 or datetime provided, using only the first values");
     h1 <- h1[1];
     h4 <- h4[1];
     datetime <- datetime[1];
  }

  if(silent) verbose <- FALSE;
  if(! silent & ! justQ) capRheader(approach=approach);

  options(device.ask.default=FALSE);

  early.out <- FALSE;
  if(! is.null(culvert$min.recordable.hw) &&
         h1 <= culvert$min.recordable.hw) {
     if(verbose) catme("\n*** h1 is at or below minimum recordable",
                        "headwater elevation, returning NA ***");
     early.out <- TRUE;
  }
  if(h1 == h4) {
     if(verbose) catme("\n*** h4 is equal to h1, returning NA ***");
     early.out <- TRUE;
  }
  if(h1 < h4) {
     if(verbose) catme("\n*** h4 is larger than h1, returning NA ***");
     early.out <- TRUE;
  }
  if(culvert$z >= h1 - culvert$zdsinvert) {
     if(verbose) catme("\n*** z is larger than h1, returning NA ***");
     early.out <- TRUE;
  }
  if(! ignore.early.out && early.out) {
     set.h("TMP.Q.previous.run", 0,             culvert);
     set.h("TMP.Qroad.previous.run", 0,         culvert);
     set.h("TMP.terminal.area.previous.run", 0, culvert);
     set.h("TMP.konvey2.previous.run", 0,       culvert);
     return(NA);
  }


  # It is critical that these original settings be preserved
  # in the case the the h1 <= approach$min.elevation conditions triggers
  # because we will need to modify the culvert and approach object on the
  # fly. Note that we must not modify the recorded approach$min.elevation.
  original.ignore.hf12   <- culvert$ignore.approach.losses;
  original.ignore.v1head <- culvert$ignore.approach.velocity.head;
  original.XY <- approach$xsec;
  original.forceEqualApproachHead <- approach$forceEqualApproachHead;
  original.forceIgnoreApproachHead <- approach$forceIgnoreApproachHead;
  if(! is.null(forceEqualApproachHead)) {
     approach$forceEqualApproachHead <- forceEqualApproachHead;
  }
  if(! is.null(forceIgnoreApproachHead)) {
     approach$forceIgnoreApproachHead <- forceIgnoreApproachHead;
  }

  if(h1 <= approach$min.elevation) {
     if(verbose) catme("\n*** h1 is at or below minimum elevation of",
                        "approach. ***");
     warning("h1 is at or below minimum elevation of approach. ",
             "The culvert is now being configured to ignore.approach.losses ",
             "and ignore.approach.velocity.head. In order to continue ",
             "processing, the XY of the approach is being modified so that ",
             "the minimum(Y) is set equal to 'just below' h1 or 'h1 - 0.001'. ",
             "This has the effect of keeping alive the approach geometry ",
             "subroutines, but the properties of the approach are ignored. ",
             "Expect to see extremely high to implausible Froude numbers in ",
             "output, ignore the output. Effectively 'ponded' conditions at ",
             "the inlet are assumed.");

     # These two truths have the effect of complete disregard for the approach
     # but geometry modification of the approach is needed to have approach
     # geometry functions continue to populate various fields
     culvert$ignore.approach.losses <- TRUE;
     culvert$ignore.approach.velocity.head <- TRUE;

     X <- approach$xsec$X; # extract the horizontal positions
     Y <- approach$xsec$Y; # extract the elevations
     ix <- 1:length(X); # vector of indices
     ix.min <- ix[Y == min(Y)]; # which indices are at the minimum
     Y[ix.min] <- h1 - 0.001; # reset those mins to just below h1
     approach$xsec <- data.frame(X=X, Y=Y); # repopulate
  }

  if(culvert$manningcor != approach$manningcor) {
     stop("Manning correction (1.486 | 1) mismatch in ",
          "approach and culvert objects");
  }

  if(reset) {
    resetTMPvarsApproach(approach);
    resetTMPvarsCulvert(culvert);
  }

  setApproachConditions(depth=h1, approach=approach,
                        plotem=plotapproach, ...);

  types <- TypeClassification(h1=h1, h4=h4, culvert=culvert, verbose=verbose);
  if(verbose) {
    catme("  Potential USGS flow types from TypeClassification():", types);
  }

  Qs <- Qroads <- TYPEs <- As <- Ks <- vector(mode="numeric");
  flows.h <- new.h();
  valid.Q.count <- 0;

  for(type in types) {
     if(verbose) catme("processing flow type", type);

     flow <- switch(type,
          culvert2QType1(h1=h1, h4=h4,
                         culvert=culvert, approach=approach),
          culvert2QType2(h1=h1, h4=h4,
                         culvert=culvert, approach=approach),
          culvert2QType3(h1=h1, h4=h4,
                         culvert=culvert, approach=approach),
          culvert2QType4(h1=h1, h4=h4,
                         culvert=culvert, approach=approach),
          culvert2QType5(h1=h1, h4=h4,
                         culvert=culvert, approach=approach),
          culvert2QType6(h1=h1, h4=h4,
                         culvert=culvert, approach=approach));

     culvert$Ltop <- culvert$TMP.Ltop;
     culvert$Lbot <- culvert$TMP.Lbot;
     culvert$zdsinvert <- culvert$TMP.zdsinvert;

     the.type <- type;
     if(type <= 3) {
        if(! is.na(flow$had.to.ignore.v1head.and.h12) &
                   flow$had.to.ignore.v1head.and.h12 == TRUE) {
           the.type <- -the.type;
        }
     }

     set.h(paste(c("type",the.type), sep="", collapse=""), flow, flows.h);

     if(verbose) print(flow);

     if(flow$valid) {
        valid.Q.count  <- valid.Q.count + 1;
        Qculvert <- flow$Q; # extract the culvert flow
        Qroad <- 0;
        if(length(flow$roadflow$is.flow) && flow$roadflow$is.flow) {
           Qroad <- flow$roadflow$Qroad;
        }
        Qs[valid.Q.count]     <- Qculvert;
        Qroads[valid.Q.count] <- Qroad;
        TYPEs[valid.Q.count]  <- the.type;
        As[valid.Q.count]     <- flow$terminalarea;
        Ks[valid.Q.count]     <- flow$konvey2;
        if(! silent) {
           if(justQ) {
              catme(h1, h4, Qculvert, type, Qroad, Qculvert+Qroad, type,
                    sep="  ");
           } else {
              printFlow(type, h1=h1, h4=h4, flow=flow, datetime=datetime,
                        culvert=culvert, approach=approach);
           }
        }
     }
  }

  if(valid.Q.count == 0) { # emergency 2-section slope area
     type <- "SAC";
     flow <- culvert2QTypeSAC(h1=h1, h4=h4, culvert=culvert, approach=approach);
     Qculvert <- flow$Q;
     Qroad <- 0;
     if(length(flow$roadflow$is.flow) && flow$roadflow$is.flow) {
       Qroad <- flow$roadflow$Qroad;
       Qculvert <- 0;
     }
     Qs[1]     <- Qculvert;
     Qroads[1] <- Qroad;
     TYPEs[1]  <- type;
     As[1]     <- flow$terminalarea;
     Ks[1]     <- flow$konvey2;
     if(! silent) {
        if(justQ) {
           catme(h1, h4, Qculvert, type, Qroad, Qculvert+Qroad, type,
                 sep="  ");
        } else {
           printFlow("SAC", h1=h1, h4=h4, flow=flow,
                     culvert=culvert, approach=approach);
        }
     }
  }

  if(verbose & valid.Q.count > 1) {
     catme("\n*** Two or more Q are valid",
           "returning mean of those found. ***\n");
  }
  if(length(Qs) == 0) {
     Qs <- Qroads <- As <- Ks <- c(NA);
     # used to trap min(), max() error messages
  }
  Qbar     <- mean(Qs,     na.rm=TRUE);
  Qroadbar <- mean(Qroads, na.rm=TRUE);
  Abar     <- mean(As,     na.rm=TRUE);
  Kbar     <- mean(Ks,     na.rm=TRUE);

  if(is.nan(Qbar))         Qbar <- 0;
  if(is.nan(Qroadbar)) Qroadbar <- 0;
  if(is.nan(Abar))         Abar <- 0;
  if(is.nan(Kbar))         Kbar <- 0;
  set.h("TMP.Q.previous.run",             Qbar,     culvert);
  set.h("TMP.Qroad.previous.run",         Qroadbar, culvert);
  set.h("TMP.terminal.area.previous.run", Abar,     culvert);
  set.h("TMP.konvey2.previous.run",       Kbar,     culvert);

  # Restore original values (rarely would these actually change)
  culvert$ignore.approach.losses <- original.ignore.hf12;
  culvert$ignore.approach.velocity.head <- original.ignore.v1head;
  approach$xsec <- original.XY;
  approach$forceEqualApproachHead <- original.forceEqualApproachHead;
  approach$forceIgnoreApproachHead <- original.forceIgnoreApproachHead;

  return(list(h1=h1, h4=h4,
              Qtotal=Qbar+Qroadbar,
              Qculvert=Qbar,
              Qroad=Qroadbar,
              Qmin=min(Qs),
              Qmax=max(Qs),
              Qsd=sd(Qs),
              Qs=Qs,
              A=Abar,
              K=Kbar,
              Types=TYPEs,
              type=TYPEs[1],
              flow.hash=flows.h));
}



################################################################
##    capR Source File ./Hydraulics/FlowTypes/computeFlowSystem.R
################################################################
"computeFlowSystem.singlepass" <-
function(culverts=NULL, approach=NULL, h1=NULL, h4=NULL,
         reset=TRUE, show.pass.results=TRUE,
         digits=4, ...) {

  if(! is.h(culverts)) {
     stop("Need hash of culverts to process");
  }

  keys <- keys.h(culverts);
  n.culverts <- length(keys);
  if(n.culverts < 1) {
     stop("*** Processing no culverts ***");
     return(NA);
  }

  if(reset) {
    resetTMPvarsApproach(approach);
    for(culvert.key in keys) {
       the.culvert <- get.h(culvert.key, culverts);
       the.culvert$TMP.key <- culvert.key;
       resetTMPvarsCulvert(the.culvert);
    }
  }

  Qs <- As <- Ks <- vector(mode="numeric", length=n.culverts);
  counter <- 0;

  if(show.pass.results) {
     cat("           **** Interating culvert key: ");
  }
  for(culvert.key in keys) {
     counter <- counter + 1;
     if(show.pass.results) {
        cat(culvert.key); cat(", ");
     }
     the.culvert <- get.h(culvert.key, culverts);
     flow <- computeFlow(h1=h1, h4=h4, culvert=the.culvert, reset=FALSE,
                         approach=approach, ...);
  }
  if(show.pass.results) {
       cat("**** \n");
  }

  i <- 0;
  for(culvert.key in keys) {
     i <- i + 1;
     the.culvert <- get.h(culvert.key, culverts);
     Qs[i] <- the.culvert$TMP.Q.previous.run +
              the.culvert$TMP.Qroad.previous.run;
     As[i] <- the.culvert$TMP.terminal.area.previous.run;
     Ks[i] <- the.culvert$TMP.konvey2.previous.run;
  }

  approach$TMP.accumulated.flow <- approach$additional.flow +
                                   sum(Qs, na.rm=TRUE);
  approach$TMP.terminal.area.previous.run <- sum(As, na.rm=TRUE);
  approach$TMP.konvey2.previous.run <- sum(Ks, na.rm=TRUE);

  a.culvert <- get.h(keys[1], culverts);
  lunits <- a.culvert$lengthunits;
  qunits <- a.culvert$flowunits;
  aunits <- a.culvert$areaunits;

  Q   <- approach$TMP.accumulated.flow;
  geo <- approach$geometry;
  A   <- geo$AREATOTAL;
  TW  <- geo$DBAR;
  g   <- a.culvert$gravity;
  F   <- Froude(discharge=Q, area=A, topwidth=TW, alpha=geo$alpha, g=g);
  F   <- round(F, digits=digits);
  ratio <- A/approach$TMP.terminal.area.previous.run;
  ratio <- round(ratio, digits=digits);
  if(show.pass.results) {
    catme("Discharge =",round(Q, digits=digits),
          "with Froude in approach of",F);
    catme("Ratio of areas (approach/'terminal area of culvert flow')",
          ratio);
  }

  z <- list(Qtotal=Q,
            qunits=qunits,
            froude.in.approach=F,
            contraction.ratio=ratio);
  return(z);
}


"computeFlowSystem.deforceEqualApproachHead" <-
function(...) {
   computeFlowSystem(forceEqualApproachHead=FALSE, ...)
}
"computeFlowSystem.forceIgnoreApproachHead" <-
function(...) {
   computeFlowSystem(forceIgnoreApproachHead=TRUE, ...)
}



"computeFlowSystem" <-
function(maxits=10, eps=1e-6, digits=4, show.pass.results=FALSE,
         forceEqualApproachHead=NULL, forceIgnoreApproachHead=NULL, ...) {

  flow <- computeFlowSystem.singlepass(reset=TRUE,
                                       show.pass.results=show.pass.results,
                                       forceEqualApproachHead=forceEqualApproachHead,
                                       forceIgnoreApproachHead=forceIgnoreApproachHead,
                                       ...);
  Q.old <- flow$Qtotal;
  its <- 0;
  error <- NA;
  if(Q.old == 0) {
    return(list(Qtotal=Q.old,
                error=error,
                iterations=its,
                flow.units=flow$qunits));
  }
  while(1) {
    its <- its + 1;
    flow <- computeFlowSystem.singlepass(reset=FALSE,
                                         show.pass.results=show.pass.results,
                                         forceEqualApproachHead=forceEqualApproachHead,
                                         forceIgnoreApproachHead=forceIgnoreApproachHead,
                                         ...);
    Q <- flow$Qtotal;
    error <- abs(Q-Q.old);
    if(abs(error/Q.old) < eps | its > maxits) break;
    Q.old <- Q;
  }
  #catme("TOTAL DISCHARGE: ", round(Q.old, digits=digits), flow$qunits);
  return(list(Qtotal=Q.old,
              error=error,
              its=its,
              flow.units=flow$qunits));
}






################################################################
##    capR Source File ./Hydraulics/FlowTypes/getPerfCurves.R
################################################################
"getPerfTW" <-
function(HW, TW=NULL, culvert=NULL, approach=NULL, ...) {

  if(is.null(TW)) TW <- 0;

  Qs <- rep("NA", length(HW));
  Qs.max <- Qs.min <- Qs;
  for(i in 1:length(HW)) {
    flow <- computeFlow(culvert=culvert,
                        approach=approach,
                        h1=HW[i],
                        h4=TW, ...);
    if(length(flow) == 1 && is.na(flow)) {
      Qs[i] <- Qs.max[i] <- Qs.min[i] <- NA;
    } else {
      Qs[i]     <- flow$Qtotal;
      Qs.max[i] <- flow$Qmax;
      Qs.min[i] <- flow$Qmin;
    }
  }
  return(list(HW=as.numeric(HW),
              TW=as.numeric(TW),
              Qmean=as.numeric(Qs),
              Qmin=as.numeric(Qs.min),
              Qmax=as.numeric(Qs.max)));
}


"getPerfHW" <-
function(TW, HW=NULL, culvert=NULL, approach=NULL, ...) {

  if(is.null(HW)) HW <- culvert$z;

  Qs <- rep("NA", length(TW));
  Qs.max <- Qs.min <- Qs;
  for(i in 1:length(TW)) {
    flow <- computeFlow(culvert=culvert,
                        approach=approach,
                        h1=HW,
                        h4=TW[i], ...);
    if(length(flow) == 1 && is.na(flow)) {
      Qs[i] <- Qs.max[i] <- Qs.min[i] <- NA;
    } else {
      Qs[i]     <- flow$Qtotal;
      Qs.max[i] <- flow$Qmax;
      Qs.min[i] <- flow$Qmin;
    }
  }
  return(list(TW=as.numeric(TW),
              HW=as.numeric(HW),
              Qmean=as.numeric(Qs),
              Qmin=as.numeric(Qs.min),
              Qmax=as.numeric(Qs.max)));
}


"getPerfTWtable" <-
function(HW, TW=NULL, culvert=NULL, approach=NULL, ...) {

  if(is.null(TW)) {
     stop("Tailwater table (a data.frame with TW and Q columns) is NULL");
  }

  Qs <- rep("NA", length(HW));
  TWs <- Qs.max <- Qs.min <- Qs;
  previous.flow <- 0; # origin of flow
  previous.TW <- approx(TW$Q, y=TW$TW, xout=previous.flow, rule=2)$y;
  for(i in 1:length(HW)) {
    if(previous.TW >= HW[i]) next;
    flow <- computeFlow(culvert=culvert,
                         approach=approach,
                         h1=HW[i],
                         h4=previous.TW, ...);
    if(length(flow) == 1 && is.na(flow)) {
      Qs[i] <- Qs.max[i] <- Qs.min[i] <- NA;
    } else {
      Qs[i]     <- flow$Qtotal;
      Qs.max[i] <- flow$Qmax;
      Qs.min[i] <- flow$Qmin;
      TWs[i]    <- previous.TW;
    }
    previous.TW <- approx(TW$Q, y=TW$TW, xout=Qs[i], rule=2)$y;
  }
  return(list(HW=as.numeric(HW),
              TW=as.numeric(TWs),
              Qmean=as.numeric(Qs),
              Qmin=as.numeric(Qs.min),
              Qmax=as.numeric(Qs.max)));
}



"getPerfHWtable" <-
function(TW, HW=NULL, culvert=NULL, approach=NULL, ...) {

  if(is.null(HW)) {
     stop("Headwater table (a data.frame with HW and Q columns) is NULL");
  }

  Qs <- rep("NA", length(TW));
  HWs <- Qs.max <- Qs.min <- Qs;
  previous.flow <- 0; # origin of flow
  previous.HW <- approx(HW$Q, y=HW$HW, xout=previous.flow, rule=2)$y;
  for(i in 1:length(TW)) {
    if(previous.HW >= TW[i]) next;
    flow <- computeFlow(culvert=culvert,
                         approach=approach,
                         h1=previous.HW,
                         h4=HW[i], ...);
    if(length(flow) == 1 && is.na(flow)) {
      Qs[i] <- Qs.max[i] <- Qs.min[i] <- NA;
    } else {
      Qs[i]     <- flow$Qtotal;
      Qs.max[i] <- flow$Qmax;
      Qs.min[i] <- flow$Qmin;
      HWs[i]    <- previous.HW;
    }
    previous.HW <- approx(HW$Q, y=HW$HW, xout=Qs[i], rule=2)$y;
  }
  return(list(TW=as.numeric(TW),
              HW=as.numeric(HWs),
              Qmean=as.numeric(Qs),
              Qmin=as.numeric(Qs.min),
              Qmax=as.numeric(Qs.max)));
}


#################################################################
"getPerfTW.FlowSystem" <-
function(HW, TW=NULL, culverts=NULL, approach=NULL,
         showperf=FALSE, monotonic=TRUE, ...) {

  if(is.null(TW)) TW <- 0;

  Qs <- rep(NA, length(HW));
  Qs.max <- Qs.min <- deltaQs <- Qs;
  for(i in 1:length(HW)) {
    flow <- computeFlowSystem(culvert=culverts,
                              approach=approach,
                              h1=HW[i],
                              h4=TW, ...);
    Q <- flow$Qtotal;
    Qs[i] <- Q;
    ifelse(i == 1, deltaQ <- 0, deltaQ <- Q - Qs[i-1]);
    deltaQs[i] <- deltaQ;
    if(showperf) {
      catme(HW[i],TW,Q,round(deltaQ, digits=3));
    }
  }
  if(monotonic) {
     HW <- HW[deltaQs >= 0];
     Qs <- Qs[deltaQs >= 0];
  }
  return(list(HW=as.numeric(HW),
              TW=as.numeric(TW),
              Qmean=as.numeric(Qs)
             ));
}


"getPerfHW.FlowSystem" <-
function(TW, HW=NULL, culverts=NULL, approach=NULL,
         showperf=FALSE, monotonic=TRUE, ...) {

  if(is.null(HW)) HW <- culvert$z;

  Qs <- rep(NA, length(TW));
  Qs.max <- Qs.min <- deltaQs <- Qs;
  for(i in 1:length(TW)) {
    flow <- computeFlowSystem(culvert=culverts,
                              approach=approach,
                              h1=HW,
                              h4=TW[i], ...);
    Q <- flow$Qtotal;
    Qs[i] <- Q;
    ifelse(i == 1, deltaQ <- 0, deltaQ <- Q - Qs[i-1]);
    deltaQs[i] <- deltaQ;
    if(showperf) {
       catme(HW,TW[i],Q,round(deltaQ, digits=3));
    }
  }
  if(monotonic) {
     TW <- TW[deltaQs >= 0];
     Qs <- Qs[deltaQs >= 0];
  }
  return(list(HW=as.numeric(HW),
              TW=as.numeric(TW),
              Qmean=as.numeric(Qs)
             ));
}


################################################################
##    capR Source File ./Hydraulics/FlowTypes/piezoLevelRatioType6.R
################################################################
"piezoLevelRatioType6" <-
function(discharge=NULL, culvert=NULL,
         supportedjet=FALSE) { # FROM culvertd.for of FEQ
   g    <- culvert$gravity;
   D    <- culvert$diameter;
   Ao   <- culvert$Ao.inlet;
   type <- culvert$type;
  
   if(g > 15) { # OK IN ENGLISH
     a.factor <- 1;
   } else { # NOPE IN SI
      a.factor <- 1.81128; # 3.2808^3/(3.2808^(5/2));
   }
   
   if(type == "box") { # ratio is dimensionless **NO* correction (see below)
     RAT <- discharge/(Ao*sqrt(g*D));
     if(RAT < 1) {
        return(1.0 - 0.2*RAT);
     } else if(RAT < 5.0) {
        return(0.875 - 0.075*RAT);
     } else {
        return(0.5);
     }
   }

   # ALL OTHER CLASSES TREATED LIKE A PIPE CULVERT
   # ESTIMATE THE EQUIVALENT NUMBER OF PIPES OF DIAMETER D
   # TO ADJUST THE FLOW RATE
   NE <- 4*Ao/(pi*D^2);
   QE <- discharge/NE;
   RAT <- a.factor*QE/D^(5/2); # Figure 18 of TWRI **NOT** dimensionless
   # in the horizontal axis--therefore, use a correction
   
   if(RAT < 1.0) RAT <- 1.0;
 
   if(supportedjet) { # Discharge is supported.
      if(RAT <= 2.0) {
         return(1.0 - 0.1*(RAT - 1.0));
      } else if(RAT <= 3.0) {
         return(1.01 - 0.055*RAT);
      } else if(RAT <= 4.0) {
         return(1.061 - 0.0720*RAT);
      } else if(RAT <= 5.0) {
         return(1.129 - 0.089*RAT);
      } else if(RAT <= 6.0) {
         return(0.899 - 0.043*RAT);
      } else if(RAT <= 7.0) {
         return(0.797 - 0.026*RAT);
      } else if(RAT <= 8.0) {
         return(0.72 - 0.0152364*RAT);
      } else {
         return(0.5 + 0.52788/RAT^0.80925);
      }
   } else { # Discharge is unsupported.
      if(RAT <= 2.0) {
         return(1.058 - 0.058*RAT);
      } else if(RAT <= 3.0) {
         return(1.056 - 0.057*RAT);
      } else if(RAT <= 4.0) {
         return(1.188 - 0.101*RAT);
      } else if(RAT <= 5.0) {
         return(1.240 - 0.114*RAT);
      } else if(RAT <= 6.0) {
         return(0.940 - 0.054*RAT);
      } else if(RAT <= 7.0) {
         return(0.808 - 0.032*RAT);
      } else if(RAT <= 8.0) {
         return(0.85 - 0.038*RAT);
      } else {
        return(0.5 + 1.560/RAT^1.546);
      }
   }
}





################################################################
##    capR Source File ./Hydraulics/FlowTypes/Qroadway.R
################################################################
"setRoad" <-
function(crown.elev=NULL,
         surface.type=c("paved", "gravel"),
         road.width=NULL,
         crest.lengths=data.frame(b=c(0,0), elev=c(0,0)),
         crest.length.reduction.per.unit.length=0) {

  surface.type <- match.arg(surface.type);

  if(is.null(road.width)) {
     stop("road.width is NULL");
  }

  if(is.null(crown.elev)) {
     stop("crown.elev is NULL");
  }

  if(! is.data.frame(crest.lengths)) {
     stop("a data frame of crest.lengths is not a data frame");
  } else {
     the.names <- names(crest.lengths);
     is.b    <- as.logical(length(grep('b', the.names)));
     is.elev <- as.logical(length(grep('elev', the.names)));
     if(! is.b)    stop("crest.length data frame needs a column named 'b'");
     if(! is.elev) stop("crest.length data frame needs a column named 'elev'");
  }

  tmp.h <- new.h();
  set.h("crown.elev",       crown.elev,  tmp.h);
  set.h("surface.type",   surface.type,  tmp.h);
  set.h("road.width",       road.width,  tmp.h);
  set.h("crest.lengths", crest.lengths,  tmp.h);
  set.h("crest.length.reduction.per.unit.length", crest.length.reduction.per.unit.length, tmp.h);
  return(tmp.h);
}


"Qroad" <-
function(h1=NULL, h4=NULL, v1head=0, road=NULL) {

  if(! is.h(road)) {
     return(list(Qroad=0, coes=NA, road.width=NA, crest.length=NA,
            H=NA, h=NA, ht=NA, is.flow=FALSE));
  }

  h  <- h1 - road$crown.elev;
  ht <- h4 - road$crown.elev;

  if(ht > h) {
    stop("*** ht > h after offsetting by crown elevation, flow would be backwards ***");
  }

  if(h <= 0) {
     return(list(Qroad=0, coes=NA, road.width=NA, crest.length=NA,
            H=NA, h=NA, ht=NA, is.flow=FALSE));
  }


  L <- road$road.width;
  surface.type <- road$surface.type;

  H <- h + v1head; # velocity head correction added

  if(is.null(road$crest.lengths)) {
    b <- 0.83333*H; # (5/6)*H, TWRI B3ChA5 p.26
  } else {
    # Note that we must use elevation in the table (h1) and *not* h
    b <- approx(road$crest.lengths$elev,
                y=road$crest.lengths$b, h1, rule=2)$y;
  }
  b <- b - b*road$crest.length.reduction.per.unit.length
  discharge.coefficients <- Croad(h=h, H=H, L=L, ht=ht, type=surface.type);

  Q <- discharge.coefficients$Croad*b*H^(3/2);

  return(list(Qroad=Q, coes=discharge.coefficients,
              road.width=L, crest.length=b,
              H=H, h=h, ht=ht, is.flow=TRUE));
}
# TWRI B3ChA5 p.26



"printRoadFlow" <-
function(roadflow, culvert=NULL, splash=TRUE) {

   lunits <- culvert$lengthunits;
   qunits <- culvert$flowunits;

   coes <- roadflow$coes;
   if(splash) splashbars();
   catme("FLOW OVER ROAD SUMMARY");
   catme("   Flow over road that is", round(roadflow$road.width), lunits,
        "wide is", round(roadflow$Qroad, digits=0), qunits);
   if(roadflow$is.flow) {
      catme("   with a weir coefficient of", round(coes$Croad, digits=3),
            "and a weir crest length of",
                          round(roadflow$crest.length, digits=2), lunits);
      catme("   Total head is", round(roadflow$H, digits=3), lunits,
            "with a hydraulic head of", round(roadflow$h, digits=3), lunits,
            "and a ht head of", round(roadflow$ht, digits=3), lunits);
   }
}





################################################################
##    capR Source File ./Hydraulics/FlowTypes/Qslopearea.R
################################################################
"Qslopearea2sec" <-
function(delh=0, L=NULL, A1=NULL, A2=NULL, K1=NULL, K2=NULL,
         alpha1=1, alpha2=1, g=NULL, treatexpansion=FALSE) {

      g2 <- 2*g;
  v1head <- 0;
  v2head <- 0;
       k <- 0;

     KoK <- K2/K1;
   KKoAA <- K2^2/(2*g*A2^2);
   AAoAA <- (A2/A1)^2;
   denom <- KoK*L + KKoAA*(-alpha1*AAoAA*(1-k) + alpha2*(1-k));
   Q1 <- K2*sqrt(delh/denom);
   
   v1head <- (Q1/A1)^2/g2;
   v2head <- (Q1/A2)^2/g2;
   if(treatexpansion) k <- ifelse(v1head - v2head > 0, 0.5, 0);

   delh2  <- delh + v1head - v2head;
   denom <- KoK*L + KKoAA*(-alpha1*AAoAA*(1-k) + alpha2*(1-k));
   Q2 <- K2*sqrt(delh2/denom);

  Q <- list(Q=Q2,  Q.no.velheads=Q1, delh=delh2, delh.no.velheads=delh);
  return(Q);
}


"culvert2QTypeSAC" <-
function(h1=NULL, h4=NULL, culvert=NULL, approach=NULL, digits=4) {

  h1.elev <- h1; h4.elev <- h4;

  h1 <- h1 - culvert$zdsinvert;
  h4 <- h4 - culvert$zdsinvert;
  if(h4 < 0) h4 <- 0;

  g  <- culvert$gravity;
  NB <- culvert$number.of.barrels;
  L   <- culvert$Lbot;

  A1     <- approach$geometry$AREATOTAL/approach$fraction.of.flow;
  alpha1 <- approach$geometry$alpha;
  g2     <- 2*g;  
  
  road <- culvert$road; # properties of the road
  approachflow <- approach$TMP.accumulated.flow; # TOTAL COMPUTED FLOW
  v1head <- alpha1*(approachflow/A1)^2/g2;
  roadflow <- Qroad(h1=h1.elev, h4=h4.elev, v1head=v1head, road=road);

  geo2 <- setCulvertGeometry(depth=h1, culvert=culvert,
                             location="inlet",
                             depression=culvert$inlet.depression);   
  geo3 <- setCulvertGeometry(depth=h4, culvert=culvert,
                             location="outlet",
                             depression=culvert$outlet.depression);
  A2  <- geo2$A;
  A3  <- geo3$A;
  K2  <- geo2$KONVEY;
  K3  <- geo3$KONVEY;

  if(roadflow$Qroad != 0) {
    Q <- list(Q=0,
              d2=h1,
              d3=h4,
              A2=NA,
              A3=NA,
              K2=NA,
              K3=NA,
              g=g,
              L=L,
              sac=NA,
              terminalarea=A2,
              konvey2=K2,
              isTypeSAC=FALSE,
              valid=FALSE,
              roadflow=roadflow,
              message="roadflow involved, but was trying slope-area flow"); 
     return(Q);
  }

  delh <- h1 - h4;
  sac <- Qslopearea2sec(delh=h1-h4, L=L, A1=A2, A2=A3, K1=K2, K2=K3, g=g)
  valid <- ifelse(is.na(sac$Q), FALSE, TRUE);
  
  Q <- list(Q=round(sac$Q*NB, digits=4),
            d2=h1,
            d3=h4,
            A2=A2,
            A3=A3,
            K2=K2,
            K3=K3,
            g=g,
            L=L,
            sac=sac,
            terminalarea=A3,
            isTypeSAC=valid,
            valid=valid,
            roadflow=roadflow,
            message="");
  return(Q);
}




"printTypeSAC" <-
function(flow=NULL, culvert=culvert, approach=approach,
         splash=TRUE, checkvalid=TRUE) {
  if(checkvalid & ! flow$valid) return(NA);

  lunits <- culvert$lengthunits;
  qunits <- culvert$flowunits;
  aunits <- culvert$areaunits;


  h12 <- flow$h12;
  if(is.numeric(h12)) {
     h12 <- paste(c(round(h12, digits=3), " ", lunits), sep="", collapse="");
  }
  v1head <- flow$v1head;
  if(is.numeric(v1head)) {
     v1head <- paste(c(round(v1head, digits=3), " ", lunits),
                     sep="", collapse="");
  }

  catme("  Depth at inlet", round(flow$d2, digits=3),lunits);
  catme("    Area at inlet", round(flow$A2, digits=2),aunits);
  catme("    Conveyance at inlet", round(flow$K2, digits=0),qunits);
  catme("  Depth at outlet", round(flow$d3, digits=3),lunits);
  catme("    Area at outlet", round(flow$A3, digits=2),aunits);
  catme("    Conveyance at outlet", round(flow$K3, digits=0),qunits);
  catme("  Bottom length of culvert", round(flow$L, digits=2),lunits);

  pdffile <- paste(c("TMPcapR_culvert",
                     culvert$TMP.key, "_inletoutlet.pdf"), collapse="");
  pdf(pdffile);
  graphCulvert(discharge=flow$Q, depth=flow$d2,
               culvert=culvert, location="inlet",
               depression=culvert$inlet.depression);
  graphCulvert(discharge=flow$Q, depth=flow$d3,
               culvert=culvert, location="outlet",
               depression=culvert$outlet.depression);
  dev.off();
}








################################################################
##    capR Source File ./Hydraulics/FlowTypes/QType1.R
################################################################
"QType1" <-
function(C=NULL, Ac=NULL, h1=NULL, z=NULL,
         a1=NULL, v1=NULL, dc=NULL, h12=NULL, g=NULL) {
  vh <- a1*v1^2/(2*g);
  return(C*Ac*sqrt(h1 - z + vh - dc - h12));
}

"culvert2QType1" <-
function(h1=NULL, h4=NULL, culvert=NULL, approach=NULL,
         digits=4, maxits=50, eps=1e-6,...) {

  h1.elev <- h1; h4.elev <- h4;

  h1 <- h1 - culvert$zdsinvert;
  h4 <- h4 - culvert$zdsinvert;
  if(h4 < 0) h4 <- 0;

  So     <- culvert$So;
  z      <- culvert$z;
  g      <- culvert$gravity;
  A1     <- approach$geometry$AREATOTAL/approach$fraction.of.flow;
  A1frac <- culvert$fraction.of.approach.area;
  alpha1 <- approach$geometry$alpha;
  g2 <- 2*g;
  hzD <- HeadwtrDiaRatio(h1=h1, culvert=culvert);
  NB <- culvert$number.of.barrels;

  ifelse(culvert$ignore.approach.velocity.head, usev1  <- 0, usev1  <- 1);
  ifelse(culvert$ignore.approach.losses,        useh12 <- 0, useh12 <- 1);

  had.to.ignore.v1head.and.h12 <- NA;

  #geo.guess <- setCulvertGeometry(depth=0.66*(h1-z), culvert=culvert,
  #                                location="inlet",
  #                                depression=culvert$inlet.depression);
  #A.guess <- geo.guess$A; TW.guess <- geo.guess$TW;
  #Q.old <- sqrt(g*A.guess^3/TW.guess);

  Q.old <- getDischargeAtCriticalDepth(depth=0.66*(h1-z),
                                       culvert=culvert,
                                       location="inlet",
                                       depression=culvert$inlet.depression);

  road <- culvert$road; # properties of the road
  approachflow <- approach$TMP.accumulated.flow; # TOTAL COMPUTED FLOW
                                                 # FROM AN EARLIER RUN
  Q.previous.run     <- culvert$TMP.Q.previous.run;
  Qroad.previous.run <- culvert$TMP.Qroad.previous.run;

  # July 11, 2016: The following line seems bogus and causes too much velocity head
  # because approachflow will be summed back into the Qtotal within the iteration loop.
  if(approachflow == 0) {
     #approachflow <- Q.old*NB;
     #Q.previous.run <- approachflow;
  }
  v1head.approach <- usev1*alpha1*(approachflow/A1)^2/g2;
  v1head <- v1head.road <- 0;
  if(approach$forceEqualApproachHead) {
      v1head <- v1head.road <- v1head.approach;
  } else if(approach$forceIgnoreApproachHead) {
      v1head <- v1head.road <- v1head.approach <- 0;
  } else if(approach$useApproachHeadApportioning & approachflow != 0) {
      v1head <- usev1*alpha1*(Q.previous.run/(A1*A1frac))^2/g2;
      v1head.road <- (Qroad.previous.run/approachflow) * v1head.approach;
  } else if(approachflow != 0) {
      v1head      <- (Q.previous.run/approachflow)     * v1head.approach;
      v1head.road <- (Qroad.previous.run/approachflow) * v1head.approach;
  }
  roadflow <- Qroad(h1=h1.elev, h4=h4.elev, v1head=v1head.road, road=road);

  Q <- NULL;
  its <- 0;

  #print(z);
  #print(g);
  #print(A1);
  #print(alpha1);
  #print(Q.old);

  #Qdcrel <- getDischargeCriticalDepthRelation(culvert=culvert);
  #dc.at.minQ <- Qdcrel$dc.at.minQ;
  #minQ.at.dc <- Qdcrel$minQ.at.dc;
  #catme("Qc.dc.rel has minQ:", minQ.at.dc, "dc at minQ", dc.at.minQ);

  So.gt.Sc <- NULL;

  while(1) {
     its <- its + 1;
     #catme("at loop origin Q.old",Q.old," at ",its);
     dc <- getCriticalDepth(Q.old, culvert=culvert, location="inlet",
                            depression=culvert$inlet.depression);

     if(is.na(dc)) {
        Q <- list(Q=NA, error=NA, its=its,
                  C=NA,
                  Ac=NA,
                  h1=h1,
                  z=z,
                  v1head=v1head,
                  H=NA,
                  d2=NA,
                  d3=NA,
                  h12=NA,
                  L=NA,
                  Lw=NA,
                  g=g,
                  terminalarea=NA,
                  konvey2=NA,
                  h4.over.hc=NA,
                  So.lt.Sc=NA,
                  isType1=FALSE,
                  valid=FALSE,
                  roadflow=roadflow,
                  message="could not compute dc, assume not type 1 flow",
                  had.to.ignore.v1head.and.h12=had.to.ignore.v1head.and.h12);
        return(Q);
     }

     geo <- setCulvertGeometry(depth=dc, culvert=culvert, location="inlet",
                               depression=culvert$inlet.depression );
     Ac  <- geo$A;
     TWc <- geo$TW;
     Kc  <- geo$KONVEY;

     # Discharge apportioning of total head amongst the two possible
     # units conveying flow (these culverts and the number of barrels NB)
     # and the optional roadway, only if actually present.
     # Note that approachflow was the TOTAL Q in A1 from last outer iteration
     # of the while(1) loop that this comments are typed in.
     roadQ <- roadflow$Qroad;
     totalQ <- Q.old*NB - Q.previous.run     +
               roadQ    - Qroad.previous.run + approachflow;
     v1head.approach <- usev1*alpha1*(totalQ/A1)^2/g2;
     v1head <- v1head.road <- 0;
     if(approach$forceEqualApproachHead) {
        v1head <- v1head.road <- v1head.approach;
     } else if(approach$forceIgnoreApproachHead) {
        v1head <- v1head.road <- v1head.approach <- 0;
     } else if(approach$useApproachHeadApportioning) {
        v1head <- usev1*alpha1*(Q.old*NB/(A1*A1frac))^2/g2;
        v1head.road <- (roadQ/approachflow) * v1head.approach;
     } else {
        v1head      <- (Q.old*NB/approachflow) * v1head.approach;
        v1head.road <- (roadQ/approachflow)    * v1head.approach;
     }
     roadflow <- Qroad(h1=h1.elev, h4=h4.elev, v1head=v1head.road, road=road);


     lengths <- Lengths4MiteredPipe(h1=h1, flowtype=1,  d2=dc,
                                    culvert=culvert, approach=approach);
     L  <- lengths$L;
     Lw <- lengths$Lw;

     h12 <- useh12*HeadLoss12(Q.old*NB, culvert=culvert,
                              approach=approach, d2=dc, otherL=Lw);
     #cat("h12:", h12);
     H <- h1 - z + v1head - dc - h12;
     #catme("Htype1:",H);
     if(H < 0) {
       usev1  <- 0;
       useh12 <- 0;
       had.to.ignore.v1head.and.h12 <- TRUE;
       H <- h1 - z - dc;
     }
     if(H < 0) {
        Q <- list(Q=NA, error=NA, its=its,
                  C=NA,
                  Ac=NA,
                  Kc=NA,
                  h1=h1,
                  z=z,
                  v1head=v1head,
                  H=H,
                  d2=dc,
                  h12=h12,
                  L=L,
                  Lw=Lw,
                  g=g,
                  terminalarea=NA,
                  konvey2=NA,
                  h4.over.hc=NA,
                  So.gt.Sc=NA,
                  isType1=FALSE,
                  valid=FALSE,
                  roadflow=roadflow,
                  message="H < 0, trapping sqrt(x<0)",
                  had.to.ignore.v1head.and.h12=had.to.ignore.v1head.and.h12);
        return(Q);
     }
     tmp <- sqrt(g2*H);

     C <- getCforType1(culvert=culvert, approach=approach,
                       hzD=hzD, A1=A1, Ac=Ac);
     C <- round(C, digits=digits);

     Q <- C*Ac*tmp;

     Sc <- (Q/Kc)^2;
     ifelse(So > Sc,              So.gt.Sc <- TRUE,   So.gt.Sc <- FALSE);
     ifelse(h4/(dc+z) < 1.0,    h4.over.hc <- TRUE, h4.over.hc <- FALSE);
     ifelse(h4.over.hc & So.gt.Sc, isType1 <- TRUE,    isType1 <- FALSE);

     if(abs(Q-Q.old)/Q.old < eps | its > maxits) break;
     Q.old <- Q;
  }

  ifelse(isType1, valid <- TRUE, valid <- FALSE);

  if(is.na(had.to.ignore.v1head.and.h12)) {
     had.to.ignore.v1head.and.h12 <- FALSE;
  } else {
     h12    <- "had to be ignored.";
     v1head <- "had to be ignored.";
  }

  Q <- list(Q=round(Q*NB, digits=4),
            error=(Q-Q.old)*NB,
            its=its,
            C=C,
            Ac=Ac,
            Kc=Kc,
            h1=h1,
            z=z,
            v1head=v1head,
            H=H,
            d2=dc,
            h12=h12,
            L=L,
            Lw=Lw,
            g=g,
            terminalarea=Ac,
            konvey2=Kc,
            h4.over.hc=h4.over.hc,
            So.gt.Sc=So.gt.Sc,
            isType1=isType1,
            valid=valid,
            roadflow=roadflow,
            message="",
            had.to.ignore.v1head.and.h12=had.to.ignore.v1head.and.h12);
  return(Q);
}
# TWRI p.4



"printType1" <-
function(flow=NULL, culvert=culvert, approach=approach,
         splash=TRUE, checkvalid=TRUE) {
  if(checkvalid & ! flow$valid) return(NA);

  lunits <- culvert$lengthunits;
  qunits <- culvert$flowunits;
  aunits <- culvert$areaunits;

  h12 <- flow$h12;
  if(is.numeric(h12)) {
     h12 <- paste(c(round(h12, digits=3), " ", lunits), sep="", collapse="");
  }
  v1head <- flow$v1head;
  if(is.numeric(v1head)) {
     v1head <- paste(c(round(v1head, digits=3), " ", lunits),
                     sep="", collapse="");
  }

  catme("  Depth (critical) at inlet", round(flow$d2, digits=3),lunits);
  catme("    Area (critical) at inlet", round(flow$Ac, digits=2),aunits);
  catme("    Conveyance (critical) at inlet", round(flow$Kc, digits=0),qunits);
  catme("  Equivalent length of culvert", round(flow$L, digits=2),lunits);
  catme("  Equivalent length of approach", round(flow$Lw, digits=2),lunits);
  catme("  Headloss between approach and inlet", h12);
  catme("  Approach velocity head", v1head);

  pdffile <- paste(c("TMPcapR_culvert",
                     culvert$TMP.key, "_inletoutlet.pdf"), collapse="");
  pdf(pdffile);
  graphCulvert(discharge=flow$Q, depth=flow$d2,
               culvert=culvert, location="inlet",
               depression=culvert$inlet.depression);
  dev.off();
}





################################################################
##    capR Source File ./Hydraulics/FlowTypes/QType2.R
################################################################
"QType2" <-
function(C=NULL, Ac=NULL, h1=NULL,
         a1=NULL, v1=NULL, dc=NULL, h12=NULL, h23=NULL, g=32.2) {
  vh <- a1*v1^2/(2*g);
  return(C*Ac*sqrt(h1 + vh - dc - h12 - h23));
}
# TWRI p.5


"culvert2QType2" <-
function(h1=NULL, h4=NULL, culvert=NULL, approach=NULL,
         digits=4, maxits=50, eps=1e-6, ...) {

  h1.elev <- h1; h4.elev <- h4;

  h1 <- h1 - culvert$zdsinvert;
  h4 <- h4 - culvert$zdsinvert;
  if(h4 < 0) h4 <- 0;

  So     <- culvert$So;
  z      <- culvert$z;
  g      <- culvert$gravity;
  D      <- culvert$diameter;
  A1     <- approach$geometry$AREATOTAL/approach$fraction.of.flow;
  A1frac <- culvert$fraction.of.approach.area;
  alpha1 <- approach$geometry$alpha;
  g2     <- 2*g;
  hzD    <- HeadwtrDiaRatio(h1=h1, culvert=culvert);
  NB     <- culvert$number.of.barrels;

  ifelse(culvert$ignore.approach.velocity.head, usev1  <- 0, usev1  <- 1);
  ifelse(culvert$ignore.approach.losses,        useh12 <- 0, useh12 <- 1);

  had.to.ignore.v1head.and.h12 <- NA;

  dc <- ((h1 - z)/2)*0.95;
  geo3 <- setCulvertGeometry(depth=dc, culvert=culvert, location="outlet",
                             depression=culvert$outlet.depression);
  A3 <- geo3$A;
  Q.old <- getDischargeAtCriticalDepth(depth=dc, culvert=culvert,
                                       location="outlet",
                                       depression=culvert$outlet.depression);
  v3 <- Q.old/A3;
  if(A3 == 0) v3 <- 0;

  d2 <- h1 - z - v3^2/g2; # TWRI p.25, simplification
  #catme("h1",h1);
  #catme("z",z);
  #catme("v3",v3);
     if(is.nan(d2)) {
        Q <- list(Q=0, error=0, its=0,
                  C=C,
                  Ac=NA,
                  Kc=NA,
                  A2=NA,
                  K2=NA,
                  h1=h1,
                  z=z,
                  v1head=0,
                  H=NA,
                  d2=NA,
                  d3=NA,
                  h12=NA,
                  h23=NA,
                  L=NA,
                  Lw=NA,
                  g=g,
                  terminalarea=NA,
                  konvey2=NA,
                  h4.over.hc=NA,
                  So.lt.Sc=NA,
                  isType2=FALSE,
                  valid=FALSE,
                  roadflow=culvert$road,
                  message="d2 is NaN, assume not Type 2",
                  had.to.ignore.v1head.and.h12=FALSE);
        return(Q);
     }
  #catme("Type 2 spinup d2",d2);
  inlet.depression <- culvert$inlet.depression;
  #catme("Type 2 interation D",D);
  #catme("Type 2 interation inlet.depression",inlet.depression);
  if(d2 > (D - inlet.depression)) d2 <- 0.95*(D - inlet.depression);
  if(d2 <= 0) d2 <- dc;

  road <- culvert$road; # properties of the road
  approachflow <- approach$TMP.accumulated.flow; # TOTAL COMPUTED FLOW
                                                 # FROM AN EARLIER RUN

  # July 11, 2016: The following line seems bogus and causes too much velocity head
  # because approachflow will be summed back into the Qtotal within the iteration loop.
  if(approachflow == 0) {
     #approachflow <- Q.old*NB;
     #Q.previous.run <- approachflow;
  }
  Q.previous.run     <- culvert$TMP.Q.previous.run;
  Qroad.previous.run <- culvert$TMP.Qroad.previous.run;
  v1head.approach <- usev1*alpha1*(approachflow/A1)^2/g2;
  v1head <- v1head.road <- 0;
  if(approach$forceEqualApproachHead) {
      v1head <- v1head.road <- v1head.approach;
  } else if(approach$forceIgnoreApproachHead) {
      v1head <- v1head.road <- v1head.approach <- 0;
  } else if(approach$useApproachHeadApportioning & approachflow != 0) {
      v1head <- usev1*alpha1*(Q.previous.run/(A1*A1frac))^2/g2;
      v1head.road <- (Qroad.previous.run/approachflow) * v1head.approach;
  } else if(approachflow != 0) {
      v1head      <- (Q.previous.run/approachflow)     * v1head.approach;
      v1head.road <- (Qroad.previous.run/approachflow) * v1head.approach;
  }
  roadflow <- Qroad(h1=h1.elev, h4=h4.elev, v1head=v1head.road, road=road);

  lengths <- Lengths4MiteredPipe(h1=h1, flowtype=2,  d2=d2, d3=dc,
                                 culvert=culvert, approach=approach);
  L  <- lengths$L;
  Lw <- lengths$Lw;

  h12 <- useh12*HeadLoss12(Q.old*NB, culvert=culvert,
                           approach=approach, d2=d2, otherL=Lw);
  h23 <- HeadLoss23(Q.old, culvert=culvert, d2=d2, d3=dc, otherL=L);

  Q <- NULL; Ac <- A3;  # A3 is Ac
  its <- 0;

  #catme("z=",z);
  #catme("g=",g);
  #catme("A1=",A1);
  #catme("v1head=",v1head);
  #catme("d2=",d2);
  #catme("d3=",d3);
  #catme("h12=",h12);
  #catme("h23=",h23);
  #catme("Q.old=",Q.old);

  #Qdcrel <- getDischargeCriticalDepthRelation(culvert=culvert);
  #dc.at.minQ <- Qdcrel$dc.at.minQ;
  #minQ.at.dc <- Qdcrel$minQ.at.dc;
  #catme("Qc.dc.rel has minQ:", minQ.at.dc, "dc at minQ", dc.at.minQ);

  So.gt.Sc <- NULL;

  while(1) {
     its <- its + 1;
     #catme("at loop origin Q.old",Q.old);
     #catme("h1:",h1);
     #catme("v1head:",v1head);
     #catme("dc:",dc);
     #catme("h12:",h12);
     #catme("h23:",h23);
     H <- h1 + v1head - dc - h12 - h23;
     #catme("Htype2:",H);

     if(H < 0) {
       usev1  <- 0;
       useh12 <- 0;
       had.to.ignore.v1head.and.h12 <- TRUE;
       H <- h1 - dc - h23;
     }
     if(H < 0) {
        Q <- list(Q=NA, error=NA, its=its,
                   C=NA,
                   Ac=NA,
                   Kc=NA,
                   A2=NA,
                   K2=NA,
                   h1=h1,
                   z=z,
                   v1head=v1head,
                   H=H,
                   d2=NA,
                   d3=NA,
                   h12=NA,
                   h23=NA,
                   L=L,
                   Lw=Lw,
                   g=g,
                   terminalarea=NA,
                   konvey2=NA,
                   h4.over.hc=NA,
                   So.lt.Sc=NA,
                   isType2=FALSE,
                   valid=FALSE,
                   roadflow=roadflow,
                   message="H < 0, trapping sqrt(x<0)",
                   had.to.ignore.v1head.and.h12=had.to.ignore.v1head.and.h12);
         return(Q);
     }
     tmp <- sqrt(g2*H);

     C <- getCforType2(culvert=culvert, approach=approach,
                       hzD=hzD, A1=A1, Ac=Ac);
     C <- round(C, digits=digits);

     Q <- C*Ac*tmp;
     #cat(c("Qloop=",Q,"\n"));
     dc  <- getCriticalDepth(Q, culvert=culvert,
                             location="outlet",
                             depression=culvert$outlet.depression);
     if(is.na(dc)) {
        Q <- list(Q=NA, error=NA, its=its,
                  C=C,
                  Ac=NA,
                  Kc=NA,
                  A2=NA,
                  K2=NA,
                  h1=h1,
                  z=z,
                  v1head=v1head,
                  H=NA,
                  d2=NA,
                  d3=NA,
                  h12=NA,
                  h23=NA,
                  L=L,
                  Lw=Lw,
                  g=g,
                  terminalarea=NA,
                  konvey2=NA,
                  h4.over.hc=NA,
                  So.lt.Sc=NA,
                  isType2=FALSE,
                  valid=FALSE,
                  roadflow=roadflow,
                  message="could not compute dc, assume not type 2 flow",
                  had.to.ignore.v1head.and.h12=had.to.ignore.v1head.and.h12);
        return(Q);
     }

     geo <- setCulvertGeometry(depth=dc, culvert=culvert,
                               location="outlet",
                               depression=culvert$outlet.depression);
     Ac  <- geo$A;
     v3  <- Q/Ac;
     Kc  <- geo$KONVEY;

     d2 <- getSubcriticalInletDepth(Q.old, C=C, h1=h1, v1head=v1head,
                                    h12=h12, v3=v3, culvert=culvert, dc=dc);
     if(is.nan(d2)) {
        Q <- list(Q=0, error=0, its=its,
                  C=C,
                  Ac=NA,
                  Kc=NA,
                  A2=NA,
                  K2=NA,
                  h1=h1,
                  z=z,
                  v1head=0,
                  H=NA,
                  d2=NA,
                  d3=NA,
                  h12=NA,
                  h23=NA,
                  L=L,
                  Lw=Lw,
                  g=g,
                  terminalarea=NA,
                  konvey2=NA,
                  h4.over.hc=NA,
                  So.lt.Sc=NA,
                  isType2=FALSE,
                  valid=FALSE,
                  roadflow=roadflow,
                  message="d2 is NaN, assume not Type 2",
                  had.to.ignore.v1head.and.h12=FALSE);
        return(Q);
     }
     #catme("Type 2 interation d2",d2);
     #catme("Type 2 interation D",D);
     #catme("Type 2 interation inlet.depression",inlet.depression);
     if(d2 > (D - inlet.depression)) d2 <- 0.95*(D - inlet.depression);
     if(d2 <= 0) d2 <- dc;
     #cat(c("d2=",d2,"\n"));

     geo <- setCulvertGeometry(depth=d2, culvert=culvert,
                               location="inlet",
                               depression=culvert$inlet.depression);
     A2  <- geo$A;
     K2  <- geo$KONVEY;

     # Discharge apportioning of total head amongst the two possible
     # units conveying flow (these culverts and the number of barrels NB)
     # and the optional roadway, only if actually present.
     # Note that approachflow was the TOTAL Q in A1 from last outer iteration
     # of the while(1) loop that this comments are typed in.
     roadQ <- roadflow$Qroad;
     totalQ <- Q.old*NB - Q.previous.run     +
               roadQ    - Qroad.previous.run + approachflow;
     v1head.approach <- usev1*alpha1*(totalQ/A1)^2/g2;
     v1head <- v1head.road <- 0;
     if(approach$forceEqualApproachHead) {
        v1head <- v1head.road <- v1head.approach;
     } else if(approach$forceIgnoreApproachHead) {
        v1head <- v1head.road <- v1head.approach <- 0;
     } else if(approach$useApproachHeadApportioning) {
        v1head <- usev1*alpha1*(Q.old*NB/(A1*A1frac))^2/g2;
        v1head.road <- (roadQ/approachflow) * v1head.approach;
     } else {
        v1head      <- (Q.old*NB/approachflow) * v1head.approach;
        v1head.road <- (roadQ/approachflow)    * v1head.approach;
     }
     roadflow <- Qroad(h1=h1.elev, h4=h4.elev, v1head=v1head.road, road=road);


     #d2 <- h1 - z + v1head - h12 - v3^2/(g2*C*C); # TWRI p.25 V2=V3;
     #cat(c("d2=",d2,"\n"));

     lengths <- Lengths4MiteredPipe(h1=h1, flowtype=2,  d2=d2, d3=dc,
                                 culvert=culvert, approach=approach);
     L  <- lengths$L;
     Lw <- lengths$Lw;

     h12 <- useh12*HeadLoss12(Q.old*NB, culvert=culvert,
                              approach=approach, d2=d2, otherL=Lw);

     h23 <- HeadLoss23(Q.old, culvert=culvert, d2=d2, d3=dc, otherL=L);

     #print(h1)
     #print(v1head)
     #print(dc)
     #print(h12)
     #print(h23)

     Sc <- (Q/Kc)^2;
     ifelse(So < Sc,              So.lt.Sc <- TRUE,   So.lt.Sc <- FALSE);
     ifelse(h4/dc < 1.0,        h4.over.hc <- TRUE, h4.over.hc <- FALSE);
     ifelse(h4.over.hc & So.lt.Sc, isType2 <- TRUE,    isType2 <- FALSE);

     if(abs(Q-Q.old)/Q.old < eps | its > maxits) break;
     Q.old <- Q;
  }

  ifelse(isType2, valid <- TRUE, valid <- FALSE);

  if(is.na(had.to.ignore.v1head.and.h12)) {
     had.to.ignore.v1head.and.h12 <- FALSE;
  } else {
     h12    <- "had to be ignored.";
     v1head <- "had to be ignored.";
  }

  Q <- list(Q=round(Q*NB, digits=4),
            error=(Q-Q.old)*NB,
            its=its,
            C=C,
            Ac=Ac,
            Kc=Kc,
            A2=A2,
            K2=K2,
            h1=h1,
            z=z,
            v1head=v1head,
            H=H,
            d2=d2,
            d3=dc,
            h12=h12,
            h23=h23,
            L=L,
            Lw=Lw,
            g=g,
            terminalarea=Ac,
            konvey2=K2,
            h4.over.hc=h4.over.hc,
            So.lt.Sc=So.lt.Sc,
            isType2=isType2,
            valid=valid,
            roadflow=roadflow,
            message="",
            had.to.ignore.v1head.and.h12=had.to.ignore.v1head.and.h12);
  return(Q);
}
# TWRI p.4




"printType2" <-
function(flow=NULL, culvert=culvert, approach=approach,
         splash=TRUE, checkvalid=TRUE) {
  if(checkvalid & ! flow$valid) return(NA);

  lunits <- culvert$lengthunits;
  qunits <- culvert$flowunits;
  aunits <- culvert$areaunits;


  h12 <- flow$h12;
  if(is.numeric(h12)) {
     h12 <- paste(c(round(h12, digits=3), " ", lunits), sep="", collapse="");
  }
  v1head <- flow$v1head;
  if(is.numeric(v1head)) {
     v1head <- paste(c(round(v1head, digits=3), " ", lunits),
                     sep="", collapse="");
  }

  catme("  Depth at inlet", round(flow$d2, digits=3),lunits);
  catme("    Area at inlet", round(flow$A2, digits=2),aunits);
  catme("    Conveyance at inlet", round(flow$K2, digits=0),qunits);
  catme("  Depth (critical) at outlet", round(flow$d3, digits=3),lunits);
  catme("    Area (critical) at outlet", round(flow$Ac, digits=2),aunits);
  catme("    Conveyance (critical) at outlet", round(flow$Kc, digits=0),qunits);
  catme("  Equivalent length of culvert", round(flow$L, digits=2),lunits);
  catme("  Equivalent length of approach", round(flow$Lw, digits=2),lunits);
  catme("  Headloss between approach and inlet", h12);
  catme("  Approach velocity head", v1head);
  catme("  Headloss between inlet and outlet", round(flow$h23,
                                                     digits=3),lunits);

  pdffile <- paste(c("TMPcapR_culvert",
                     culvert$TMP.key, "_inletoutlet.pdf"), collapse="");
  pdf(pdffile);
  graphCulvert(discharge=flow$Q, depth=flow$d2,
               culvert=culvert, location="inlet",
               depression=culvert$inlet.depression);
  graphCulvert(discharge=flow$Q, depth=flow$d3,
               culvert=culvert, location="outlet",
               depression=culvert$outlet.depression);
  dev.off();
}




################################################################
##    capR Source File ./Hydraulics/FlowTypes/QType3.R
################################################################
"QType3" <-
function(C=NULL, A3=NULL, h1=NULL, h3=NULL,
         a1=NULL, v1=NULL, h12=NULL, h23=NULL, g=32.2) {
  vh <- a1*v1^2/(2*g);
  return(C*A3*sqrt(h1 + vh - h3 - h12 - h23));
}
# TWRI p.5


"culvert2QType3" <-
function(h1=NULL, h4=NULL, culvert=NULL, approach=NULL,
         digits=4, maxits=50, eps=1e-6,...) {

  h1.elev <- h1; h4.elev <- h4;

  h1 <- h1 - culvert$zdsinvert;
  h4 <- h4 - culvert$zdsinvert;
  if(h4 < 0) h4 <- 0;

  So     <- culvert$So;
  z      <- culvert$z;
  g      <- culvert$gravity;
  D      <- culvert$diameter;
  A1     <- approach$geometry$AREATOTAL/approach$fraction.of.flow;
  A1frac <- culvert$fraction.of.approach.area;
  alpha1 <- approach$geometry$alpha;
  g2 <- 2*g;
  hzD <- HeadwtrDiaRatio(h1=h1, culvert=culvert);
  NB <- culvert$number.of.barrels;

  ifelse(culvert$ignore.approach.velocity.head, usev1  <- 0, usev1  <- 1);
  ifelse(culvert$ignore.approach.losses,        useh12 <- 0, useh12 <- 1);

  had.to.ignore.v1head.and.h12 <- NA;

  d3 <- ifelse(h4 == 0, 0.01*D, h4); # trap a zero tail water depth, which will yield A3=0
  geo3 <- setCulvertGeometry(depth=d3, culvert=culvert,
                             location="outlet",
                             depression=culvert$outlet.depression);
  A3   <- geo3$A;
  K3   <- geo3$KONVEY;
  TW3  <- geo3$TW;
  if(h4 > h1) {
     Q <- list(Q=0, error=0, its=0,
               C=C,
               A2=NA,
               K2=NA,
               A3=NA,
               K3=NA,
               h1=h1,
               z=z,
               v1head=0,
               H=NA,
                  d2=0,
                  d3=0,
                  h12=0,
                  h23=0,
                  L=NA,
                  Lw=NA,
                  g=g,
                  terminalarea=0,
                  konvey2=0,
                  h4.over.D=NA,
                  h4.over.hc=NA,
                  So.lt.Sc=NA,
                  isType3=FALSE,
                  valid=FALSE,
                  roadflow=culvert$road,
                  message="h4 > h1",
                  had.to.ignore.v1head.and.h12=FALSE);
        return(Q);
  }
  Q.old <- 0.95*A3*sqrt(g2*(h1-h4));
  v3 <- Q.old/A3;
  if(A3 == 0) v3 <- 0;
  #catme("A3=",A3);
  #catme("d3=",d3);
  #catme("v3=",v3);
  #catme("h1=",h1);
  #catme("h4=",h4);
  #catme("D=",D);
  d2 <- h1 - z - v3^2/g2; # TWRI p.25, simplification
  #catme("Type 3 spinup d2",d2);
  #catme("Type 3 spinup D",D);

  inlet.depression <- culvert$inlet.depression;
  #catme("Type 3 spinup inlet.depression",inlet.depression);

  if(d2 > (D - inlet.depression)) d2 <- 0.95*(D - inlet.depression);
  if(d2 <= 0) d2 <- d3; # trapping a bad spin up, one cause is not enough
  # head to push flow through the pipe given the "fair approximation" of Q.old

  road <- culvert$road; # properties of the road
  approachflow <- approach$TMP.accumulated.flow; # TOTAL COMPUTED FLOW
                                                 # FROM AN EARLIER RUN
  
  # July 11, 2016: The following line seems bogus and causes too much velocity head
  # because approachflow will be summed back into the Qtotal within the iteration loop.
  if(approachflow == 0) {
     #approachflow <- Q.old*NB;
     #Q.previous.run <- approachflow;
  }
  Q.previous.run     <- culvert$TMP.Q.previous.run;
  Qroad.previous.run <- culvert$TMP.Qroad.previous.run;
  v1head.approach <- usev1*alpha1*(approachflow/A1)^2/g2;
  v1head <- v1head.road <- 0;
  if(approach$forceEqualApproachHead) {
      v1head <- v1head.road <- v1head.approach;
  } else if(approach$forceIgnoreApproachHead) {
      v1head <- v1head.road <- v1head.approach <- 0;
  } else if(approach$useApproachHeadApportioning & approachflow != 0) {
      v1head <- usev1*alpha1*(Q.previous.run/(A1*A1frac))^2/g2;
      v1head.road <- (Qroad.previous.run/approachflow) * v1head.approach;
  } else if(approachflow != 0) {
      v1head      <- (Q.previous.run/approachflow)     * v1head.approach;
      v1head.road <- (Qroad.previous.run/approachflow) * v1head.approach;
  }
  roadflow <- Qroad(h1=h1.elev, h4=h4.elev, v1head=v1head.road, road=road);

  lengths <- Lengths4MiteredPipe(h1=h1, flowtype=3,  d2=d2, d3=d3,
                                 culvert=culvert, approach=approach);
  L  <- lengths$L;
  Lw <- lengths$Lw;

  h12 <- useh12*HeadLoss12(Q.old*NB, culvert=culvert,
                           approach=approach, d2=d2, otherL=Lw);
  h23 <- HeadLoss23(Q.old, culvert=culvert, d2=d2, d3=d3, otherL=L);


  Q <- NULL;
  its <- 0;

  #catme("h1=",h1);
  #catme("h4=",h4);
  #catme("z=",z);
  #catme("g=",g);
  #catme("A1=",A1);
  #catme("v1head=",v1head);
  #catme("d2=",d2);
  #catme("d3=",d3);
  #catme("h12=",h12);
  #catme("h23=",h23);
  #catme("Q.old=",Q.old);

  So.gt.Sc <- NULL;

  while(1) {
     its <- its + 1;

     H <- h1 + v1head - d3 - h12 - h23;
     if(H < 0) {
       usev1  <- 0;
       useh12 <- 0;
       had.to.ignore.v1head.and.h12 <- TRUE;
       H <- h1 - d3 - h23;
     }
     if(H < 0) {
         Q <- list(Q=NA, error=NA, its=its,
                  C=NA,
                  A2=NA,
                  K2=NA,
                  A3=A3,
                  K3=K3,
                  h1=h1,
                  z=z,
                  v1head=v1head,
                  H=H,
                  d2=NA,
                  d3=d3,
                  h12=NA,
                  h23=NA,
                  L=L,
                  Lw=Lw,
                  g=g,
                  terminalarea=NA,
                  konvey2=NA,
                  h4.over.D=NA,
                  h4.over.hc=NA,
                  So.lt.Sc=NA,
                  isType3=FALSE,
                  valid=FALSE,
                  roadflow=roadflow,
                  message="H < 0, trapping sqrt(x<0)",
                  had.to.ignore.v1head.and.h12=had.to.ignore.v1head.and.h12);
        return(Q);
     }
     tmp <- sqrt(g2*H);

     Fr <- Froude(discharge=Q.old, area=A3, topwidth=TW3, g=g);
     C <- getCforType3(culvert=culvert, approach=approach,
                       froude=Fr, hzD=hzD, A1=A1, Ac=A3);
     C <- round(C, digits=digits);

     Q <- C*A3*tmp;
     v3 <- Q/A3;

     d2 <- getSubcriticalInletDepth(Q.old, C=C, h1=h1, v1head=v1head,
                                    h12=h12, v3=v3, culvert=culvert, dc=dc);
     #cat(c("d2=",d2,"\n"));
     if(is.nan(d2)) d2 <- d3;
     #catme("Type 3 interation d2",d2,d3);
     if(d2 > D) d2 <- 0.95*D;
     if(d2 <= 0) d2 <- d3;

     geo <- setCulvertGeometry(depth=d2, culvert=culvert,
                               location="inlet",
                               depression=culvert$inlet.depression);
     A2  <- geo$A;
     K2  <- geo$KONVEY;

     # Discharge apportioning of total head amongst the two possible
     # units conveying flow (these culverts and the number of barrels NB)
     # and the optional roadway, only if actually present.
     # Note that approachflow was the TOTAL Q in A1 from last outer iteration
     # of the while(1) loop that this comments are typed in.
     roadQ <- roadflow$Qroad;
     totalQ <- Q.old*NB - Q.previous.run     +
               roadQ    - Qroad.previous.run + approachflow;
     v1head.approach <- usev1*alpha1*(totalQ/A1)^2/g2;
     v1head <- v1head.road <- 0;
     if(approach$forceEqualApproachHead) {
        v1head <- v1head.road <- v1head.approach;
     } else if(approach$forceIgnoreApproachHead) {
        v1head <- v1head.road <- v1head.approach <- 0;
     } else if(approach$useApproachHeadApportioning) {
        v1head <- usev1*alpha1*(Q.old*NB/(A1*A1frac))^2/g2;
        v1head.road <- (roadQ/approachflow) * v1head.approach;
     } else {
        v1head      <- (Q.old*NB/approachflow) * v1head.approach;
        v1head.road <- (roadQ/approachflow)    * v1head.approach;
     }
     roadflow <- Qroad(h1=h1.elev, h4=h4.elev, v1head=v1head.road, road=road);

     lengths <- Lengths4MiteredPipe(h1=h1, flowtype=3,  d2=d2, d3=d3,
                                    culvert=culvert, approach=approach);
     L  <- lengths$L;
     Lw <- lengths$Lw;

     h12 <- useh12*HeadLoss12(Q.old*NB, culvert=culvert,
                       approach=approach, d2=d2, otherL=Lw);

     h23 <- HeadLoss23(Q.old, culvert=culvert, d2=d2, d3=d3, otherL=L);

     #print(Q.old);
     #print(Q);
     #print(h1)
     #print(v1head)
     #print(h12)
     #print(h23)

     hc  <- getCriticalDepth(Q.old, culvert=culvert,
                             location="outlet",
                             depression=culvert$outlet.depression);
     if(is.na(hc)) {
        Q <- list(Q=NA, error=NA, its=its,
                  C=C,
                  A2=NA,
                  K2=NA,
                  A3=A3,
                  K3=K3,
                  h1=h1,
                  z=z,
                  v1head=v1head,
                  H=H,
                  d2=NA,
                  d3=d3,
                  h12=NA,
                  h23=NA,
                  L=L,
                  Lw=Lw,
                  g=g,
                  terminalarea=NA,
                  konvey2=NA,
                  h4.over.D=NA,
                  h4.over.hc=NA,
                  So.lt.Sc=NA,
                  isType3=FALSE,
                  valid=FALSE,
                  roadflow=roadflow,
                  message="could not compute hc, assume not type 3 flow",
                  had.to.ignore.v1head.and.h12=had.to.ignore.v1head.and.h12);
        return(Q);
     }
     geo <- setCulvertGeometry(depth=hc, culvert=culvert,
                               location="outlet",
                               depression=culvert$outlet.depression);
     Ac  <- geo$A;
     v3  <- Q/Ac;
     Kc  <- geo$KONVEY;

     Sc <- (Q/Kc)^2;
     ifelse(So < Sc,               So.lt.Sc <- TRUE,   So.lt.Sc <- FALSE);
     ifelse(h4/D <= 1.0,          h4.over.D <- TRUE,  h4.over.D <- FALSE);
     ifelse(h4/hc > 1.0,         h4.over.hc <- TRUE, h4.over.hc <- FALSE);
     ifelse(h4.over.D & h4.over.hc, isType3 <- TRUE,    isType3 <- FALSE);

     if(abs(Q-Q.old)/Q.old < eps | its > maxits) break;
     Q.old <- Q;
  }

  ifelse(isType3, valid <- TRUE, valid <- FALSE);

  if(is.na(had.to.ignore.v1head.and.h12)) {
     had.to.ignore.v1head.and.h12 <- FALSE;
  } else {
     h12    <- "had to be ignored.";
     v1head <- "had to be ignored.";
  }


  Q <- list(Q=round(Q*NB, digits=4),
            error=(Q-Q.old)*NB,
            its=its,
            C=C,
            A2=A2,
            K2=K2,
            A3=A3,
            K3=K3,
            h1=h1,
            z=z,
            v1head=v1head,
            H=H,
            d2=d2,
            d3=d3,
            h12=h12,
            h23=h23,
            L=L,
            Lw=Lw,
            g=g,
            terminalarea=A3,
            konvey2=K2,
            h4.over.D=h4.over.D,
            h4.over.hc=h4.over.hc,
            So.lt.Sc=So.lt.Sc,
            isType3=isType3,
            valid=valid,
            roadflow=roadflow,
            message="",
            had.to.ignore.v1head.and.h12=had.to.ignore.v1head.and.h12);
  return(Q);
}
# TWRI p.4





"printType3" <-
function(flow=NULL, culvert=culvert, approach=approach,
         splash=TRUE, checkvalid=TRUE) {
  if(checkvalid & ! flow$valid) return(NA);

  lunits <- culvert$lengthunits;
  qunits <- culvert$flowunits;
  aunits <- culvert$areaunits;

  h12 <- flow$h12;
  if(is.numeric(h12)) {
     h12 <- paste(c(round(h12, digits=3), " ", lunits),
                  sep="", collapse="");
  }
  v1head <- flow$v1head;
  if(is.numeric(v1head)) {
     v1head <- paste(c(round(v1head, digits=3), " ", lunits),
                     sep="", collapse="");
  }

  g  <- culvert$gravity;
  g2 <- 2*g;

  catme("  Depth at inlet", round(flow$d2, digits=3),lunits);
  catme("    Area at inlet", round(flow$A2, digits=2),aunits);
  catme("    Conveyance at inlet", round(flow$K2, digits=0),qunits);
  catme("    Velocity head at inlet",
                  round((flow$Q/flow$A2)^2/g2, digits=3), lunits);
  catme("  Depth at outlet", round(flow$d3, digits=3),lunits);
  catme("    Area at outlet", round(flow$A3, digits=2),aunits);
  catme("    Conveyance at outlet", round(flow$K3, digits=0),qunits);
  catme("    Velocity head at outlet",
                  round((flow$Q/flow$A3)^2/g2, digits=3),lunits);
  catme("  Equivalent length of culvert", round(flow$L, digits=2),lunits);
  catme("  Equivalent length of approach", round(flow$Lw, digits=2),lunits);
  catme("  Headloss between approach and inlet", h12);
  catme("  Approach velocity head", v1head);
  catme("  Headloss between inlet and outlet", round(flow$h23,
                                                       digits=3),lunits);

  pdffile <- paste(c("TMPcapR_culvert",
                     culvert$TMP.key, "_inletoutlet.pdf"), collapse="");
  pdf(pdffile);
  graphCulvert(discharge=flow$Q, depth=flow$d2,
               culvert=culvert, location="inlet",
               depression=culvert$inlet.depression);
  graphCulvert(discharge=flow$Q, depth=flow$d3,
               culvert=culvert, location="outlet",
               depression=culvert$outlet.depression);
  dev.off();
}




################################################################
##    capR Source File ./Hydraulics/FlowTypes/QType4.R
################################################################
"QType4" <-
function(C=NULL, Ao=NULL, h1=NULL, h4=NULL, n=NULL,
         L=NULL, Ro=NULL, g=32.2, manningcor=1.486) {
  tmp <- 2*g*(C*n)^2*L/(manningcor^2*Ro^(4/3)); tmp <- 1 + tmp;
  delh <- h1 - h4;
  return( C*Ao*sqrt(2*g*(delh)/tmp) );
}
# TWRI p.5

"culvert2QType4" <-
function(h1=NULL, h4=NULL, culvert=NULL, approach=NULL,
         digits=4, maxits=50, eps=1e-6, ...) {

  h1.elev <- h1; h4.elev <- h4;

  h1 <- h1 - culvert$zdsinvert;
  h4 <- h4 - culvert$zdsinvert;
  if(h4 < 0) h4 <- 0;

  Ao  <- culvert$Ao.inlet;
  Ro  <- culvert$Ro.inlet;
  Ko  <- culvert$Ko.inlet;
  z   <- culvert$z;
  D   <- culvert$diameter;
  inlet.depression <- culvert$inlet.depression;
  d2 <- D - inlet.depression;

  n   <- culvert$nvalue;
  L   <- culvert$Ltop; # TWRI p.8
  g   <- culvert$gravity;
  manningcor <- culvert$manningcor;
  NB <- culvert$number.of.barrels;
  A1     <- approach$geometry$AREATOTAL/approach$fraction.of.flow;
  A1frac <- culvert$fraction.of.approach.area;
  alpha1 <- approach$geometry$alpha;
  g2 <- 2*g;

  ifelse(culvert$ignore.approach.velocity.head, usev1  <- 0, usev1  <- 1);
  ifelse(culvert$ignore.approach.losses,        useh12 <- 0, useh12 <- 1);

  C <- round(getCforType4(culvert=culvert), digits=digits);
  #catme("h1",h1); catme("h4",h4);
  #catme("g",g);catme("n",n);catme("Ro",Ro);
  #catme("manningcor",manningcor);
  tmp <- g2*(C*n)^2*L/(manningcor^2*Ro^(4/3));
  Q.old <- C*Ao*sqrt(g2*(h1 - h4)/(1 + tmp));

  road <- culvert$road; # properties of the road
  approachflow <- approach$TMP.accumulated.flow; # TOTAL COMPUTED FLOW
                                                 # FROM AN EARLIER RUN
  
  # July 11, 2016: The following line seems bogus and causes too much velocity head
  # because approachflow will be summed back into the Qtotal within the iteration loop.
  if(approachflow == 0) {
     #approachflow <- Q.old*NB;
     #Q.previous.run <- approachflow;
  }
  Q.previous.run     <- culvert$TMP.Q.previous.run;
  Qroad.previous.run <- culvert$TMP.Qroad.previous.run;
  v1head.approach <- usev1*alpha1*(approachflow/A1)^2/g2;
  v1head <- v1head.road <- 0;
  if(approach$forceEqualApproachHead) {
      v1head <- v1head.road <- v1head.approach;
  } else if(approach$forceIgnoreApproachHead) {
      v1head <- v1head.road <- v1head.approach <- 0;
  } else if(approach$useApproachHeadApportioning & approachflow != 0) {
      v1head <- usev1*alpha1*(Q.previous.run/(A1*A1frac))^2/g2;
      v1head.road <- (Qroad.previous.run/approachflow) * v1head.approach;
  } else if(approachflow != 0) {
      v1head      <- (Q.previous.run/approachflow)     * v1head.approach;
      v1head.road <- (Qroad.previous.run/approachflow) * v1head.approach;
  }
  roadflow <- Qroad(h1=h1.elev, h4=h4.elev, v1head=v1head.road, road=road);

  its <- 0;
  while(1) {
     its <- its + 1;

     # Discharge apportioning of total head amongst the two possible
     # units conveying flow (these culverts and the number of barrels NB)
     # and the optional roadway, only if actually present.
     # Note that approachflow was the TOTAL Q in A1 from last outer iteration
     # of the while(1) loop that this comments are typed in.
     roadQ <- roadflow$Qroad;
     totalQ <- Q.old*NB - Q.previous.run     +
               roadQ    - Qroad.previous.run + approachflow;
     v1head.approach <- usev1*alpha1*(totalQ/A1)^2/g2;
     v1head <- v1head.road <- 0;
     if(approach$forceEqualApproachHead) {
        v1head <- v1head.road <- v1head.approach;
     } else if(approach$forceIgnoreApproachHead) {
        v1head <- v1head.road <- v1head.approach <- 0;
     } else if(approach$useApproachHeadApportioning) {
        v1head <- usev1*alpha1*(Q.old*NB/(A1*A1frac))^2/g2;
        v1head.road <- (roadQ/approachflow) * v1head.approach;
     } else {
        v1head      <- (Q.old*NB/approachflow) * v1head.approach;
        v1head.road <- (roadQ/approachflow)    * v1head.approach;
     }
     roadflow <- Qroad(h1=h1.elev, h4=h4.elev, v1head=v1head.road, road=road);

     lengths <- Lengths4MiteredPipe(h1=h1, flowtype=4, d2=NA, d3=NA,
                                    culvert=culvert, approach=approach);
     L  <- lengths$L;
     Lw <- lengths$Lw;

     h12 <- useh12*HeadLoss12(Q.old*NB, culvert=culvert,
                              approach=approach, d2=d2, otherL=Lw);

     #catme("h1-z:",(h1-z));
     #catme("D:",D);
     vohead <- (Q.old/Ao)^2/(g2*C^2);
     #catme("vohead",vohead);

     Q <- C*Ao*sqrt(g2*(h1 - h4 + v1head - h12)/(1 + tmp));
     if(! is.finite(Q)) {
        stop("Infinite Q determined for Type 4, v1head likely growing unbounded, try larger approach section or reducing fraction of total flow normal to inlet");
     }
     # TWRI p. 36 For type4 h1-z must exceed D by an amount
     # equal to vohead (with C^2 term) to ensure full flow
     # at upstream end. WHA interprets this to be
     # "exceed by at least"
     #catme("h1",h1);catme("z",z);catme("vohead",vohead);
     #catme("D",D);catme("C",C);catme("Q",Q);
     #catme("Ao",Ao);

     #ifelse(h1 - z - vohead > D, valid <- TRUE, valid <- FALSE);
     ifelse(h1 - z - D >= vohead, valid <- TRUE, valid <- FALSE);

     if(abs(Q-Q.old)/Q.old < eps | its > maxits) break;
     Q.old <- Q;
  }

  # A few cases have been found in which valid is FALSE yet, things seem
  # SO submerged that surely barrel is running full at inlet. Use the 1.5
  # criteria to represent head that is so high that barrel will be full
  # regardless of what the relation between h1, z, D, and vohead tells us.
  if(valid == FALSE && (h1-z)/D > 1.5) valid <- TRUE;

  Q <- list(Q=round(Q*NB, digits=digits),
            error=(Q-Q.old)*NB,
            its=its,
            C=C,
            d2=d2,
            Ao=Ao,
            Ro=Ro,
            Ko=Ko,
            L=L,
            H=(h1-h4),
            h1=h1,
            vohead=vohead,
            v1head=v1head,
            g=g,
            terminalarea=Ao,
            konvey2=Ko,
            isType4=valid,
            valid=valid,
            roadflow=roadflow,
            message="");
  return(Q);
}




"printType4" <-
function(flow=NULL, culvert=culvert, approach=approach,
         splash=TRUE, checkvalid=TRUE) {
  if(checkvalid & ! flow$valid) return(NA);

  lunits <- culvert$lengthunits;
  qunits <- culvert$flowunits;
  aunits <- culvert$areaunits;

  catme("  Depth (at crown)", round(flow$d2, digits=2), lunits);
  catme("    Area (naught)", round(flow$Ao, digits=2), aunits);
  catme("    Hydraulic Radius (naught)", round(flow$Ro, digits=2), lunits);
  catme("    Conveyance (naught)", round(flow$Ko, digits=0), qunits);
  catme("  Length of culvert", round(flow$L, digits=2), lunits);
  catme("  Approach velocity head", round(flow$v1head, digits=3), lunits);

  pdffile <- paste(c("TMPcapR_culvert",
                     culvert$TMP.key, "_inletoutlet.pdf"), collapse="");
  pdf(pdffile);
  graphCulvert(discharge=flow$Q,
               depth=culvert$diameter-culvert$inlet.depression,
               culvert=culvert, location="inlet",
               depression=culvert$inlet.depression);
  graphCulvert(discharge=flow$Q,
               depth=culvert$diameter-culvert$outlet.depression,
               culvert=culvert, location="outlet",
               depression=culvert$outlet.depression);
  dev.off();

}



################################################################
##    capR Source File ./Hydraulics/FlowTypes/QType5.R
################################################################
"QType5" <-
function(C=NULL, Ao=NULL, h1=NULL, z=NULL, g=NULL) {
  return( C*Ao*sqrt(2*g*(h1 - z) ) );
}
# TWRI p.6

"culvert2QType5" <-
function(h1=NULL, h4=NULL, culvert=NULL, approach=NULL,
         digits=4, maxits=50, eps=1e-6, ...) {

  h1.elev <- h1; h4.elev <- h4;

  h1 <- h1 - culvert$zdsinvert;
  h4 <- h4 - culvert$zdsinvert;
  if(h4 < 0) h4 <- 0;

  z  <- culvert$z;
  Ao <- culvert$Ao.inlet;
  Ko <- culvert$Ko.inlet;
  L  <- culvert$Ltop;
  g  <- culvert$gravity;
  C  <- getCforType5(h1=h1, culvert=culvert);
  NB <- culvert$number.of.barrels;
  A1     <- approach$geometry$AREATOTAL/approach$fraction.of.flow;
  A1frac <- culvert$fraction.of.approach.area;
  alpha1 <- approach$geometry$alpha;
  D   <- culvert$diameter;
  inlet.depression <- culvert$inlet.depression;
  d2 <- D - inlet.depression;
  g2 <- 2*g;

  ifelse(culvert$ignore.approach.velocity.head, usev1  <- 0, usev1  <- 1);
  ifelse(culvert$ignore.approach.losses,        useh12 <- 0, useh12 <- 1);

  Q.old <- C*Ao*sqrt(g2*(h1 - z));

  road <- culvert$road; # properties of the road
  approachflow <- approach$TMP.accumulated.flow; # TOTAL COMPUTED FLOW
                                                 # FROM AN EARLIER RUN
  
  # July 11, 2016: The following line seems bogus and causes too much velocity head
  # because approachflow will be summed back into the Qtotal within the iteration loop.
  if(approachflow == 0) {
     #approachflow <- Q.old*NB;
     #Q.previous.run <- approachflow;
  }
  Q.previous.run     <- culvert$TMP.Q.previous.run;
  Qroad.previous.run <- culvert$TMP.Qroad.previous.run;
  v1head.approach <- usev1*alpha1*(approachflow/A1)^2/g2;
  v1head <- v1head.road <- 0;
  if(approach$forceEqualApproachHead) {
      v1head <- v1head.road <- v1head.approach;
  } else if(approach$forceIgnoreApproachHead) {
      v1head <- v1head.road <- v1head.approach <- 0;
  } else if(approach$useApproachHeadApportioning & approachflow != 0) {
      v1head <- usev1*alpha1*(Q.previous.run/(A1*A1frac))^2/g2;
      v1head.road <- (Qroad.previous.run/approachflow) * v1head.approach;
  } else if(approachflow != 0) {
      v1head      <- (Q.previous.run/approachflow)     * v1head.approach;
      v1head.road <- (Qroad.previous.run/approachflow) * v1head.approach;
  }
  roadflow <- Qroad(h1=h1.elev, h4=h4.elev, v1head=v1head.road, road=road);

  its <- 0;
  while(1) {
     its <- its + 1;
     #catme("iteration:",its);

     # Discharge apportioning of total head amongst the two possible
     # units conveying flow (these culverts and the number of barrels NB)
     # and the optional roadway, only if actually present.
     # Note that approachflow was the TOTAL Q in A1 from last outer iteration
     # of the while(1) loop that this comments are typed in.
     roadQ <- roadflow$Qroad;
     totalQ <- Q.old*NB - Q.previous.run     +
               roadQ    - Qroad.previous.run + approachflow;
     v1head.approach <- usev1*alpha1*(totalQ/A1)^2/g2;
     v1head <- v1head.road <- 0;
     if(approach$forceEqualApproachHead) {
        v1head <- v1head.road <- v1head.approach;
     } else if(approach$forceIgnoreApproachHead) {
        v1head <- v1head.road <- v1head.approach <- 0;
     } else if(approach$useApproachHeadApportioning) {
        v1head <- usev1*alpha1*(Q.old*NB/(A1*A1frac))^2/g2;
        v1head.road <- (roadQ/approachflow) * v1head.approach;
     } else {
        v1head      <- (Q.old*NB/approachflow) * v1head.approach;
        v1head.road <- (roadQ/approachflow)    * v1head.approach;
     }
     roadflow <- Qroad(h1=h1.elev, h4=h4.elev, v1head=v1head.road, road=road);


     lengths <- Lengths4MiteredPipe(h1=h1, flowtype=5, d2=NA, d3=NA,
                                    culvert=culvert, approach=approach);
     L  <- lengths$L;
     Lw <- lengths$Lw;

     h12 <- useh12*HeadLoss12(Q.old*NB, culvert=culvert,
                              approach=approach, d2=d2, otherL=Lw);

     #catme("v1head:",v1head);
     H <- h1 - z + v1head - h12;
     Q <- C*Ao*sqrt(g2*H);
     if(! is.finite(Q)) {
        stop("Infinite Q determined for Type 5, v1head likely growing unbounded, try larger approach section or reducing fraction of total flow normal to inlet");
     }
     if(abs(Q-Q.old)/Q.old < eps | its > maxits) break;
     Q.old <- Q;
  }

  test56 <- isType5or6(h1=h1+v1head, culvert=culvert);

  Q <- list(Q=round(Q*NB, digits=digits),
            error=(Q-Q.old)*NB, its=its,
            C=C,
            d2=d2,
            Ao=Ao,
            Ko=Ko,
            h1=h1,
            z=z,
            H=H,
            v1head=v1head,
            L=L,
            g=g,
            terminalarea=Ao,
            konvey2=Ko,
            isType5=test56$isType5,
            valid=test56$isType5,
            roadflow=roadflow,
            message="");
  return(Q);
}


"printType5" <-
function(flow=NULL, culvert=culvert, approach=approach,
         splash=TRUE, checkvalid=TRUE) {
  if(checkvalid & ! flow$valid) return(NA);

  lunits <- culvert$lengthunits;
  qunits <- culvert$flowunits;
  aunits <- culvert$areaunits;

  catme("  Depth (at crown) at inlet", round(flow$d2, digits=3),lunits);
  catme("  Area (naught)", round(flow$Ao, digits=2),aunits);
  catme("  Conveyance (naught)", round(flow$Ko, digits=0),qunits);
  catme("  Approach velocity head", round(flow$v1head, digits=3), lunits);

  pdffile <- paste(c("TMPcapR_culvert",
                     culvert$TMP.key, "_inletoutlet.pdf"), collapse="");
  pdf(pdffile);
  graphCulvert(discharge=flow$Q,
               depth=culvert$diameter-culvert$inlet.depression,
               culvert=culvert, location="inlet",
               depression=culvert$inlet.depression);
  dev.off();
}


"isType5or6" <-
function(type, h1=NULL, culvert=NULL) {
  So <- culvert$slope;
  D  <- culvert$diameter;
  nvalue <- culvert$nvalue;
  L  <- culvert$Ltop; # TWRI p.8
  g  <- culvert$gravity;
  Ro <- culvert$Ro.inlet;
  manningcor <- culvert$manningcor;
  z  <- culvert$z;

  L.over.D <- L/D;
  X <- 2*g * nvalue^2 * (h1-z) / (manningcor^2 * Ro^(4/3));

  isType5 <- isType6 <- FALSE;
  if((culvert$type == "circle" | culvert$type == "ellipse") &
    culvert$is.barrel.rough == TRUE) { # FIGURE 16
    fig16 <- TWRIfigure16(h1=h1, culvert=culvert);
    if(fig16 == 5) isType5 <- TRUE;
    if(fig16 == 6) isType6 <- TRUE;
  } else { # FIGURE 15
    fig15 <- TWRIfigure15(culvert=culvert);
    if(fig15 == 5) isType5 <- TRUE;
    if(fig15 == 6) isType6 <- TRUE;
  }

  return(list(isType5=isType5, isType6=isType6, L.over.D=L.over.D, X=X));
}




################################################################
##    capR Source File ./Hydraulics/FlowTypes/QType6.R
################################################################
"QType6" <-
function(C=NULL, Ao=NULL, h1=NULL, h3=NULL, h23=NULL, g=NULL) {
  return( C*Ao*sqrt(2*g*(h1 - h3 - h23) ) );
}
# TWRI p.6


"culvert2QType6" <-
function(h1=NULL, h4=NULL, culvert=NULL, approach=NULL,
         digits=4, maxits=50, eps=1e-6, ...) {

  h1.elev <- h1; h4.elev <- h4;

  h1 <- h1 - culvert$zdsinvert;
  h4 <- h4 - culvert$zdsinvert;
  if(h4 < 0) h4 <- 0;

  Ao  <- culvert$Ao.inlet;
  Ko  <- culvert$Ko.inlet;
  g   <- culvert$gravity;
  A1     <- approach$geometry$AREATOTAL/approach$fraction.of.flow;
  A1frac <- culvert$fraction.of.approach.area;
  alpha1 <- approach$geometry$alpha;
  D   <- culvert$diameter;
  inlet.depression <- culvert$inlet.depression;
  d2 <- D - inlet.depression;
  L   <- culvert$Ltop; # TWRI p.8
  g2  <- 2*g;
  NB <- culvert$number.of.barrels;

  ifelse(culvert$ignore.approach.velocity.head, usev1  <- 0, usev1  <- 1);
  ifelse(culvert$ignore.approach.losses,        useh12 <- 0, useh12 <- 1);

  test56 <- isType5or6(h1=h1, culvert=culvert);

  C <- round(getCforType6(culvert=culvert), digits=digits);

  Qbyfig17 <- QType6byFig17(h1=h1, C=C, culvert=culvert);


  # initially guess that h3 is in accordance to TWRI p. 34
  # however, this is largely paying homage as these will
  # quickly be superceded in the iterations.
  ifelse(culvert$type == "box", h3 <- 0.65*d2,
                                h3 <- 0.75*d2);
  Q.old <- getDischargeAtCriticalDepth(h3, culvert=culvert,
                                       location="outlet",
                                       depression=culvert$outlet.depression);

  road <- culvert$road; # properties of the road
  approachflow <- approach$TMP.accumulated.flow; # TOTAL COMPUTED FLOW
                                                 # FROM AN EARLIER RUN

  # July 11, 2016: The following line seems bogus and causes too much velocity head
  # because approachflow will be summed back into the Qtotal within the iteration loop.
  if(approachflow == 0) {
     #approachflow <- Q.old*NB;
     #Q.previous.run <- approachflow;
  }
  Q.previous.run     <- culvert$TMP.Q.previous.run;
  Qroad.previous.run <- culvert$TMP.Qroad.previous.run;
  v1head.approach <- usev1*alpha1*(approachflow/A1)^2/g2;
  v1head <- v1head.road <- 0;
  if(approach$forceEqualApproachHead) {
      v1head <- v1head.road <- v1head.approach;
  } else if(approach$forceIgnoreApproachHead) {
      v1head <- v1head.road <- v1head.approach <- 0;
  } else if(approach$useApproachHeadApportioning & approachflow != 0) {
      v1head <- usev1*alpha1*(Q.previous.run/(A1*A1frac))^2/g2;
      v1head.road <- (Qroad.previous.run/approachflow) * v1head.approach;
  } else if(approachflow != 0) {
      v1head      <- (Q.previous.run/approachflow)     * v1head.approach;
      v1head.road <- (Qroad.previous.run/approachflow) * v1head.approach;
  }
  roadflow <- Qroad(h1=h1.elev, h4=h4.elev, v1head=v1head.road, road=road);

  #catme("Q.old=",Q.old);
  Q <- NULL;
  its <- 0;
  while(1) {
     its <- its + 1;

     h3 <- getH3forType6(h4=h4, discharge=Q.old, culvert=culvert);

     geo3 <- setCulvertGeometry(depth=h3, culvert=culvert,
                                location="outlet",
                                depression=culvert$outlet.depression);
     A3   <- geo3$A;
     K3   <- geo3$KONVEY;

     # Discharge apportioning of total head amongst the two possible
     # units conveying flow (these culverts and the number of barrels NB)
     # and the optional roadway, only if actually present.
     # Note that approachflow was the TOTAL Q in A1 from last outer iteration
     # of the while(1) loop that this comments are typed in.
     roadQ <- roadflow$Qroad;
     totalQ <- Q.old*NB - Q.previous.run     +
               roadQ    - Qroad.previous.run + approachflow;
     v1head.approach <- usev1*alpha1*(totalQ/A1)^2/g2;
     v1head <- v1head.road <- 0;
     if(approach$forceEqualApproachHead) {
        v1head <- v1head.road <- v1head.approach;
     } else if(approach$forceIgnoreApproachHead) {
        v1head <- v1head.road <- v1head.approach <- 0;
     } else if(approach$useApproachHeadApportioning) {
        v1head <- usev1*alpha1*(Q.old*NB/(A1*A1frac))^2/g2;
        v1head.road <- (roadQ/approachflow) * v1head.approach;
     } else {
        v1head      <- (Q.old*NB/approachflow) * v1head.approach;
        v1head.road <- (roadQ/approachflow)    * v1head.approach;
     }
     roadflow <- Qroad(h1=h1.elev, h4=h4.elev, v1head=v1head.road, road=road);

     lengths <- Lengths4MiteredPipe(h1=h1, flowtype=6, d2=NA, d3=NA,
                                    culvert=culvert, approach=approach);
     L  <- lengths$L;
     Lw <- lengths$Lw;

     h12 <- useh12*HeadLoss12(Q.old*NB, culvert=culvert,
                              approach=approach, d2=d2, otherL=Lw);

     h23 <- HeadLoss23(Q.old, culvert=culvert, d2=d2, d3=h3);

     dc3  <- getCriticalDepth(Q.old, culvert=culvert,
                              location="outlet",
                              depression=culvert$outlet.depression);

     H <- h1 + v1head - h12 - h3 - h23;
     if(H < 0) {
          # conclude not type 6
          Q <- list(Q=NA, error=NA, its=its,
                    C=C,
                    d2=d2,
                    Ao=Ao,
                    Ko=Ko,
                    h1=h1,
                    d3=NA,
                    A3=NA,
                    K3=NA,
                    d3c=NA,
                    h12=NA,
                    h23=NA,
                    v1head=v1head,
                    H=NA,
                    L=L,
                    g=g,
                    terminalarea=NA,
                    konvey2=NA,
                    isType6=FALSE,
                    valid=FALSE,
                    roadflow=roadflow,
                    message="H < 0, trapping sqrt(x<0)",
                    Qbyfig17=Qbyfig17);
        return(Q);
     }
     Q <- C*Ao*sqrt(g2*H);

     if(! is.finite(Q)) {
        stop("Infinite Q determined for Type 6, v1head likely growing unbounded, try larger approach section or reducing fraction of total flow normal to inlet");
     }

     if(abs(Q-Q.old)/Q.old < eps | its > maxits)  break;
     Q.old <- Q;
  }
  Q <- list(Q=round(Q*NB, digits=digits),
            error=(Q-Q.old)*NB,
            its=its,
            C=C,
            d2=d2,
            Ao=Ao,
            Ko=Ko,
            h1=h1,
            d3=h3,
            A3=A3,
            K3=K3,
            d3c=dc3,
            h12=h12,
            h23=h23,
            v1head=v1head,
            H=H,
            L=L,
            g=g,
            terminalarea=Ao,
            konvey2=Ko,
            isType6=test56$isType6,
            valid=test56$isType6,
            roadflow=roadflow,
            message="",
            Qbyfig17=Qbyfig17);
  return(Q);
  # Jain (2001, p. 313) reports h3 on the interval [D/2, D] because although
  # barrel is full, D is not a good estimate of pressure head
}



"printType6" <-
function(flow=NULL, culvert=culvert, approach=approach,
         splash=TRUE, checkvalid=TRUE) {
  if(checkvalid & ! flow$valid) return(NA);

  lunits <- culvert$lengthunits;
  qunits <- culvert$flowunits;
  aunits <- culvert$areaunits;

  catme("  Depth (at crown) at inlet", round(flow$d2, digits=3),lunits);
  catme("    Area (naught) at inlet", round(flow$Ao, digits=2),aunits);
  catme("    Conveyance (naught) at inlet",
                                      round(flow$Ko, digits=0),qunits);
  catme("  Depth at outlet", round(flow$d3, digits=3),lunits);
  catme("    Area at outlet", round(flow$A3, digits=2),aunits);
  catme("    Conveyance at outlet", round(flow$K3, digits=0),qunits);
  catme("    Critical depth at outlet", round(flow$d3c, digits=3),lunits);
  catme("  Length of culvert", round(flow$L, digits=2),lunits);
  catme("  Headloss between approach and inlet", round(flow$h12,
                                                       digits=3),lunits);
  catme("  Headloss between inlet and outlet", round(flow$h23,
                                                       digits=3),lunits);
  catme("  Approach velocity head", round(flow$v1head, digits=3),lunits);

  catme("  ***Results from figure 17 of TWRI based on Cap97.08c FORTRAN***");
  catme("    Discharge is",
                                    round(flow$Qbyfig17$Q, digits=4),qunits);
  catme("      Headwater divided by diameter is",
                                    round(flow$Qbyfig17$H.over.D, digits=2));
  catme("      Correction factor Kf is",
                          round(flow$Qbyfig17$Kf, digits=2),
              "from X term of", round(flow$Qbyfig17$X, digits=2));
  catme("      Q divided by (Ao * sqrt(diameter)) is",
                              round(flow$Qbyfig17$Q.over.AorootD, digits=2));

  pdffile <- paste(c("TMPcapR_culvert",
                     culvert$TMP.key, "_inletoutlet.pdf"), collapse="");
  pdf(pdffile);
  graphCulvert(discharge=flow$Q,
               depth=culvert$diameter-culvert$inlet.depression,
               culvert=culvert, location="inlet",
               depression=culvert$inlet.depression);
  graphCulvert(discharge=flow$Q, depth=flow$d3,
               culvert=culvert, location="outlet",
               depression=culvert$outlet.depression);
  dev.off();

}


"getH3forType6" <-
function(h4=NULL, discharge=NULL, culvert=NULL,
         byoutletpressure=TRUE, supportedjet=FALSE) {
   if(byoutletpressure) {
      ratio <- piezoLevelRatioType6(discharge=discharge,
                                    culvert=culvert,
                                    supportedjet=supportedjet);
      #catme("piezoLevelRatioType6",ratio);
      return(ratio*culvert$diameter);
   }

   D  <- culvert$diameter;
   D.over.2 <- D/2;

   yc  <- getCriticalDepth(discharge, culvert=culvert);
   if(is.na(yc)) { # guessing again to keep process running
     ifelse(culvert$type == "box", h3 <- 0.65*D, h3 <- 0.75*D);
   }
   ifelse(h4 > yc, h3 <- h4, h3 <- yc);

   ycD2 <- (yc + D)/2; # Sturm (2010, p. 256-257)
   #ifelse(h4 > ycD2, h3 <- h4, h3 <- ycD2);
   if(h3 < D.over.2) h3 <- D.over.2; # set minimum (Jain, 2001, p.313)
   #  # AND TWRI p. 6 and p. 34;

   #h3 <- D;

   #geo <- setCulvertGeometry(depth=h3, culvert=culvert);
   #A3  <- geo$A;
   #v3head  <- (discharge/A3)^2/(2*culvert$gravity);
   #catme("getH3forType6, Q",discharge);
   #catme("getH3forType6, A3",A3);
   #catme("getH3forType6, yc=",yc);
   #catme("getH3forType6, h4=",h4);
   #catme("getH3forType6, h3=",h3);
   #catme("getH3forType6, D=",D);
   #catme("getH3forType6, (yc+D)/2=",ycD2);
   #catme("getH3forType6, v3head=",v3head);

   return(h3);
}



"QType6byFig17" <-
function(h1=NULL, C=C, culvert=NULL, switchKF=TRUE, ...) {

  L <- culvert$Ltop;
  D <- culvert$diameter;
  Ao <- culvert$Ao.inlet;
  Ro <- culvert$Ro.inlet;
  g  <- culvert$gravity;
  nvalue <- culvert$nvalue;
  manningcor <- culvert$manningcor;

  # IMPLEMENTING FIGURE 17
  # note that in original fortran source that nvalue^2 is missing
  # in the discharg.f file of the Cap97.08c sources (other conversions
  # in culvert.f)
  X <- 2*g * nvalue^2 * L / (manningcor^2 * Ro^(4/3)); # step 3 of TWRI, p.31

  # USING TWRI example 8 with Q=209
  # NOTE THAT switchFW=TRUE provides a Q=216
  #           switchFW=FALSE provides a Q=221
  # my dynamic computation of h3 provides Q=217
  if(switchKF) { # FROM discharg.f
    KF1 <- 1.222081  + X*(-0.39096055 + X*(0.10127278 - X*0.010547583));
    KF2 <- 1.6475101 + X*(-0.56519116 + X*(0.12983789 - X*0.011096691));
  } else { # FROM culvert.f
    KF1 <- 1.2002 + X*(-0.37526  +
                    X*( 0.13410  +
                    X*(-0.034714 +
                    X*(0.0047746 - X*0.00023996))));
    KF2 <- 1.7713 + X*(-0.93433 +
                    X*( 0.48185 +
                    X*(-0.14896 +
                    X*( 0.02349 - X*0.0014455))));
  }


  if(C < 0.76) {
    KF <- KF1;
  } else if(C >= 1.0) { # but C can not be >= 1.0??
    KF <- KF2;
  } else {
    KF <- KF1 + 4.166666 * (C-0.76) * (KF2-KF1);
  }
  # KF completes step 4 of TWRI, p.31

  HQ1 <- h1/D; # step 1 of TWRI, p.31 (C provided as argument)


  QRAT <- HQ1*(4.7693-HQ1*(0.68351 - .044726*HQ1)) - 1.8368;
  QRAT <- HQ1*(7.2458-HQ1*(1.8350  - HQ1*(0.26087+0.014075*HQ1))) - 3.6183;
  # step 2 of TWRI, p.31 is completed

  QRAT1 <- QRAT*KF; # step 5 of TWRI, p. 31
      Q <- QRAT1*Ao*sqrt(D); # step 6 of TWRI, p. 31

  return(list(Q=Q, Kf=KF,
              H.over.D=HQ1,
              X=X,
              Q.over.AorootD=QRAT));
}





################################################################
##    capR Source File ./Hydraulics/FlowTypes/TWRIfigure15.R
################################################################
TWRIfigure15.h <- new.h();
set.h("svals",
      matrix(
      c(-0.10,  -0.10,  -0.10,  -0.10,  -0.10,  -0.10, -0.10,
        -0.10,  -0.10,  -0.10,  -0.10,  -0.10,  -0.10, -0.10,
        -0.098, -0.098, -0.098, -0.097, -0.096, -0.091, 0.09,
        -0.081, -0.078, -0.074, -0.069, -0.056,  0.0,   0.094,
        -0.058, -0.049, -0.042, -0.029,  0.0,    0.015, 0.101,
        -0.041, -0.029, -0.019,  0.0,    0.029,  0.025, 0.105,
        -0.027, -0.012,  0.0,    0.009,  0.047,  0.034, 0.108,
        -0.017,  0.0,    0.003,  0.017,  0.058,  0.040, 0.111,
        -0.005,  0.002,  0.006,  0.023,  0.061,  0.047, 0.114,
         0.0,    0.003,  0.008,  0.030,  0.064,  0.051, 0.115,
         0.002,  0.010,  0.022,  0.042,  0.069,  0.100, 0.136,
         0.003,  0.011,  0.024,  0.043,  0.070,  0.102, 0.141,
         0.004,  0.012,  0.025,  0.044,  0.070,  0.104, 0.146,
         0.006,  0.013,  0.026,  0.045,  0.071,  0.108, 0.155,
         0.069,  0.073,  0.086,  0.105,  0.114,  0.294, 0.596),
      byrow=TRUE, ncol=7),
      TWRIfigure15.h);
set.h("rndnode", c(0.0, 0.01, 0.02, 0.03, 0.04, 0.05, 0.06),
      TWRIfigure15.h);
set.h("ldnode", c( 0.0,  4.4,  4.5,  5.5,  6.9,  7.9, 8.7, 9.3,
                  10.0, 10.3, 15.0, 20.0, 25.0, 35.0, 500),
      TWRIfigure15.h);


"TWRIfigure15" <-
function(culvert=NULL) {
   D    <- culvert$diameter - culvert$inlet.depression;
   L    <- culvert$Ltop;
   So   <- culvert$So;
   rnd  <- culvert$rounding;
   bev  <- culvert$beveling;
   if(bev > rnd) rnd <- bev;

   LD <- L/D;

   svals   <- get.h("svals", TWRIfigure15.h);
   rndnode <- get.h("rndnode", TWRIfigure15.h);
   if(rnd > max(rndnode)) rnd <- max(rndnode);

   ldnode <- get.h("ldnode", TWRIfigure15.h);

   n.ldnode <- length(ldnode)
   min.ldnode <- min(ldnode); max.ldnode <- max(ldnode);
   nodes <- 1:n.ldnode; #rnds <- seq(0,0.06, by=0.001);
   fig15 <- NA;
   #catme("FIGURE15 start LD:",LD);
   #catme("FIGURE15 rnd:",rnd);
   if(LD < min.ldnode) {
     #catme("FIGURE15 LD < min.ldnode");
     fig15 <- approx(x=rndnode, y=svals[1,], xout=rnd)$y;
   } else if(LD > max.ldnode) {
     #catme("FIGURE15 LD > max.ldnode");
     fig15 <- approx(x=rndnode, y=svals[n.ldnode,], xout=rnd)$y;
   } else {
     j <- nodes[ldnode == LD];
     #catme("FIGURE15 j",j);
   	 if(length(j) != 0) {
   	   fig15 <- approx(x=rndnode, y=svals[j,], xout=rnd)$y;
   	 } else {
   	    j1 <- max(nodes[ldnode < LD]); j2 <- min(nodes[ldnode > LD]);
        #catme("FIGURE15 j1/j2",j1,j2);
        y <- c(approx(x=rndnode, y=svals[j1,], xout=rnd)$y,
               approx(x=rndnode, y=svals[j2,], xout=rnd)$y);
       #catme("FIGURE15 y",y);
       fig15 <- approx(x=ldnode[c(j1,j2)], y=y, xout=LD)$y;
     }
   }
   #catme("FIGURE15 fig15",fig15);

   ifelse(So > fig15, type <- 5, type <- 6);
   #catme("FIGURE15 type",type);
   return(type);
}


################################################################
##    capR Source File ./Hydraulics/FlowTypes/TWRIfigure16.R
################################################################
"TWRIfigure16" <-
function(h1=NULL, culvert=NULL) {
   D      <- culvert$diameter - culvert$inlet.depression;
   L      <- culvert$Ltop;
   So     <- culvert$So;
   g      <- culvert$gravity;
   z      <- culvert$z;
   Ro     <- culvert$Ro.inlet;
   nvalue <- culvert$nvalue;
   manningcor <- culvert$manningcor;


   rnd  <- culvert$rounding;
   bev  <- culvert$beveling;
   if(bev > rnd) rnd <- bev;

   if(rnd > 0.03) rnd <- 0.03;

   LD <- L/D;
   if(LD > 500) LD <- 500;
   #catme("FIGURE16 LD",LD);
   
   rndnode <- c(0, 0.01, 0.02, 0.03);
   
   X <- (2*g*nvalue^2*(h1-z)) / (manningcor^2 * Ro^(4/3));
   Xnode <- c(0, 0.10, 0.15, 0.20, 0.25, 0.30, 0.60);
   if(X > max(Xnode)) X <- max(Xnode);
   #catme("FIGURE16 X",X);

   SLOPES0.00 <- c(-0.037, -0.033, -0.031, -0.029, -0.027, -0.025, -0.013,
                   -0.015, -0.011, -0.009, -0.007, -0.005,  0.0,    0.030,
                   -0.012, -0.006, -0.003, -0.002,  0.0,    0.006,  0.041,
                   -0.011, -0.005,  0.002,  0.0,    0.002,  0.008,  0.044,
                   -0.006, -0.003,  0.0,    0.001,  0.003,  0.010,  0.048,
                   -0.004,  0.0,    0.002,  0.004,  0.007,  0.014,  0.054,
                   -0.001,  0.003,  0.005,  0.009,  0.013,  0.021,  0.068,
                      0.0,  0.010,  0.015,  0.024,  0.033,  0.044,  0.109,
                    0.002,  0.016,  0.025,  0.039,  0.053,  0.067,  0.151,
                    0.007,  0.019,  0.032,  0.048,  0.065,  0.082,  0.184,
                    0.010,  0.020,  0.035,  0.052,  0.069,  0.086,  0.188,
                    0.012,  0.020,  0.036,  0.053,  0.071,  0.089,  0.197,
                    0.015,  0.025,  0.040,  0.060,  0.090,  0.120,  0.250);


   svals0.00  <- matrix(SLOPES0.00, byrow=TRUE, ncol=7);
   ldnode0.00 <- c( 0.0,  5.5,  6.8,  7.2,  7.6, 8.4, 10.0,
                  15.0, 20.0, 25.0, 30.0, 35.0, 500.0);
               
               
   SLOPES0.01 <- c(-0.095, -0.082, -0.076, -0.069, -0.063, -0.056, -0.017,
                   -0.041, -0.028, -0.022, -0.017, -0.012,  0.0,    0.041,
                   -0.028, -0.016, -0.010, -0.006,  0.0,    0.013,  0.054,
                   -0.022, -0.010, -0.004,  0.0,    0.007,  0.016,  0.060,
                   -0.018, -0.006,  0.0,    0.050,  0.010,  0.019,  0.064,
                   -0.012,  0.0,    0.006,  0.010,  0.015,  0.023,  0.071,
                    0.004,  0.010,  0.013,  0.017,  0.022,  0.030,  0.078,
                    0.008,  0.018,  0.023,  0.033,  0.042,  0.053,  0.119,
                    0.010,  0.023,  0.033,  0.047,  0.060,  0.073,  0.151,
                    0.011,  0.027,  0.040,  0.056,  0.072,  0.088,  0.166,
                    0.013,  0.028,  0.043,  0.060,  0.077,  0.094,  0.194,
                    0.014,  0.028,  0.044,  0.061,  0.080,  0.099,  0.213,
                    0.025,  0.037,  0.053,  0.075,  0.102,  0.132,  0.283);

   svals0.01  <- matrix(SLOPES0.01, byrow=TRUE, ncol=7);
   ldnode0.01 <- c( 0.0,  5.3,  6.5,  7.1,  7.5, 8.1, 10.0,
                   15.0, 20.0, 25.0, 30.0, 35.0, 500.0);
                   
   
   SLOPES0.02 <- c(-0.357, -0.301, -0.273, -0.246, -0.218, -0.190, -0.024,
                   -0.146, -0.110, -0.089, -0.065, -0.036,  0.0,    0.037,
                   -0.104, -0.072, -0.052, -0.029,  0.0,    0.020,  0.057,
                   -0.070, -0.042, -0.022,  0.0,    0.015,  0.027,  0.061,
                   -0.045, -0.019,  0.0,    0.012,  0.021,  0.027,  0.069,
                   -0.024,  0.0,    0.012,  0.020,  0.026,  0.033,  0.075,
                    0.013,  0.021,  0.025,  0.030,  0.035,  0.044,  0.098,
                    0.017,  0.031,  0.038,  0.045,  0.055,  0.066,  0.132,
                    0.020,  0.036,  0.047,  0.060,  0.074,  0.088,  0.172,
                    0.023,  0.039,  0.053,  0.069,  0.085,  0.101,  0.197,
                    0.025,  0.041,  0.056,  0.074,  0.092,  0.110,  0.218,
                    0.026,  0.041,  0.057,  0.075,  0.093,  0.111,  0.219,
                    0.035,  0.048,  0.067,  0.090,  0.113,  0.143,  0.317);
   svals0.02  <- matrix(SLOPES0.02, byrow=TRUE, ncol=7);
   ldnode0.02 <- c( 0.0,  5.0,  6.0,  6.8,  7.4, 7.9, 10.0,
                   15.0, 20.0, 25.0, 30.0, 35.0, 500.0);

   SLOPES0.03 <- c(-1.121, -0.920, -0.820, -0.720, -0.619, -0.519, 0.083,
                   -0.498, -0.387, -0.308, -0.232, -0.160,  0.0,   0.090,
                   -0.280, -0.200, -0.128, -0.061,  0.0,    0.033, 0.093,
                   -0.202, -0.133, -0.064,  0.0,    0.023,  0.037, 0.094,
                   -0.124, -0.067,  0.0,    0.023,  0.029,  0.041, 0.095,
                   -0.046,  0.0,    0.023,  0.039,  0.036,  0.045, 0.096,
                    0.006,  0.022,  0.030,  0.035,  0.041,  0.049, 0.097,
                    0.032,  0.040,  0.044,  0.049,  0.055,  0.062, 0.104,
                    0.038,  0.050,  0.056,  0.064,  0.074,  0.084, 0.144,
                    0.035,  0.055,  0.065,  0.079,  0.093,  0.107, 0.191,
                    0.032,  0.060,  0.074,  0.088,  0.102,  0.116, 0.200,
                    0.028,  0.060,  0.076,  0.092,  0.108,  0.124, 0.220,
                    0.045,  0.060,  0.080,  0.105,  0.125,  0.155, 0.350);
   svals0.03  <- matrix(SLOPES0.03, byrow=TRUE, ncol=7);
   ldnode0.03 <- c( 0.0,  4.0,  5.4,  5.9,  6.4, 6.9, 7.5, 10.0,
                   15.0, 20.0, 27.5, 35.0, 500.0);
   
   
   "getfromFigs16ABCD" <-
   function(LD=NULL, X=NULL, svals=NULL, ldnode=NULL, Xnode=NULL) {
      n.ldnode <- length(ldnode)
      min.ldnode <- min(ldnode); max.ldnode <- max(ldnode);
      nodes <- 1:n.ldnode;
      if(LD < min.ldnode) {
        #catme("FIGURE16 LD < min.ldnode");
        fig16 <- approx(x=Xnode, y=svals[1,], xout=X)$y;
      } else if(LD > max.ldnode) {
        #catme("FIGURE16 LD > max.ldnode");
        fig16 <- approx(x=Xnode, y=svals[n.ldnode,], xout=X)$y;
      } else {
        j <- nodes[ldnode == LD];
        #catme("FIGURE16 j",j);
   	    if(length(j) != 0) {
   	      fig16 <- approx(x=Xnode, y=svals[j,], xout=X)$y;
   	    } else {
   	      j1 <- max(nodes[ldnode < LD]); j2 <- min(nodes[ldnode > LD]);
          #catme("FIGURE16 j1/j2",j1,j2);
          #catme("FIGURE16 svals[j1,]",svals[j1,]);
          #catme("FIGURE16 svals[j2,]",svals[j2,]);
          #catme("FIGURE16 Xnode",Xnode);
          y <- c(approx(x=Xnode, y=svals[j1,], xout=X)$y,
                 approx(x=Xnode, y=svals[j2,], xout=X)$y);
         #catme("FIGURE16 y",y);
         fig16 <- approx(x=ldnode[c(j1,j2)], y=y, xout=LD)$y;
        }
      }
      return(fig16);
   }
  
   
 
   slope0.00 <- getfromFigs16ABCD(LD=LD, X=X, svals=svals0.00, ldnode=ldnode0.00, Xnode=Xnode);
   slope0.01 <- getfromFigs16ABCD(LD=LD, X=X, svals=svals0.01, ldnode=ldnode0.01, Xnode=Xnode);
   slope0.02 <- getfromFigs16ABCD(LD=LD, X=X, svals=svals0.02, ldnode=ldnode0.02, Xnode=Xnode);
   slope0.03 <- getfromFigs16ABCD(LD=LD, X=X, svals=svals0.03, ldnode=ldnode0.03, Xnode=Xnode);
   #catme("FIGURE16 slope0.00",slope0.00);
   #catme("FIGURE16 slope0.01",slope0.01);
   #catme("FIGURE16 slope0.02",slope0.02);
   #catme("FIGURE16 slope0.03",slope0.03);
 
   fig16 <- approx(x=rndnode,
                   y=c(slope0.00, slope0.01, slope0.02, slope0.03),
                   xout=rnd)$y; 
  
   #catme("FIGURE16 fig16",fig16);
   ifelse(So > fig16, type <- 5, type <- 6);
   #catme("FIGURE16 type",type);
   return(type);
}


################################################################
##    capR Source File ./Hydraulics/FlowTypes/TypeClassification.R
################################################################
"TypeClassification" <-
function(h1=NULL, h4=NULL, culvert=NULL, ...) {

  h1 <- h1 - culvert$zdsinvert;
  h4 <- h4 - culvert$zdsinvert;

  if(h1 <= h4) stop("Upstream depth is <= downstream depth");

  d3 <- culvert$diameter - culvert$outlet.depression;
  HzD <- HeadwtrDiaRatio(h1=h1, culvert=culvert);
  if(h4/d3 > 1) {
     if(HzD >= 1.5)  return(c(4));
     So <- culvert$So;
     zdsinvert <- culvert$zdsinvert;
     if(So == 0) return(c(3)); # trapping division by zero
     L.prime <- (h4 - d3)/So;
     Ltop <- culvert$Ltop;
     Lbot <- culvert$Lbot;
     Ltop.new <- Ltop - L.prime;
     Lbot.new <- Lbot - L.prime;
     zdsinvert.new <- culvert$zdsinvert + L.prime*So;
     if(Ltop.new > 0 && Ltop.new < Ltop &&
        Lbot.new > 0 && Lbot.new < Lbot &&
        zdsinvert.new < zdsinvert) {
        culvert$Ltop <- Ltop.new;           # DANGER modifying the culvert
        culvert$Lbot <- Lbot.new;           # DANGER modifying the culvert
        culvert$zdsinvert <- zdsinvert.new; # DANGER modifying the culvert
     }
     #catme("new Ltop",Ltop.new);
     #catme("new Lbot",Lbot.new);
     #catme("new zdsinvert", zdsinvert.new);
     #catme("submerged outlet, but not inlet\n\n");
     return(c(1,3));
  }
  # remainder imply h4/d2 <= 1
  if(HzD <  1.5) return(c(1,2,3));
  if(HzD >= 1.5) return(c(5,6  ));
}
# TWRI p.3


################################################################
##    capR Source File ./nwis/nwts2capR.R
################################################################
"nwts2capR" <-
function(method=nwts2capR.ssh, ...) {
  return(method(...));
}

"nwts2capR.sql" <-
function() {
  stop("stub out");
}

"nwts2capR.nwisweb" <-
function() {
  stop("stub out");
}


"nwts2capR.ssh" <-
function(agency="USGS",
         host="somehost.cr.usgs.gov",
         path="./",
         program="capRwyuv.pl",
         user="someuser",
         station="08123620",
         stat="C",
         hw=1, tw=4,
         beg="1001", end="0930",
         wy=format(Sys.time(), "%Y"),
         yy=NULL,
         workingok=FALSE,
         compress=TRUE,
         test=FALSE,
         noget=FALSE,
         unlink=TRUE,
         verbose=FALSE) {

   # if the yy is not provided, use the wy from the argument
   # this way the "program" is not called with TWO separate
   # year arguments
   if(! is.null(yy)) {
      year <- paste(c("-yy=",yy," "), collapse="");
   } else {
      year <- paste(c("-wy=",wy," "), collapse="");
   }
   # compress the ssh session, good for slow networks
   compress <- ifelse(compress, "-z ",     " ");

   # get working record as well as approved?
   working  <- ifelse(workingok, "-workingok",  " ");
   # do not actually make the ssh retrieval, pretend that it
   # has happened and continue processing
   noget    <- ifelse(noget,    "-noget ", " ");
   com <- paste(c(path,program," ",
                  "-user=",user," ",
                  "-host=",host," ",
                  year,
                  "-a=",agency," ",
                  "-s=",stat," ",
                  "-hw=",hw," ",
                  "-tw=",tw," ",
                  "-b=",beg," ",
                  "-e=",end," ",
                  compress,
                  working,
                  noget,
                  station), collapse="");

   if(verbose || test) {
      message(com); # show the command, helpful in debugging
      message("Unit values of headwater in TMP4capR_uvHW.rdb");
      message("Unit values of tailwater in TMP4capR_uvTW.rdb");
      message("Standard error of external command is in TMP4capR_STDERR.txt");
      if(test) return(NA);
   }

   system(com); # EXTERNAL COMMAND
   if(unlink) {
      message("Unlinking the temporary files created by this function");
      try(unlink("TMP4capR_uvHW.rdb")  );
      try(unlink("TMP4capR_uvTW.rdb")  );
      try(unlink("TMP4capR_STDERR.txt"));
   }
}


"read.nwts2capR" <-
function(unlink=TRUE, savefile="TMP4capR_read_nwts2capR.RData") {
   HW <- TW <- HWTW <- DT <- NULL;
   try(HW    <- read.table("TMP4capR_HW.txt", sep="|", header=TRUE, stringsAsFactors=FALSE));
   if(is.null(HW)) {
      warning("Headwater file was not found");
      warning("Try manually changing directory with setwd()?");
      warning("Assuming tail, head and tail, and date files not available, returning NA");
      return(NA);
   }
   try(TW    <- read.table("TMP4capR_TW.txt",        sep="|", header=TRUE, stringsAsFactors=FALSE));
   try(HWTW  <- read.table("TMP4capR_HWTWinter.txt", sep="|", header=TRUE, stringsAsFactors=FALSE));
   try(DT    <- read.table("TMP4capR_alldates.txt",  sep="|", header=TRUE, stringsAsFactors=FALSE));
   if(unlink) {
      message("Unlinking the temporary files created by this function");
      try(unlink("TMP4capR_HW.txt")        );
      try(unlink("TMP4capR_TW.txt")        );
      try(unlink("TMP4capR_HWTWinter.txt") );
      try(unlink("TMP4capR_alldates.txt")  );

      message("Unlinking the savefile");
      try(unlink(savefile));
   }
   # Head water and tail water retrievals are now loaded, at this point
   # there is no guarantee that they have the same dates, hopefully
   # quite close in time (few minutes). The union of the dates is used
   # for the xout and approx() does linear interpolation with flat line
   # edge estimation (rule=2).
   HWapprox  <- approx(HW$DAYS, y=HW$HW, DT$DAYS, rule=2);
   TWapprox  <- approx(TW$DAYS, y=TW$TW, DT$DAYS, rule=2);
   HWTWunion <- data.frame(DATE=DT$DATE,
                           DAYS=round(DT$DAYS, digits=5),
                           HW=round(HWapprox$y, digits=2),
                           TW=round(TWapprox$y, digits=2));
   nwts2capR.RData <- list(headwater=HW,
                           tailwater=TW,
                           intersection.of.head.and.tailwater=HWTW,
                           union.of.dates=DT,
                           union.of.head.and.tailwater=HWTWunion,
                           message="");
   if(! file.exists(savefile)) {
      message("The savefile does not exist, testing whether to create one");
      if(! is.na(savefile)) {
        message(paste(c("savefile= ",savefile," now being written."),
                      collapse=""));
        try(save(nwts2capR.RData, file=savefile));
      } else {
        message("savefile=NA, so it was not written");
      }
   }
   return(nwts2capR.RData);
}




"write.capR2nwts" <-
function(uv, file="capR2nwts.txt", capograph=NA,
             station="NNNNNNNN", col.names=FALSE, append=FALSE) {
   uv$STATION <- rep(station, length(uv[,1]))
   uv$HW   <- sprintf("%2.2f", uv$HW)
   uv$TW   <- sprintf("%2.2f", uv$TW)
   uv$DAYS <- sprintf("%5.5f", uv$DAYS)
   uv$TYPE <- capograph$abstypes
   uv$Q    <- sprintf("%2.2f", capograph$Qtotal)
   uv <- as.data.frame(uv)
   #uv <- uv[,c(5,1:4,7,6)] # reshuffle the header
   write.table(uv, file=file, row.names=FALSE, quote=FALSE,
                   append=append, col.names=col.names)

   uv$DAYS <- as.numeric(uv$DAYS)
   uv$HW   <- as.numeric(uv$HW)
   uv$TW   <- as.numeric(uv$TW)
   uv$Q    <- as.numeric(uv$Q)

   return(uv)
}

